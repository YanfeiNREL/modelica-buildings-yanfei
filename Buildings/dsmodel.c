#define DYNEventSpecial
/* DSblock model generated by Dymola from Modelica model Buildings.Applications.DHC.Loads.Examples.CouplingETS_RC_Yanfei_Cooling
 Dymola Version 2019 (64-bit), 2018-04-11 translated this at Thu Dec 19 17:21:13 2019

   */

#include <matrixop.h>
static const char* DymArrays40[1]={"SimpleLiquidWater"};
#if defined(DynSimStruct) || defined(BUILDFMU)
static double DymArrays32[3]={0.0, 0.0, 0.0};
static double DymArrays33[3]={0.0, 0.0010044335697769957, 12000.0};
static double DymArrays7[3]={5E-05, 2.5E-05, 1.040895310738997};
static double DymArrays2[3]={0.01, 0.0, 6.283185307179586};
static double DymArrays4[3]={0.01, 0.01, 0.99};
static double DymArrays1[3]={0.01, 0.01, 9.99};
static double DymArrays30[3]={1.0, 1.0, 0.0};
static double DymArrays22[3]={1.0, 1.0, 1.0};
static double DymArrays12[3]={1.0, 1.0, 2.0};
static double DymArrays9[3]={3.5, 8.0, 1.0};
static double DymArrays27[3]={4.0, 4.0, 1.0};
static double DymArrays39[3]={273.15, 0.0, 0.0};
static double DymArrays29[3]={995.586, 300000.0, 293.15};
static double DymArrays21[3]={101325.0, 293.15, 1.204114944782858};
static double DymArrays24[3]={300000.0, 293.15, 4184.0};
static double DymArrays16[4]={-2.1362830044410592, 0.6565928646002667, -28800.0,
   1.0};
static double DymArrays31[4]={0.0, 0.0010044335697769957, 12000.0, 0.0};
static double DymArrays11[4]={0.5, 0.5, 1000.0, 500.0};
static double DymArrays37[4]={0.6565928646002667, -2.1362830044410592, 
  0.6565928646002667, -2.1362830044410592};
static double DymArrays13[4]={2.0, 0.0, 0.0, 2.0};
static double DymArrays14[4]={4.0, 4.0, 4.0, 4.0};
static double DymArrays18[4]={9.0, 10.0, 11.0, 2.0};
static double DymArrays36[4]={995.586, 300000.0, 293.15, 995.586};
static double DymArrays3[4]={3600.0, 3600.0, 3600.0, 3600.0};
static double DymArrays26[4]={300000.0, 293.15, 300000.0, 293.15};
static double DymArrays10[4]={2569834.5, 25.5, 11.5, 14.0};
static double DymArrays5[5]={0.0, 0.0, 0.0, 2.0, 1.0};
static double DymArrays19[5]={0.1, 0.1, 293.15, 293.15, 297.15};
static double DymArrays35[5]={2.0, 2.0, 2.0, 2.0, 1.0};
static double DymArrays28[6]={0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
static double DymArrays15[6]={1.0, 1.0, 1.0, 1.0, 1.0, 1.0};
static double DymArrays20[6]={1.0, 2.0, 1.0, 6.0, 6.0, 6.0};
static double DymArrays34[8]={0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0};
static double DymArrays23[8]={5.0000000000000004E-08, 20000000.0, -300000000.0, 
  4.76E+16, -2.888E+24, 8.544E+31, -1.216E+39, 6.656E+45};
static double DymArrays8[8]={52.5, 2.0, 0.0, 7.0, 7.0, 7.0, 7.0, 0.09};
static double DymArrays6[9]={1.0, 1.0, 0.0, 1.0, 2.0, 1.0, 1.0, 0.0, 0.0};
static double DymArrays25[11]={5.0000000000000004E-08, 20000000.0, -300000000.0,
   4.76E+16, -2.888E+24, 8.544E+31, -1.216E+39, 6.656E+45, 300000.0, 293.15, 
  4184.0};
static double DymArrays38[12]={0.6565928646002667, -2.1362830044410592, 
  0.6565928646002667, -2.1362830044410592, 0.6565928646002667, -2.1362830044410592,
   0.6565928646002667, -2.1362830044410592, 0.6565928646002667, -2.1362830044410592,
   0.6565928646002667, -2.1362830044410592};
static double DymArrays0[12]={2.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 
  1.0, 1.0};
static double DymArrays17[27]={2.0, 3.0, 4.0, 5.0, 6.0, 11.0, 12.0, 13.0, 14.0, 
  15.0, 16.0, 17.0, 18.0, 19.0, 20.0, 21.0, 22.0, 23.0, 24.0, 25.0, 26.0, 27.0, 
  28.0, 29.0, 30.0, 8.0, 2.0};
#endif
/* Declaration of C-structs */
struct DymStruc0;
struct DymStruc1;
struct DymStruc2;
struct DymStruc0 {
  int  id_0member;
};
DYMOLA_STATIC struct DymStruc0 DymStruc0_construct(int   id_02) {
  struct DymStruc0 dummy_0;
  dummy_0.id_0member = id_02;
  return dummy_0;
}
struct DymStruc1 {
  RealArray   V_flow_0member;
  RealArray   eta_0member;
};
DYMOLA_STATIC struct DymStruc1 DymStruc1_construct(RealArray    V_flow_02, 
  RealArray    eta_02) {
  struct DymStruc1 dummy_0;
  dummy_0.V_flow_0member = V_flow_02;
  dummy_0.eta_0member = eta_02;
  return dummy_0;
}
struct DymStruc2 {
  int dummy123;
};
/* Prototypes for functions used in model */
#include <getTimeSpan.c>
DYMOLA_STATIC RealArray    Buildings_BoundaryConditions_WeatherData_BaseClasses_getTimeSpanTMY3_M
  (const char*  filNam0_0, const char*  tabNam0_0);
DYMOLA_STATIC double   Buildings_Fluid_BaseClasses_FlowModels_basicFlowFunctionx_0mx_0flow
  (double  mx_0flow, double  k0_0, double  mx_0flowx_0turbulent);
DYMOLA_STATIC double   Buildings_Fluid_BaseClasses_FlowModels_basicFlowFunctionx_0mx_0flowx_0der
  (double  mx_0flow, double  k0_0, double  mx_0flowx_0turbulent, double  
  mx_0flowx_0der);
DYMOLA_STATIC double   Buildings_Fluid_HeatExchangers_BaseClasses_Internal_fx_0nonlinear
  (double  x0_0, double  p0_0, RealArray   X0_0, struct DymStruc2 
  fx_0nonlinearx_0data);
DYMOLA_STATIC double   Buildings_Fluid_HeatExchangers_BaseClasses_epsilonx_0C(
  double  UA0_0, double  C1x_0flow, double  C2x_0flow, int  flowRegime0_0, 
  double  CMinx_0flowx_0nominal, double  CMaxx_0flowx_0nominal, double  delta0_0);
DYMOLA_STATIC double   Buildings_Fluid_HeatExchangers_BaseClasses_epsilonx_0ntuZ
  (double  NTU0_0, double  Z0_0, int  flowRegime0_0);
DYMOLA_STATIC double   Buildings_Fluid_HeatExchangers_BaseClasses_ntux_0epsilonZ
  (double  eps0_0, double  Z0_0, int  flowRegime0_0);
DYMOLA_STATIC double   Buildings_Fluid_HeatExchangers_BaseClasses_solvex_0Unique15
  (double  yx_0zero, double  xx_0min, double  xx_0max, double  pressure0_0, 
  RealArray   X0_0, struct DymStruc2 fx_0nonlinearx_0data, double  xx_0tol);
DYMOLA_STATIC double   Buildings_Fluid_Movers_BaseClasses_Characteristics_efficiency
  (struct DymStruc1 per0_0, double  Vx_0flow, RealArray   d0_0, double  rx_0N, 
  double  delta0_0);
DYMOLA_STATIC const char*   Buildings_Fluid_Movers_BaseClasses_FlowMachineInterface_getArrayAsString
  (RealArray   array0_0, const char*  varName0_0, int  minimumLength0_0, int  
  significantDigits0_0);
DYMOLA_STATIC RealArray    Buildings_ThermalZones_ReducedOrder_RC_BaseClasses_splitFacVal
  (int  nRow0_0, int  nCol0_0, RealArray   AArray0_0, RealArray   AExt0_0, 
  RealArray   AWin0_0);
DYMOLA_STATIC double   Buildings_Utilities_Math_Functions_BaseClasses_smoothTransition
  (double  x0_0, double  delta0_0, double  deltaInv0_0, double  a0_0, double  
  b0_0, double  c0_0, double  d0_0, double  e0_0, double  f0_0);
DYMOLA_STATIC double   Buildings_Utilities_Math_Functions_cubicHermiteLinearExtrapolation
  (double  x0_0, double  x10_0, double  x20_0, double  y10_0, double  y20_0, 
  double  y1d0_0, double  y2d0_0);
DYMOLA_STATIC int   Buildings_Utilities_Math_Functions_isMonotonic(RealArray   
  x0_0, int  strict0_0);
DYMOLA_STATIC double   Buildings_Utilities_Math_Functions_regNonZeroPower(double 
   x0_0, double  n0_0, double  delta0_0);
DYMOLA_STATIC double   Buildings_Utilities_Math_Functions_regStep(double  x0_0, 
  double  y10_0, double  y20_0, double  xx_0small);
DYMOLA_STATIC double   Buildings_Utilities_Math_Functions_smoothLimit(double  
  x0_0, double  l0_0, double  u0_0, double  deltaX0_0);
DYMOLA_STATIC double   Buildings_Utilities_Math_Functions_smoothMax(double  
  x10_0, double  x20_0, double  deltaX0_0);
DYMOLA_STATIC double   Buildings_Utilities_Math_Functions_smoothMin(double  
  x10_0, double  x20_0, double  deltaX0_0);
DYMOLA_STATIC double   Buildings_Utilities_Math_Functions_spliceFunction(double 
   pos0_0, double  neg0_0, double  x0_0, double  deltax0_0);
DYMOLA_STATIC RealArray    Buildings_Utilities_Math_Functions_splineDerivatives(
  RealArray   x0_0, RealArray   y0_0, int  ensureMonotonicity0_0);
struct Modelica_Blocks_Continuous_Internal_Filter_Utilities_toHighestPowerOne_struct {
  RealArray    cr0_0_0member;
  RealArray    c00_0_0member;
  RealArray    c10_0_0member;
};
DYMOLA_STATIC struct Modelica_Blocks_Continuous_Internal_Filter_Utilities_toHighestPowerOne_struct
   Modelica_Blocks_Continuous_Internal_Filter_Utilities_toHighestPowerOne(
  RealArray   den10_0, RealArray   den20_0);
DYMOLA_STATIC RealArray    Modelica_Blocks_Continuous_Internal_Filter_base_CriticalDamping
  (int  order0_0, int  normalized0_0);
struct Modelica_Blocks_Continuous_Internal_Filter_coefficients_lowPass_struct {
  RealArray    cr0_0_0member;
  RealArray    c00_0_0member;
  RealArray    c10_0_0member;
};
DYMOLA_STATIC struct Modelica_Blocks_Continuous_Internal_Filter_coefficients_lowPass_struct
   Modelica_Blocks_Continuous_Internal_Filter_coefficients_lowPass(RealArray   
  crx_0in, RealArray   c0x_0in, RealArray   c1x_0in, double  fx_0cut);
struct Modelica_Blocks_Continuous_Internal_Filter_roots_lowPass_struct {
  RealArray    r0_0_0member;
  RealArray    a0_0_0member;
  RealArray    b0_0_0member;
  RealArray    ku0_0_0member;
};
DYMOLA_STATIC struct Modelica_Blocks_Continuous_Internal_Filter_roots_lowPass_struct
   Modelica_Blocks_Continuous_Internal_Filter_roots_lowPass(RealArray   crx_0in,
   RealArray   c0x_0in, RealArray   c1x_0in, double  fx_0cut);
DYMOLA_STATIC double   Modelica_Blocks_Sources_CombiTimeTable_getNextTimeEvent_M
  (struct DymStruc0 tableID0_0, double  timeIn0_0, double  tableAvailable0_0);
DYMOLA_STATIC double   Modelica_Blocks_Sources_CombiTimeTable_getTableTimeTmax_M
  (struct DymStruc0 tableID0_0, double  tableAvailable0_0);
DYMOLA_STATIC double   Modelica_Blocks_Sources_CombiTimeTable_getTableTimeTmin_M
  (struct DymStruc0 tableID0_0, double  tableAvailable0_0);
DYMOLA_STATIC double   Modelica_Blocks_Sources_CombiTimeTable_getTableValue_M(
  struct DymStruc0 tableID0_0, int  icol0_0, double  timeIn0_0, double  
  nextTimeEvent0_0, double  prex_0nextTimeEvent, double  tableAvailable0_0);
DYMOLA_STATIC double   Modelica_Blocks_Tables_CombiTable1Ds_getTableValue_M(
  struct DymStruc0 tableID0_0, int  icol0_0, double  u0_0, double  
  tableAvailable0_0);
DYMOLA_STATIC double   Modelica_Blocks_Tables_CombiTable1Ds_readTableData_M(
  struct DymStruc0 tableID0_0, int  forceRead0_0, int  verboseRead0_0);
DYMOLA_STATIC struct DymStruc0  Modelica_Blocks_Types_ExternalCombiTable1D_M(
  const char*  tableName0_0, const char*  fileName0_0, RealArray   table0_0, 
  IntegerArray   columns0_0, int  smoothness0_0, int id_, int alwaysMakeNew_);
DYMOLA_STATIC void Modelica_Blocks_Types_ExternalCombiTable1D_destructor_M(
  void* externalCombiTable1D0_0);
DYMOLA_STATIC struct DymStruc0  Modelica_Blocks_Types_ExternalCombiTimeTable_M(
  const char*  tableName0_0, const char*  fileName0_0, RealArray   table0_0, 
  double  startTime0_0, IntegerArray   columns0_0, int  smoothness0_0, int  
  extrapolation0_0, int id_, int alwaysMakeNew_);
DYMOLA_STATIC void Modelica_Blocks_Types_ExternalCombiTimeTable_destructor_M(
  void* externalCombiTimeTable0_0);
DYMOLA_STATIC void Modelica_Fluid_Utilities_checkBoundary(const char*  
  mediumName0_0, StringArray   substanceNames0_0, int  singleState0_0, int  
  definex_0p, RealArray   Xx_0boundary, const char*  modelName0_0);
DYMOLA_STATIC double   Modelica_Fluid_Utilities_cubicHermite(double  x0_0, 
  double  x10_0, double  x20_0, double  y10_0, double  y20_0, double  y1d0_0, 
  double  y2d0_0);
DYMOLA_STATIC int   Modelica_Math_BooleanVectors_allTrue(IntegerArray   b0_0);
/* Codes used in model */

/* Flattened Modelica model:

function Buildings.BoundaryConditions.WeatherData.BaseClasses.getTimeSpanTMY3
input String filNam "Name of weather data file";
input String tabNam "Name of table on weather file";
discrete output Real timeSpan[2](unit = "s") "Start time, end time of weather data";

external "C" getTimeSpan(filNam, tabNam, timeSpan);
annotation(Include="#include <getTimeSpan.c>", IncludeDirectory="modelica://Buildings/Resources/C-Sources");
end Buildings.BoundaryConditions.WeatherData.BaseClasses.getTimeSpanTMY3;

  */
DYMOLA_STATIC RealArray    Buildings_BoundaryConditions_WeatherData_BaseClasses_getTimeSpanTMY3_M
  (const char*  filNam0_0, const char*  tabNam0_0) {
  PushContext("Buildings.BoundaryConditions.WeatherData.BaseClasses.getTimeSpanTMY3")
  {
    /* Declare outputs and temporaries */
    RealArray    timeSpan0_0;
    MarkObject retmark_ = PushMark();
    timeSpan0_0=RealTemporary( 1, 2);
    RePushMark(&retmark_);
    RealFillAssign( timeSpan0_0, 0);
    /* Start of real code */
    {
      (getTimeSpan)(filNam0_0, tabNam0_0, timeSpan0_0.data);
      }
    /* Output section */
    PopMark(retmark_);
    PopContext()
    return timeSpan0_0;
  }}

/* Flattened Modelica model:

function Buildings.Fluid.BaseClasses.FlowModels.basicFlowFunction_m_flow
discrete input Real m_flow(unit = "kg/s") "Mass flow rate in design flow direction";
discrete input Real k "Flow coefficient, k=m_flow/sqrt(dp), with unit=(kg.m)^(1/2)";
discrete input Real m_flow_turbulent(unit = "kg/s", min = 0.0) "Mass flow rate where transition to turbulent flow occurs";
discrete output Real dp(unit = "Pa", displayUnit = "Pa") "Pressure difference between port_a and port_b (= port_a.p - port_b.p)";
protected 
discrete Real dp_turbulent(start = (m_flow_turbulent/k)^2, unit = "Pa", displayUnit = "bar") "Pressure where flow changes to turbulent";
discrete Real m_flowNorm(start = m_flow/m_flow_turbulent) "Normalised mass flow rate";
discrete Real m_flowNormSq(start = m_flowNorm^2) "Square of normalised mass flow rate";
public 
algorithm 
dp := (if noEvent(abs(m_flow) > m_flow_turbulent) then noEvent((if m_flow > 0 then 1 else (if m_flow < 0 then -1 else 0)))*(m_flow/k)^2 else (0.375+(0.75-0.125*m_flowNormSq)*m_flowNormSq)*dp_turbulent*m_flowNorm);
annotation(derivative(zeroDerivative=k, zeroDerivative=m_flow_turbulent)=Buildings.Fluid.BaseClasses.FlowModels.basicFlowFunction_m_flow_der, Inline=false, smoothOrder=2);
end Buildings.Fluid.BaseClasses.FlowModels.basicFlowFunction_m_flow;

  */
DYMOLA_STATIC double   Buildings_Fluid_BaseClasses_FlowModels_basicFlowFunctionx_0mx_0flow
  (double  mx_0flow, double  k0_0, double  mx_0flowx_0turbulent) {
  PushContext("Buildings.Fluid.BaseClasses.FlowModels.basicFlowFunction_m_flow")
  {
    /* Declare outputs and temporaries */
    double   dp0_0;
    double   dpx_0turbulent;
    double   mx_0flowNorm;
    double   mx_0flowNormSq;
    dp0_0=0;
    dpx_0turbulent = sqr(divmacro(mx_0flowx_0turbulent,"m_flow_turbulent",k0_0,
      "k"));
    mx_0flowNorm = divmacro(mx_0flow,"m_flow",mx_0flowx_0turbulent,
      "m_flow_turbulent");
    mx_0flowNormSq = sqr(mx_0flowNorm);
    /* Start of real code */
      dp0_0 = IF fabs(mx_0flow) > mx_0flowx_0turbulent THEN (IF mx_0flow > 0
         THEN 1 ELSE IF mx_0flow < 0 THEN -1 ELSE 0)*sqr(divmacro(mx_0flow,
        "m_flow",k0_0,"k")) ELSE (0.375+(0.75-0.125*mx_0flowNormSq)*
        mx_0flowNormSq)*dpx_0turbulent*mx_0flowNorm;
    /* Output section */
    PopContext()
    return dp0_0;
  }}

/* Flattened Modelica model:

function Buildings.Fluid.BaseClasses.FlowModels.basicFlowFunction_m_flow_der
discrete input Real m_flow(unit = "kg/s") "Mass flow rate in design flow direction";
discrete input Real k "Flow coefficient, k=m_flow/sqrt(dp), with unit=(kg.m)^(1/2)";
discrete input Real m_flow_turbulent(unit = "kg/s", min = 0.0) "Mass flow rate where transition to turbulent flow occurs";
discrete input Real m_flow_der(unit = "kg/s2") "Derivative of mass flow rate in design flow direction";
discrete output Real dp_der "Derivative of pressure difference between port_a and port_b (= port_a.p - port_b.p)";
protected 
discrete Real dp_turbulent(start = (m_flow_turbulent/k)^2, unit = "Pa", displayUnit = "bar") "Pressure where flow changes to turbulent";
discrete Real m_flowNormSq(start = (m_flow/m_flow_turbulent)^2) "Square of normalised mass flow rate";
public 
algorithm 
dp_der := (if noEvent(abs(m_flow) > m_flow_turbulent) then noEvent((if m_flow > 0 then 1 else (if m_flow < 0 then -1 else 0)))*2*m_flow/k^2 else (0.375+(2.25-0.625*m_flowNormSq)*m_flowNormSq)*dp_turbulent/m_flow_turbulent)*m_flow_der;
annotation(derivative(order=2, zeroDerivative=k, zeroDerivative=m_flow_turbulent)=Buildings.Fluid.BaseClasses.FlowModels.basicFlowFunction_m_flow_der2, Inline=false, smoothOrder=1);
end Buildings.Fluid.BaseClasses.FlowModels.basicFlowFunction_m_flow_der;

  */
DYMOLA_STATIC double   Buildings_Fluid_BaseClasses_FlowModels_basicFlowFunctionx_0mx_0flowx_0der
  (double  mx_0flow, double  k0_0, double  mx_0flowx_0turbulent, double  
  mx_0flowx_0der) {
  PushContext("Buildings.Fluid.BaseClasses.FlowModels.basicFlowFunction_m_flow_der")
  {
    /* Declare outputs and temporaries */
    double   dpx_0der;
    double   dpx_0turbulent;
    double   mx_0flowNormSq;
    dpx_0der=0;
    dpx_0turbulent = sqr(divmacro(mx_0flowx_0turbulent,"m_flow_turbulent",k0_0,
      "k"));
    mx_0flowNormSq = sqr(divmacro(mx_0flow,"m_flow",mx_0flowx_0turbulent,
      "m_flow_turbulent"));
    /* Start of real code */
      dpx_0der = (IF fabs(mx_0flow) > mx_0flowx_0turbulent THEN divmacro((IF 
        mx_0flow > 0 THEN 1 ELSE IF mx_0flow < 0 THEN -1 ELSE 0)*2*mx_0flow,
        "noEvent((if m_flow > 0 then 1 else (if m_flow < 0 then -1 else 0)))*2*m_flow",
        sqr(k0_0),"k^2") ELSE divmacro((0.375+(2.25-0.625*mx_0flowNormSq)*
        mx_0flowNormSq)*dpx_0turbulent,"(0.375+(2.25-0.625*m_flowNormSq)*m_flowNormSq)*dp_turbulent",
        mx_0flowx_0turbulent,"m_flow_turbulent"))*mx_0flowx_0der;
    /* Output section */
    PopContext()
    return dpx_0der;
  }}

/* Flattened Modelica model:

function Buildings.Fluid.HeatExchangers.BaseClasses.epsilon_C
discrete input Real UA(unit = "W/K") "UA value";
discrete input Real C1_flow(unit = "W/K") "Enthalpy flow rate medium 1";
discrete input Real C2_flow(unit = "W/K") "Enthalpy flow rate medium 2";
input Integer flowRegime "Heat exchanger flow regime, see  Buildings.Fluid.Types.HeatExchangerFlowRegime";
discrete input Real CMin_flow_nominal(unit = "W/K") "Minimum enthalpy flow rate at nominal condition";
discrete input Real CMax_flow_nominal(unit = "W/K") "Maximum enthalpy flow rate at nominal condition";
discrete input Real delta(start = 0.001) "Small value used for smoothing";
discrete output Real eps(min = 0.0, max = 1.0) "Heat exchanger effectiveness";
protected 
discrete Real deltaCMin(unit = "W/K") "Small number for capacity flow rate";
discrete Real deltaCMax(unit = "W/K") "Small number for capacity flow rate";
discrete Real CMin_flow(unit = "W/K") "Minimum capacity flow rate";
discrete Real CMax_flow(unit = "W/K") "Maximum capacity flow rate";
discrete Real CMinNZ_flow(unit = "W/K") "Minimum capacity flow rate, bounded away from zero";
discrete Real CMaxNZ_flow(unit = "W/K") "Maximum capacity flow rate, bounded away from zero";
discrete Real gaiEps(min = 0.0, max = 1.0) "Gain used to force UA to zero for very small flow rates";
discrete Real gaiNTU(min = 1E-10, max = 1.0) "Gain used to force NTU to a number slightly above zero for very small flow rates. Because NTU is used in NTU^-(0.22), it must not be zero.";
discrete Real NTU "Number of transfer units";
discrete Real Z(min = 0.0, max = 1.0) "Ratio of capacity flow rate (CMin/CMax)";
public 
algorithm 
deltaCMin := delta*CMin_flow_nominal;
deltaCMax := delta*CMax_flow_nominal;
CMin_flow := Buildings.Utilities.Math.Functions.smoothMin(C1_flow, C2_flow, deltaCMin/4);
CMax_flow := Buildings.Utilities.Math.Functions.smoothMax(C1_flow, C2_flow, deltaCMax/4);
CMinNZ_flow := Buildings.Utilities.Math.Functions.smoothMax(CMin_flow, deltaCMin, deltaCMin/4);
CMaxNZ_flow := Buildings.Utilities.Math.Functions.smoothMax(CMax_flow, deltaCMax, deltaCMax/4);
Z := CMin_flow/CMaxNZ_flow+1E-10*deltaCMin;
gaiEps := Buildings.Utilities.Math.Functions.spliceFunction(1, 0, CMin_flow-deltaCMin, deltaCMin/2);
gaiNTU := Buildings.Utilities.Math.Functions.spliceFunction(1, delta, CMin_flow-deltaCMin, deltaCMin/2);
NTU := gaiNTU*UA/CMinNZ_flow;
eps := gaiEps*Buildings.Fluid.HeatExchangers.BaseClasses.epsilon_ntuZ(NTU, Z, flowRegime);
annotation(Inline=false, smoothOrder=1);
end Buildings.Fluid.HeatExchangers.BaseClasses.epsilon_C;

  */
DYMOLA_STATIC double   Buildings_Fluid_HeatExchangers_BaseClasses_epsilonx_0C(
  double  UA0_0, double  C1x_0flow, double  C2x_0flow, int  flowRegime0_0, 
  double  CMinx_0flowx_0nominal, double  CMaxx_0flowx_0nominal, double  delta0_0)
   {
  PushContext("Buildings.Fluid.HeatExchangers.BaseClasses.epsilon_C")
  {
    /* Declare outputs and temporaries */
    double   eps0_0;
    double   deltaCMin0_0;
    double   deltaCMax0_0;
    double   CMinx_0flow;
    double   CMaxx_0flow;
    double   CMinNZx_0flow;
    double   CMaxNZx_0flow;
    double   gaiEps0_0;
    double   gaiNTU0_0;
    double   NTU0_0;
    double   Z0_0;
    eps0_0=0;
    deltaCMin0_0=0;
    deltaCMax0_0=0;
    CMinx_0flow=0;
    CMaxx_0flow=0;
    CMinNZx_0flow=0;
    CMaxNZx_0flow=0;
    gaiEps0_0=0;
    gaiNTU0_0=0;
    NTU0_0=0;
    Z0_0=0;
    /* Start of real code */
      deltaCMin0_0 = delta0_0*CMinx_0flowx_0nominal;
      deltaCMax0_0 = delta0_0*CMaxx_0flowx_0nominal;
      CMinx_0flow = Buildings_Utilities_Math_Functions_smoothMin(C1x_0flow, 
        C2x_0flow, deltaCMin0_0/(double)(4));
      CMaxx_0flow = Buildings_Utilities_Math_Functions_smoothMax(C1x_0flow, 
        C2x_0flow, deltaCMax0_0/(double)(4));
      CMinNZx_0flow = Buildings_Utilities_Math_Functions_smoothMax(CMinx_0flow, 
        deltaCMin0_0, deltaCMin0_0/(double)(4));
      CMaxNZx_0flow = Buildings_Utilities_Math_Functions_smoothMax(CMaxx_0flow, 
        deltaCMax0_0, deltaCMax0_0/(double)(4));
      Z0_0 = divmacro(CMinx_0flow,"CMin_flow",CMaxNZx_0flow,"CMaxNZ_flow")+1E-10
        *deltaCMin0_0;
      gaiEps0_0 = Buildings_Utilities_Math_Functions_spliceFunction(1, 0, 
        CMinx_0flow-deltaCMin0_0, deltaCMin0_0/(double)(2));
      gaiNTU0_0 = Buildings_Utilities_Math_Functions_spliceFunction(1, delta0_0,
         CMinx_0flow-deltaCMin0_0, deltaCMin0_0/(double)(2));
      NTU0_0 = divmacro(gaiNTU0_0*UA0_0,"gaiNTU*UA",CMinNZx_0flow,"CMinNZ_flow");
      eps0_0 = gaiEps0_0*Buildings_Fluid_HeatExchangers_BaseClasses_epsilonx_0ntuZ
        (NTU0_0, Z0_0, flowRegime0_0);
    /* Output section */
    PopContext()
    return eps0_0;
  }}

/* Flattened Modelica model:

function Buildings.Fluid.HeatExchangers.BaseClasses.epsilon_ntuZ
discrete input Real NTU "Number of transfer units";
discrete input Real Z(min = 0.0, max = 1.0) "Ratio of capacity flow rate (CMin/CMax)";
input Integer flowRegime "Heat exchanger flow regime, see  Buildings.Fluid.Types.HeatExchangerFlowRegime";
discrete output Real eps(min = 0.0, max = 1.0) "Heat exchanger effectiveness";
protected 
discrete Real a "Auxiliary variable";
public 
algorithm 
if (flowRegime == 1) then 
a := 0;
eps := (1-exp( -NTU*(1+Z)))/(1+Z);
elseif (flowRegime == 2) then 
a := smooth(1, (if Z < 0.97 then Z else Buildings.Utilities.Math.Functions.smoothMin(Z, 0.98, 0.01)));
eps := (1-exp( -NTU*(1-a)))/(1-a*exp( -NTU*(1-a)));
elseif (flowRegime == 3) then 
a := NTU^(-0.22);
eps := 1-exp((exp( -NTU*Z*a)-1)/(Z*a));
elseif (flowRegime == 5) then 
a := 0;
eps := (1-exp( -Z*(1-exp( -NTU))))/Z;
elseif (flowRegime == 4) then 
a := 0;
eps := 1-exp( -(1-exp( -Z*NTU))/Z);
elseif (flowRegime == 6) then 
a := 0;
eps := 1-exp( -NTU);
else
a := 0;
eps := 0;
assert(1 <= flowRegime and flowRegime <= 6, "Flow regime is not implemented.");
end if;
annotation(smoothOrder=1);
end Buildings.Fluid.HeatExchangers.BaseClasses.epsilon_ntuZ;

  */
DYMOLA_STATIC double   Buildings_Fluid_HeatExchangers_BaseClasses_epsilonx_0ntuZ
  (double  NTU0_0, double  Z0_0, int  flowRegime0_0) {
  PushContext("Buildings.Fluid.HeatExchangers.BaseClasses.epsilon_ntuZ")
  {
    /* Declare outputs and temporaries */
    double   eps0_0;
    double   a0_0;
    eps0_0=0;
    a0_0=0;
    /* Start of real code */
      if (flowRegime0_0 == 1) {
        a0_0 = 0;
        eps0_0 = divmacro(1-exp( -NTU0_0*(1+Z0_0)),"1-exp( -NTU*(1+Z))",1+Z0_0,
          "1+Z");
      }
      else if (flowRegime0_0 == 2) {
        a0_0 = IF Z0_0 < 0.97 THEN Z0_0 ELSE Buildings_Utilities_Math_Functions_smoothMin
          (Z0_0, 0.98, 0.01);
        eps0_0 = divmacro(1-exp( -NTU0_0*(1-a0_0)),"1-exp( -NTU*(1-a))",1-a0_0*
          exp( -NTU0_0*(1-a0_0)),"1-a*exp( -NTU*(1-a))");
      }
      else if (flowRegime0_0 == 3) {
        a0_0 = powmacro(NTU0_0,"NTU",-0.22,"-0.22");
        eps0_0 = 1-exp(divmacro(exp( -NTU0_0*Z0_0*a0_0)-1,"exp( -NTU*Z*a)-1",
          Z0_0*a0_0,"Z*a"));
      }
      else if (flowRegime0_0 == 5) {
        a0_0 = 0;
        eps0_0 = divmacro(1-exp( -Z0_0*(1-exp( -NTU0_0))),"1-exp( -Z*(1-exp( -NTU)))",
          Z0_0,"Z");
      }
      else if (flowRegime0_0 == 4) {
        a0_0 = 0;
        eps0_0 = 1-exp( -divmacro(1-exp( -Z0_0*NTU0_0),"1-exp( -Z*NTU)",Z0_0,"Z"));
      }
      else if (flowRegime0_0 == 6) {
        a0_0 = 0;
        eps0_0 = 1-exp( -NTU0_0);
      }
      else{
        a0_0 = 0;
        eps0_0 = 0;
        AssertModelica(1 <= flowRegime0_0 AND flowRegime0_0 <= 6,
          "1 <= flowRegime and flowRegime <= 6", "Flow regime is not implemented.");
      }
    /* Output section */
    PopContext()
    return eps0_0;
  }}

/* Flattened Modelica model:

function Buildings.Fluid.HeatExchangers.BaseClasses.ntu_epsilonZ
discrete input Real eps(min = 0.0, max = 0.999) "Heat exchanger effectiveness";
discrete input Real Z(min = 0.0, max = 1.0) "Ratio of capacity flow rate (CMin/CMax)";
input Integer flowRegime "Heat exchanger flow regime";
discrete output Real NTU "Number of transfer units";
protected 
discrete Real a "Auxiliary variable";
constant Modelica.Media.Common.OneNonLinearEquation.f_nonlinear_Data dummy = Modelica.Media.Common.OneNonLinearEquation.f_nonlinear_Data(

);
public 
algorithm 
if (flowRegime == 1) then 
a := Z+1;
assert(eps < 1/a, "Invalid input data. eps > 1/(1+Z) is physically not possible for parallel flow.
  Received eps = "+       String(eps, true, 0)+"
             Z = "+       String(Z, true, 0)+"
       1/(Z+1) = "+       String(1/a, true, 0));
NTU :=  -log(1-eps*a)/a;
elseif (flowRegime == 2) then 
a := smooth(1, (if Z < 0.97 then Z else Buildings.Utilities.Math.Functions.smoothMin(Z, 0.98, 0.01)));
NTU := log((1-eps)/(1-eps*a))/(a-1);
elseif (flowRegime == 3) then 
a := 0;
NTU := Buildings.Fluid.HeatExchangers.BaseClasses.solve_Unique15(
eps, 
1.5E-10, 
1000000.0, 
Z, 
fill(0, 0), 
dummy, 
1E-13);
elseif (flowRegime == 5) then 
a := smooth(1, (if Z > 0.03 then Z else Buildings.Utilities.Math.Functions.smoothMin(0.02, Z, 0.01)));
NTU :=  -log(1+log(1-eps*a)/a);
elseif (flowRegime == 4) then 
a := smooth(1, (if Z > 0.03 then Z else Buildings.Utilities.Math.Functions.smoothMin(0.02, Z, 0.01)));
NTU :=  -log(1+Z*log(1-eps))/Z;
elseif (flowRegime == 6) then 
a := 0;
NTU :=  -log(1-eps);
else
a := 0;
NTU := 0;
assert(1 <= flowRegime and flowRegime <= 6, "Flow regime is not implemented.");
end if;
annotation(smoothOrder=1);
end Buildings.Fluid.HeatExchangers.BaseClasses.ntu_epsilonZ;

  */
DYMOLA_STATIC double   Buildings_Fluid_HeatExchangers_BaseClasses_ntux_0epsilonZ
  (double  eps0_0, double  Z0_0, int  flowRegime0_0) {
  char*retSMark_=GetStringMark();
  PushContext("Buildings.Fluid.HeatExchangers.BaseClasses.ntu_epsilonZ")
  {
    /* Declare outputs and temporaries */
    double   NTU0_0;
    double   a0_0;
    struct DymStruc2  dummy0_0;
    MarkObject retmark_ = PushMark();
    NTU0_0=0;
    a0_0=0;
    /* Start of real code */
      if (flowRegime0_0 == 1) {
        a0_0 = Z0_0+1;
        AssertModelica(eps0_0 < divmacro(1,"1",a0_0,"a"),"eps < 1/a", StringAdd(
          StringAdd(StringAdd(StringAdd(StringAdd("Invalid input data. eps > 1/(1+Z) is physically not possible for parallel flow.\n  Received eps = ",
          Real2String2(eps0_0, true, 0)),"\n             Z = "),Real2String2(
          Z0_0, true, 0)),"\n       1/(Z+1) = "),Real2String2(divmacro(1,"1",
          a0_0,"a"), true, 0)));
        NTU0_0 =  -divmacro(logGuarded(1-eps0_0*a0_0,"1-eps*a"),"log(1-eps*a)",
          a0_0,"a");
      }
      else if (flowRegime0_0 == 2) {
        a0_0 = IF Z0_0 < 0.97 THEN Z0_0 ELSE Buildings_Utilities_Math_Functions_smoothMin
          (Z0_0, 0.98, 0.01);
        NTU0_0 = divmacro(logGuarded(divmacro(1-eps0_0,"1-eps",1-eps0_0*a0_0,
          "1-eps*a"),"(1-eps)/(1-eps*a)"),"log((1-eps)/(1-eps*a))",a0_0-1,"a-1");
      }
      else if (flowRegime0_0 == 3) {
        a0_0 = 0;
        NTU0_0 = Buildings_Fluid_HeatExchangers_BaseClasses_solvex_0Unique15(
          eps0_0, 1.5E-10, 1000000.0, Z0_0, RealConvertInteger (IntegerFill( 0, 1, (SizeType)(0))),
           dummy0_0, 1E-13);
        Release();
      }
      else if (flowRegime0_0 == 5) {
        a0_0 = IF Z0_0 > 0.03 THEN Z0_0 ELSE Buildings_Utilities_Math_Functions_smoothMin
          (0.02, Z0_0, 0.01);
        NTU0_0 =  -logGuarded(1+divmacro(logGuarded(1-eps0_0*a0_0,"1-eps*a"),
          "log(1-eps*a)",a0_0,"a"),"1+log(1-eps*a)/a");
      }
      else if (flowRegime0_0 == 4) {
        a0_0 = IF Z0_0 > 0.03 THEN Z0_0 ELSE Buildings_Utilities_Math_Functions_smoothMin
          (0.02, Z0_0, 0.01);
        NTU0_0 =  -divmacro(logGuarded(1+Z0_0*logGuarded(1-eps0_0,"1-eps"),
          "1+Z*log(1-eps)"),"log(1+Z*log(1-eps))",Z0_0,"Z");
      }
      else if (flowRegime0_0 == 6) {
        a0_0 = 0;
        NTU0_0 =  -logGuarded(1-eps0_0,"1-eps");
      }
      else{
        a0_0 = 0;
        NTU0_0 = 0;
        AssertModelica(1 <= flowRegime0_0 AND flowRegime0_0 <= 6,
          "1 <= flowRegime and flowRegime <= 6", "Flow regime is not implemented.");
      }
    /* Output section */
    PopMark(retmark_);
    SetStringMark(retSMark_);
    PopContext()
    return NTU0_0;
  }}

/* Flattened Modelica model:

function Buildings.Fluid.HeatExchangers.BaseClasses.solve_Unique15
discrete input Real y_zero "Determine x_zero, such that f_nonlinear(x_zero) = y_zero";
discrete input Real x_min "Minimum value of x";
discrete input Real x_max "Maximum value of x";
discrete input Real pressure(start = 0.0) "Disregarded variables (here always used for pressure)";
discrete input Real X[:](start = fill(0, 0)) "Disregarded variables (here always used for composition)";
constant input Modelica.Media.Common.OneNonLinearEquation.f_nonlinear_Data f_nonlinear_data = Modelica.Media.Common.OneNonLinearEquation.f_nonlinear_Data(

);
discrete input Real x_tol(start = 1E-13) "Relative tolerance of the result";
discrete output Real x_zero "f_nonlinear(x_zero) = y_zero";
protected 
constant Real eps = 1E-15 "Machine epsilon";
constant Real x_eps = 1E-10 "Slight modification of x_min, x_max, since x_min, x_max are usually exactly at the borders T_min/h_min and then small numeric noise may make the interval invalid";
discrete Real x_min2(start = x_min-x_eps);
discrete Real x_max2(start = x_max+x_eps);
discrete Real a(start = x_min2) "Current best minimum interval value";
discrete Real b(start = x_max2) "Current best maximum interval value";
discrete Real c "Intermediate point a <= c <= b";
discrete Real d;
discrete Real e "b - a";
discrete Real m;
discrete Real s;
discrete Real p;
discrete Real q;
discrete Real r;
discrete Real tol;
discrete Real fa "= f_nonlinear(a) - y_zero";
discrete Real fb "= f_nonlinear(b) - y_zero";
discrete Real fc;
Boolean found(start = false);
public 
algorithm 
fa := Buildings.Fluid.HeatExchangers.BaseClasses.Internal.f_nonlinear(
x_min2, 
pressure, 
X, 
f_nonlinear_data)-y_zero;
fb := Buildings.Fluid.HeatExchangers.BaseClasses.Internal.f_nonlinear(
x_max2, 
pressure, 
X, 
f_nonlinear_data)-y_zero;
fc := fb;
if (fa > 0.0 and fb > 0.0 or fa < 0.0 and fb < 0.0) then 
ModelicaError("The arguments x_min and x_max to OneNonLinearEquation.solve(..)
do not bracket the root of the single non-linear equation:
  x_min  = "+       String(x_min2, true, 0)+"\n"+"  x_max  = "+       String(x_max2, true, 0)+"\n"+"  y_zero = "+       String(y_zero, true, 0)+"\n"+"  fa = f(x_min) - y_zero = "+       String(fa, true, 0)+"\n"+"  fb = f(x_max) - y_zero = "+       String(fb, true, 0)+"\n"+"fa and fb must have opposite sign which is not the case");
end if;
c := a;
fc := fa;
e := b-a;
d := e;
while  not found loop
if (abs(fc) < abs(fb)) then 
a := b;
b := c;
c := a;
fa := fb;
fb := fc;
fc := fa;
end if;
tol := 2*eps*abs(b)+x_tol;
m := (c-b)/2;
if (abs(m) <= tol or fb == 0.0) then 
found := true;
x_zero := b;
else
if (abs(e) < tol or abs(fa) <= abs(fb)) then 
e := m;
d := e;
else
s := fb/fa;
if (a == c) then 
p := 2*m*s;
q := 1-s;
else
q := fa/fc;
r := fb/fc;
p := s*(2*m*q*(q-r)-(b-a)*(r-1));
q := (q-1)*(r-1)*(s-1);
end if;
if (p > 0) then 
q :=  -q;
else
p :=  -p;
end if;
s := e;
e := d;
if (2*p < 3*m*q-abs(tol*q) and p < abs(0.5*s*q)) then 
d := p/q;
else
e := m;
d := e;
end if;
end if;
a := b;
fa := fb;
b := b+(if abs(d) > tol then d else (if m > 0 then tol else  -tol));
fb := Buildings.Fluid.HeatExchangers.BaseClasses.Internal.f_nonlinear(
b, 
pressure, 
X, 
f_nonlinear_data)-y_zero;
if (fb > 0 and fc > 0 or fb < 0 and fc < 0) then 
c := a;
fc := fa;
e := b-a;
d := e;
end if;
end if;
end while;
end Buildings.Fluid.HeatExchangers.BaseClasses.solve_Unique15;

  */
DYMOLA_STATIC double   Buildings_Fluid_HeatExchangers_BaseClasses_solvex_0Unique15
  (double  yx_0zero, double  xx_0min, double  xx_0max, double  pressure0_0, 
  RealArray   X0_0, struct DymStruc2 fx_0nonlinearx_0data, double  xx_0tol) {
  char*retSMark_=GetStringMark();
  PushContext("Buildings.Fluid.HeatExchangers.BaseClasses.solve_Unique15")
  {
    /* Declare outputs and temporaries */
    double   xx_0zero;
    double   eps0_0;
    double   xx_0eps;
    double   xx_0min2;
    double   xx_0max2;
    double   a0_0;
    double   b0_0;
    double   c0_0;
    double   d0_0;
    double   e0_0;
    double   m0_0;
    double   s0_0;
    double   p0_0;
    double   q0_0;
    double   r0_0;
    double   tol0_0;
    double   fa0_0;
    double   fb0_0;
    double   fc0_0;
    int   found0_0;
    MarkObject retmark_ = PushMark();
    xx_0zero=0;
    eps0_0 = 1E-15;
    xx_0eps = 1E-10;
    xx_0min2 = xx_0min-xx_0eps;
    xx_0max2 = xx_0max+xx_0eps;
    a0_0 = xx_0min2;
    b0_0 = xx_0max2;
    c0_0=0;
    d0_0=0;
    e0_0=0;
    m0_0=0;
    s0_0=0;
    p0_0=0;
    q0_0=0;
    r0_0=0;
    tol0_0=0;
    fa0_0=0;
    fb0_0=0;
    fc0_0=0;
    found0_0 = false;
    /* Start of real code */
      fa0_0 = Buildings_Fluid_HeatExchangers_BaseClasses_Internal_fx_0nonlinear(
        xx_0min2, pressure0_0, X0_0, fx_0nonlinearx_0data)-yx_0zero;
      fb0_0 = Buildings_Fluid_HeatExchangers_BaseClasses_Internal_fx_0nonlinear(
        xx_0max2, pressure0_0, X0_0, fx_0nonlinearx_0data)-yx_0zero;
      fc0_0 = fb0_0;
      if (fa0_0 > 0.0 AND fb0_0 > 0.0 OR fa0_0 < 0.0 AND fb0_0 < 0.0) {
        ModelicaError(StringAdd(StringAdd(StringAdd(StringAdd(StringAdd(
          StringAdd(StringAdd(StringAdd(StringAdd(StringAdd(StringAdd(StringAdd(
          StringAdd(StringAdd(StringAdd("The arguments x_min and x_max to OneNonLinearEquation.solve(..)\ndo not bracket the root of the single non-linear equation:\n  x_min  = ",
          Real2String2(xx_0min2, true, 0)),"\n"),"  x_max  = "),Real2String2(
          xx_0max2, true, 0)),"\n"),"  y_zero = "),Real2String2(yx_0zero, true, 0)),
          "\n"),"  fa = f(x_min) - y_zero = "),Real2String2(fa0_0, true, 0)),
          "\n"),"  fb = f(x_max) - y_zero = "),Real2String2(fb0_0, true, 0)),
          "\n"),"fa and fb must have opposite sign which is not the case"));
      }
      c0_0 = a0_0;
      fc0_0 = fa0_0;
      e0_0 = b0_0-a0_0;
      d0_0 = e0_0;
      while ( NOT found0_0) {
        if (fabs(fc0_0) < fabs(fb0_0)) {
          a0_0 = b0_0;
          b0_0 = c0_0;
          c0_0 = a0_0;
          fa0_0 = fb0_0;
          fb0_0 = fc0_0;
          fc0_0 = fa0_0;
        }
        tol0_0 = 2*eps0_0*fabs(b0_0)+xx_0tol;
        m0_0 = (c0_0-b0_0)/(double)(2);
        if (fabs(m0_0) <= tol0_0 OR fb0_0 == 0.0) {
          found0_0 = true;
          xx_0zero = b0_0;
        }
        else{
          if (fabs(e0_0) < tol0_0 OR fabs(fa0_0) <= fabs(fb0_0)) {
            e0_0 = m0_0;
            d0_0 = e0_0;
          }
          else{
            s0_0 = divmacro(fb0_0,"fb",fa0_0,"fa");
            if (a0_0 == c0_0) {
              p0_0 = 2*m0_0*s0_0;
              q0_0 = 1-s0_0;
            }
            else{
              q0_0 = divmacro(fa0_0,"fa",fc0_0,"fc");
              r0_0 = divmacro(fb0_0,"fb",fc0_0,"fc");
              p0_0 = s0_0*(2*m0_0*q0_0*(q0_0-r0_0)-(b0_0-a0_0)*(r0_0-1));
              q0_0 = (q0_0-1)*(r0_0-1)*(s0_0-1);
            }
            if (p0_0 > 0) {
              q0_0 =  -q0_0;
            }
            else{
              p0_0 =  -p0_0;
            }
            s0_0 = e0_0;
            e0_0 = d0_0;
            if (2*p0_0 < 3*m0_0*q0_0-fabs(tol0_0*q0_0) AND p0_0 < fabs(0.5*s0_0*
              q0_0)) {
              d0_0 = divmacro(p0_0,"p",q0_0,"q");
            }
            else{
              e0_0 = m0_0;
              d0_0 = e0_0;
            }
          }
          a0_0 = b0_0;
          fa0_0 = fb0_0;
          b0_0 = b0_0+(IF fabs(d0_0) > tol0_0 THEN d0_0 ELSE IF m0_0 > 0 THEN 
            tol0_0 ELSE  -tol0_0);
          fb0_0 = Buildings_Fluid_HeatExchangers_BaseClasses_Internal_fx_0nonlinear
            (b0_0, pressure0_0, X0_0, fx_0nonlinearx_0data)-yx_0zero;
          if (fb0_0 > 0 AND fc0_0 > 0 OR fb0_0 < 0 AND fc0_0 < 0) {
            c0_0 = a0_0;
            fc0_0 = fa0_0;
            e0_0 = b0_0-a0_0;
            d0_0 = e0_0;
          }
        }
      }
    /* Output section */
    PopMark(retmark_);
    SetStringMark(retSMark_);
    PopContext()
    return xx_0zero;
  }}

/* Flattened Modelica model:

function Buildings.Fluid.Movers.BaseClasses.Characteristics.efficiency
parameter input Buildings.Fluid.Movers.BaseClasses.Characteristics.efficiencyParameters per;
discrete input Real V_flow(unit = "m3/s") "Volumetric flow rate";
discrete input Real d[:] "Derivatives at support points for spline interpolation";
discrete input Real r_N(unit = "1") "Relative revolution, r_N=N/N_nominal";
discrete input Real delta "Small value for switching implementation around zero rpm";
discrete output Real eta(unit = "1") "Efficiency";
protected 
Integer n(start = size(per.V_flow, 1)) "Number of data points";
discrete Real rat "Ratio of V_flow/r_N";
Integer i "Integer to select data interval";
public 
algorithm 
if (n == 1) then 
eta := per.eta[1];
else
rat := V_flow/Buildings.Utilities.Math.Functions.smoothMax(r_N, 0.1, delta);
i := 1;
for j in (1:n-1) loop
if (rat > per.V_flow[j]) then 
i := j;
end if;
end for;
eta := Buildings.Utilities.Math.Functions.cubicHermiteLinearExtrapolation(rat, per.V_flow[i], per.V_flow[i+1], per.eta[i], per.eta[i+1], d[i], d[i+1]);
end if;
annotation(smoothOrder=1);
end Buildings.Fluid.Movers.BaseClasses.Characteristics.efficiency;

  */
DYMOLA_STATIC double   Buildings_Fluid_Movers_BaseClasses_Characteristics_efficiency
  (struct DymStruc1 per0_0, double  Vx_0flow, RealArray   d0_0, double  rx_0N, 
  double  delta0_0) {
  PushContext("Buildings.Fluid.Movers.BaseClasses.Characteristics.efficiency")
  {
    /* Declare outputs and temporaries */
    double   eta0_0;
    int   n0_0;
    double   rat0_0;
    int   i0_0;
    MarkObject retmark_ = PushMark();
    eta0_0=0;
    n0_0 = DYNSizeSimple(per0_0.V_flow_0member, 1);
    rat0_0=0;
    i0_0=0;
    /* Start of real code */
      if (n0_0 == 1) {
        eta0_0 = RealElement( per0_0.eta_0member, (SizeType)(1));
      }
      else{
        rat0_0 = divmacro(Vx_0flow,"V_flow",Buildings_Utilities_Math_Functions_smoothMax
          (rx_0N, 0.1, delta0_0),"Buildings.Utilities.Math.Functions.smoothMax(r_N, 0.1, delta)");
        i0_0 = 1;
        {
          int end_ = (n0_0-1);
          int j0_0_0;
          for(j0_0_0 = 1;j0_0_0 <= end_;j0_0_0 += 1) {
            if (rat0_0 > RealElement( per0_0.V_flow_0member, (SizeType)(j0_0_0)))
               {
              i0_0 = j0_0_0;
            }
          }
        }
        eta0_0 = Buildings_Utilities_Math_Functions_cubicHermiteLinearExtrapolation
          (rat0_0, RealElement( per0_0.V_flow_0member, (SizeType)(i0_0)), 
          RealElement( per0_0.V_flow_0member, (SizeType)(i0_0+1)), RealElement( 
          per0_0.eta_0member, (SizeType)(i0_0)), RealElement( per0_0.eta_0member,
           (SizeType)(i0_0+1)), RealElement( d0_0, (SizeType)(i0_0)), 
          RealElement( d0_0, (SizeType)(i0_0+1)));
      }
    /* Output section */
    PopMark(retmark_);
    PopContext()
    return eta0_0;
  }}

/* Flattened Modelica model:

function Buildings.Fluid.Movers.BaseClasses.FlowMachineInterface.getArrayAsString
discrete input Real array[:] "Array to be printed";
input String varName "Variable name";
input Integer minimumLength(start = 6) "Minimum width of result";
input Integer significantDigits(start = 6) "Number of significant digits";
output String str "String representation";

algorithm 
str := "";
for i in (1:size(array, 1)) loop
str := str+"  "+varName+"["+       String(i, true, 0)+"]="+     String(array[i], true, minimumLength, significantDigits)+"\n";
end for;
end Buildings.Fluid.Movers.BaseClasses.FlowMachineInterface.getArrayAsString;

  */
DYMOLA_STATIC const char*   Buildings_Fluid_Movers_BaseClasses_FlowMachineInterface_getArrayAsString
  (RealArray   array0_0, const char*  varName0_0, int  minimumLength0_0, int  
  significantDigits0_0) {
  char*retSMark_=GetStringMark();
  PushContext("Buildings.Fluid.Movers.BaseClasses.FlowMachineInterface.getArrayAsString")
  {
    /* Declare outputs and temporaries */
    const char*   str0_0;
    MarkObject retmark_ = PushMark();
    str0_0="";
    /* Start of real code */
      str0_0 = "";
      {
        int end_ = DYNSizeSimple(array0_0, 1);
        int i0_0_0;
        for(i0_0_0 = 1;i0_0_0 <= end_;i0_0_0 += 1) {
          str0_0 = StringAdd(StringAdd(StringAdd(StringAdd(StringAdd(StringAdd(
            StringAdd(str0_0,"  "),varName0_0),"["),Integer2String2(i0_0_0, true,
             0)),"]="),Real2String3(RealVectorElement( array0_0, (SizeType)(
            i0_0_0)), true, minimumLength0_0, significantDigits0_0)),"\n");
        }
      }
    /* Output section */
    PopMark(retmark_);
    PopContext()
    return SqueezeString(str0_0, retSMark_);
  }}

/* Flattened Modelica model:

function Buildings.ThermalZones.ReducedOrder.RC.BaseClasses.splitFacVal
input Integer nRow "Number of rows";
input Integer nCol "Number of columns";
discrete input Real AArray[:](unit = "m2") "Vector of areas";
discrete input Real AExt[nCol](unit = "m2") "Vector of exterior wall areas";
discrete input Real AWin[nCol](unit = "m2") "Vector of window areas";
discrete output Real splitFacValues[nRow, nCol] "Split factor values for ThermSplitter";
protected 
discrete Real ATot(start = sum(AArray), unit = "m2") "Total area";
Integer j(start = 1) "Row counter";
Integer k(start = 1) "Column counter";
Integer l(start = 1) "AArray counter";
public 
algorithm 
for A in AArray loop
if (A > 0) then 
k := 1;
if (l == 1) then 
for AWall in AExt loop
splitFacValues[j, k] := (A-AWall)/(ATot-AWall-AWin[k]);
k := k+1;
end for;
elseif (l == 2) then 
for AWall in AExt loop
splitFacValues[j, k] := (A-AWin[k])/(ATot-AWall-AWin[k]);
k := k+1;
end for;
else
for AWall in AExt loop
splitFacValues[j, k] := A/(ATot-AWall-AWin[k]);
k := k+1;
end for;
end if;
j := j+1;
end if;
l := l+1;
end for;
end Buildings.ThermalZones.ReducedOrder.RC.BaseClasses.splitFacVal;

  */
DYMOLA_STATIC RealArray    Buildings_ThermalZones_ReducedOrder_RC_BaseClasses_splitFacVal
  (int  nRow0_0, int  nCol0_0, RealArray   AArray0_0, RealArray   AExt0_0, 
  RealArray   AWin0_0) {
  PushContext("Buildings.ThermalZones.ReducedOrder.RC.BaseClasses.splitFacVal")
  AssertModelica(DYNSizeSimple(AExt0_0,1)==nCol0_0,"size(AExt, 1) == nCol","Dimension check of input to function failed");
  AssertModelica(DYNSizeSimple(AWin0_0,1)==nCol0_0,"size(AWin, 1) == nCol","Dimension check of input to function failed");
  {
    /* Declare outputs and temporaries */
    RealArray    splitFacValues0_0;
    double   ATot0_0;
    int   j0_0;
    int   k0_0;
    int   l0_0;
    MarkObject retmark_ = PushMark();
    splitFacValues0_0=RealTemporary( 2, nRow0_0, nCol0_0);
    RePushMark(&retmark_);
    RealFillAssign( splitFacValues0_0, 0);
    ATot0_0 = Realsum( AArray0_0);
    Release();
    j0_0 = 1;
    k0_0 = 1;
    l0_0 = 1;
    /* Start of real code */
      {
        MarkObject formark_ = PushMark();
        RealArray   vector_ = AArray0_0;
        int i_;
        for (i_ = 0; i_ < vector_.dims[0]; i_++) {
          double A0_0_0 = vector_.data[i_];
          if (A0_0_0 > 0) {
            k0_0 = 1;
            if (l0_0 == 1) {
              {
                MarkObject formark_ = PushMark();
                RealArray   vector_ = AExt0_0;
                int i_;
                for (i_ = 0; i_ < vector_.dims[0]; i_++) {
                  double AWall0_0_0 = vector_.data[i_];
                  SetRealElement(divmacro(A0_0_0-AWall0_0_0,"A-AWall",ATot0_0-
                    AWall0_0_0-RealElement( AWin0_0, (SizeType)(k0_0)),
                    "ATot-AWall-AWin[k]"), splitFacValues0_0, (SizeType)(j0_0), 
                    (SizeType)(k0_0));
                  k0_0 = k0_0+1;
                }
                PopMark(formark_);
              }
            }
            else if (l0_0 == 2) {
              {
                MarkObject formark_ = PushMark();
                RealArray   vector_ = AExt0_0;
                int i_;
                for (i_ = 0; i_ < vector_.dims[0]; i_++) {
                  double AWall0_0_0 = vector_.data[i_];
                  SetRealElement(divmacro(A0_0_0-RealElement( AWin0_0, 
                    (SizeType)(k0_0)),"A-AWin[k]",ATot0_0-AWall0_0_0-
                    RealElement( AWin0_0, (SizeType)(k0_0)),"ATot-AWall-AWin[k]"),
                     splitFacValues0_0, (SizeType)(j0_0), (SizeType)(k0_0));
                  k0_0 = k0_0+1;
                }
                PopMark(formark_);
              }
            }
            else{
              {
                MarkObject formark_ = PushMark();
                RealArray   vector_ = AExt0_0;
                int i_;
                for (i_ = 0; i_ < vector_.dims[0]; i_++) {
                  double AWall0_0_0 = vector_.data[i_];
                  SetRealElement(divmacro(A0_0_0,"A",ATot0_0-AWall0_0_0-
                    RealElement( AWin0_0, (SizeType)(k0_0)),"ATot-AWall-AWin[k]"),
                     splitFacValues0_0, (SizeType)(j0_0), (SizeType)(k0_0));
                  k0_0 = k0_0+1;
                }
                PopMark(formark_);
              }
            }
            j0_0 = j0_0+1;
          }
          l0_0 = l0_0+1;
        }
        PopMark(formark_);
      }
    /* Output section */
    PopMark(retmark_);
    PopContext()
    return splitFacValues0_0;
  }}

/* Flattened Modelica model:

function Buildings.Utilities.Math.Functions.BaseClasses.smoothTransition
discrete input Real x "Abscissa value";
discrete input Real delta(min = 1E-15) "Abscissa value below which approximation occurs";
discrete input Real deltaInv(start = 1/delta) "Inverse value of delta";
discrete input Real a(start = (-15)*deltaInv) "Polynomial coefficient";
discrete input Real b(start = 119*deltaInv^2) "Polynomial coefficient";
discrete input Real c(start = (-361)*deltaInv^3) "Polynomial coefficient";
discrete input Real d(start = 534*deltaInv^4) "Polynomial coefficient";
discrete input Real e(start = (-380)*deltaInv^5) "Polynomial coefficient";
discrete input Real f(start = 104*deltaInv^6) "Polynomial coefficient";
discrete output Real y "Function value";
protected 
discrete Real aX "Absolute value of x";
public 
algorithm 
aX := abs(x);
y := (if x >= 0 then 1 else -1)*(a+aX*(b+aX*(c+aX*(d+aX*(e+aX*f)))));
annotation(derivative(zeroDerivative=a, zeroDerivative=b, zeroDerivative=c, zeroDerivative=d, zeroDerivative=delta, zeroDerivative=deltaInv, zeroDerivative=e, zeroDerivative=f)=Buildings.Utilities.Math.Functions.BaseClasses.der_smoothTransition, smoothOrder=2);
end Buildings.Utilities.Math.Functions.BaseClasses.smoothTransition;

  */
DYMOLA_STATIC double   Buildings_Utilities_Math_Functions_BaseClasses_smoothTransition
  (double  x0_0, double  delta0_0, double  deltaInv0_0, double  a0_0, double  
  b0_0, double  c0_0, double  d0_0, double  e0_0, double  f0_0) {
  PushContext("Buildings.Utilities.Math.Functions.BaseClasses.smoothTransition")
  {
    /* Declare outputs and temporaries */
    double   y0_0;
    double   aX0_0;
    y0_0=0;
    aX0_0=0;
    /* Start of real code */
      aX0_0 = fabs(x0_0);
      y0_0 = (IF x0_0 >= 0 THEN 1 ELSE -1)*(a0_0+aX0_0*(b0_0+aX0_0*(c0_0+aX0_0*(
        d0_0+aX0_0*(e0_0+aX0_0*f0_0)))));
    /* Output section */
    PopContext()
    return y0_0;
  }}

/* Flattened Modelica model:

function Buildings.Utilities.Math.Functions.cubicHermiteLinearExtrapolation
discrete input Real x "Abscissa value";
discrete input Real x1 "Lower abscissa value";
discrete input Real x2 "Upper abscissa value";
discrete input Real y1 "Lower ordinate value";
discrete input Real y2 "Upper ordinate value";
discrete input Real y1d "Lower gradient";
discrete input Real y2d "Upper gradient";
discrete output Real y "Interpolated ordinate value";

algorithm 
if (x > x1 and x < x2) then 
y := Modelica.Fluid.Utilities.cubicHermite(x, x1, x2, y1, y2, y1d, y2d);
elseif (x <= x1) then 
y := y1+(x-x1)*y1d;
else
y := y2+(x-x2)*y2d;
end if;
annotation(smoothOrder=1);
end Buildings.Utilities.Math.Functions.cubicHermiteLinearExtrapolation;

  */
DYMOLA_STATIC double   Buildings_Utilities_Math_Functions_cubicHermiteLinearExtrapolation
  (double  x0_0, double  x10_0, double  x20_0, double  y10_0, double  y20_0, 
  double  y1d0_0, double  y2d0_0) {
  PushContext("Buildings.Utilities.Math.Functions.cubicHermiteLinearExtrapolation")
  {
    /* Declare outputs and temporaries */
    double   y0_0;
    y0_0=0;
    /* Start of real code */
      if (x0_0 > x10_0 AND x0_0 < x20_0) {
        y0_0 = Modelica_Fluid_Utilities_cubicHermite(x0_0, x10_0, x20_0, y10_0, 
          y20_0, y1d0_0, y2d0_0);
      }
      else if (x0_0 <= x10_0) {
        y0_0 = y10_0+(x0_0-x10_0)*y1d0_0;
      }
      else{
        y0_0 = y20_0+(x0_0-x20_0)*y2d0_0;
      }
    /* Output section */
    PopContext()
    return y0_0;
  }}

/* Flattened Modelica model:

function Buildings.Utilities.Math.Functions.isMonotonic
discrete input Real x[:] "Sequence to be tested";
input Boolean strict(start = false) "Set to true to test for strict monotonicity";
output Boolean monotonic "True if x is monotonic increasing or decreasing";
protected 
Integer n(start = size(x, 1)) "Number of data points";
public 
algorithm 
if (n == 1) then 
monotonic := true;
else
monotonic := true;
if (strict) then 
if (x[1] >= x[n]) then 
for i in (1:n-1) loop
if ( not (x[i] > x[i+1])) then 
monotonic := false;
end if;
end for;
else
for i in (1:n-1) loop
if ( not (x[i] < x[i+1])) then 
monotonic := false;
end if;
end for;
end if;
else
if (x[1] >= x[n]) then 
for i in (1:n-1) loop
if ( not (x[i] >= x[i+1])) then 
monotonic := false;
end if;
end for;
else
for i in (1:n-1) loop
if ( not (x[i] <= x[i+1])) then 
monotonic := false;
end if;
end for;
end if;
end if;
end if;
end Buildings.Utilities.Math.Functions.isMonotonic;

  */
DYMOLA_STATIC int   Buildings_Utilities_Math_Functions_isMonotonic(RealArray   
  x0_0, int  strict0_0) {
  PushContext("Buildings.Utilities.Math.Functions.isMonotonic")
  {
    /* Declare outputs and temporaries */
    int   monotonic0_0;
    int   n0_0;
    MarkObject retmark_ = PushMark();
    monotonic0_0=0;
    n0_0 = DYNSizeSimple(x0_0, 1);
    /* Start of real code */
      if (n0_0 == 1) {
        monotonic0_0 = true;
      }
      else{
        monotonic0_0 = true;
        if (strict0_0) {
          if (RealElement( x0_0, (SizeType)(1)) >= RealElement( x0_0, (SizeType)
            (n0_0))) {
            {
              int end_ = (n0_0-1);
              int i0_0_0;
              for(i0_0_0 = 1;i0_0_0 <= end_;i0_0_0 += 1) {
                if ( NOT (RealElement( x0_0, (SizeType)(i0_0_0)) > RealElement( 
                  x0_0, (SizeType)(i0_0_0+1)))) {
                  monotonic0_0 = false;
                }
              }
            }
          }
          else{
            {
              int end_ = (n0_0-1);
              int i0_0_0;
              for(i0_0_0 = 1;i0_0_0 <= end_;i0_0_0 += 1) {
                if ( NOT (RealElement( x0_0, (SizeType)(i0_0_0)) < RealElement( 
                  x0_0, (SizeType)(i0_0_0+1)))) {
                  monotonic0_0 = false;
                }
              }
            }
          }
        }
        else{
          if (RealElement( x0_0, (SizeType)(1)) >= RealElement( x0_0, (SizeType)
            (n0_0))) {
            {
              int end_ = (n0_0-1);
              int i0_0_0;
              for(i0_0_0 = 1;i0_0_0 <= end_;i0_0_0 += 1) {
                if ( NOT (RealElement( x0_0, (SizeType)(i0_0_0)) >= RealElement( 
                  x0_0, (SizeType)(i0_0_0+1)))) {
                  monotonic0_0 = false;
                }
              }
            }
          }
          else{
            {
              int end_ = (n0_0-1);
              int i0_0_0;
              for(i0_0_0 = 1;i0_0_0 <= end_;i0_0_0 += 1) {
                if ( NOT (RealElement( x0_0, (SizeType)(i0_0_0)) <= RealElement( 
                  x0_0, (SizeType)(i0_0_0+1)))) {
                  monotonic0_0 = false;
                }
              }
            }
          }
        }
      }
    /* Output section */
    PopMark(retmark_);
    PopContext()
    return monotonic0_0;
  }}

/* Flattened Modelica model:

function Buildings.Utilities.Math.Functions.regNonZeroPower
discrete input Real x "Abscissa value";
discrete input Real n "Exponent";
discrete input Real delta(start = 0.01) "Abscissa value where transition occurs";
discrete output Real y "Function value";
protected 
discrete Real a1;
discrete Real a3;
discrete Real a5;
discrete Real delta2;
discrete Real x2;
discrete Real y_d "=y(delta)";
discrete Real yP_d "=dy(delta)/dx";
discrete Real yPP_d "=d^2y(delta)/dx^2";
public 
algorithm 
if (abs(x) > delta) then 
y := abs(x)^n;
else
delta2 := delta*delta;
x2 := x*x;
y_d := delta^n;
yP_d := n*delta^(n-1);
yPP_d := n*(n-1)*delta^(n-2);
a1 :=  -(yP_d/delta-yPP_d)/delta2/8;
a3 := (yPP_d-12*a1*delta2)/2;
a5 := y_d-delta2*(a3+delta2*a1);
y := a5+x2*(a3+x2*a1);
assert(a5 > 0, "Delta is too small for this exponent.");
end if;
annotation(derivative(zeroDerivative=delta, zeroDerivative=n)=Buildings.Utilities.Math.Functions.BaseClasses.der_regNonZeroPower, Inline=true, smoothOrder=2);
end Buildings.Utilities.Math.Functions.regNonZeroPower;

  */
DYMOLA_STATIC double   Buildings_Utilities_Math_Functions_regNonZeroPower(double 
   x0_0, double  n0_0, double  delta0_0) {
  PushContext("Buildings.Utilities.Math.Functions.regNonZeroPower")
  {
    /* Declare outputs and temporaries */
    double   y0_0;
    double   a10_0;
    double   a30_0;
    double   a50_0;
    double   delta20_0;
    double   x20_0;
    double   yx_0d;
    double   yPx_0d;
    double   yPPx_0d;
    y0_0=0;
    a10_0=0;
    a30_0=0;
    a50_0=0;
    delta20_0=0;
    x20_0=0;
    yx_0d=0;
    yPx_0d=0;
    yPPx_0d=0;
    /* Start of real code */
      if (fabs(x0_0) > delta0_0) {
        y0_0 = powmacro(fabs(x0_0),"abs(x)",n0_0,"n");
      }
      else{
        delta20_0 = delta0_0*delta0_0;
        x20_0 = x0_0*x0_0;
        yx_0d = powmacro(delta0_0,"delta",n0_0,"n");
        yPx_0d = n0_0*powmacro(delta0_0,"delta",n0_0-1,"n-1");
        yPPx_0d = n0_0*(n0_0-1)*powmacro(delta0_0,"delta",n0_0-2,"n-2");
        a10_0 =  -divmacro(divmacro(yPx_0d,"yP_d",delta0_0,"delta")-yPPx_0d,
          "yP_d/delta-yPP_d",delta20_0,"delta2")/(double)(8);
        a30_0 = (yPPx_0d-12*a10_0*delta20_0)/(double)(2);
        a50_0 = yx_0d-delta20_0*(a30_0+delta20_0*a10_0);
        y0_0 = a50_0+x20_0*(a30_0+x20_0*a10_0);
        AssertModelica(a50_0 > 0,"a5 > 0", "Delta is too small for this exponent.");
      }
    /* Output section */
    PopContext()
    return y0_0;
  }}

/* Flattened Modelica model:

function Buildings.Utilities.Math.Functions.smoothLimit
discrete input Real x "Variable";
discrete input Real l "Low limit";
discrete input Real u "Upper limit";
discrete input Real deltaX "Width of transition interval";
discrete output Real y "Result";
protected 
discrete Real cor;
public 
algorithm 
cor := deltaX/10;
y := Buildings.Utilities.Math.Functions.smoothMax(x, l+deltaX, cor);
y := Buildings.Utilities.Math.Functions.smoothMin(y, u-deltaX, cor);
annotation(smoothOrder=1);
end Buildings.Utilities.Math.Functions.smoothLimit;

  */
DYMOLA_STATIC double   Buildings_Utilities_Math_Functions_smoothLimit(double  
  x0_0, double  l0_0, double  u0_0, double  deltaX0_0) {
  PushContext("Buildings.Utilities.Math.Functions.smoothLimit")
  {
    /* Declare outputs and temporaries */
    double   y0_0;
    double   cor0_0;
    y0_0=0;
    cor0_0=0;
    /* Start of real code */
      cor0_0 = deltaX0_0/(double)(10);
      y0_0 = Buildings_Utilities_Math_Functions_smoothMax(x0_0, l0_0+deltaX0_0, 
        cor0_0);
      y0_0 = Buildings_Utilities_Math_Functions_smoothMin(y0_0, u0_0-deltaX0_0, 
        cor0_0);
    /* Output section */
    PopContext()
    return y0_0;
  }}

/* Flattened Modelica model:

function Buildings.Utilities.Math.Functions.smoothMax
discrete input Real x1 "First argument";
discrete input Real x2 "Second argument";
discrete input Real deltaX "Width of transition interval";
discrete output Real y "Result";

algorithm 
y := Buildings.Utilities.Math.Functions.regStep(x1-x2, x1, x2, deltaX);
annotation(Inline=true, smoothOrder=1);
end Buildings.Utilities.Math.Functions.smoothMax;

  */
DYMOLA_STATIC double   Buildings_Utilities_Math_Functions_smoothMax(double  
  x10_0, double  x20_0, double  deltaX0_0) {
  PushContext("Buildings.Utilities.Math.Functions.smoothMax")
  {
    /* Declare outputs and temporaries */
    double   y0_0;
    y0_0=0;
    /* Start of real code */
      y0_0 = Buildings_Utilities_Math_Functions_regStep(x10_0-x20_0, x10_0, 
        x20_0, deltaX0_0);
    /* Output section */
    PopContext()
    return y0_0;
  }}

/* Flattened Modelica model:

function Buildings.Utilities.Math.Functions.smoothMin
discrete input Real x1 "First argument";
discrete input Real x2 "Second argument";
discrete input Real deltaX "Width of transition interval";
discrete output Real y "Result";

algorithm 
y := Buildings.Utilities.Math.Functions.regStep(x2-x1, x1, x2, deltaX);
annotation(Inline=true, smoothOrder=1);
end Buildings.Utilities.Math.Functions.smoothMin;

  */
DYMOLA_STATIC double   Buildings_Utilities_Math_Functions_smoothMin(double  
  x10_0, double  x20_0, double  deltaX0_0) {
  PushContext("Buildings.Utilities.Math.Functions.smoothMin")
  {
    /* Declare outputs and temporaries */
    double   y0_0;
    y0_0=0;
    /* Start of real code */
      y0_0 = Buildings_Utilities_Math_Functions_regStep(x20_0-x10_0, x10_0, 
        x20_0, deltaX0_0);
    /* Output section */
    PopContext()
    return y0_0;
  }}

/* Flattened Modelica model:

function Buildings.Utilities.Math.Functions.spliceFunction
discrete input Real pos "Argument of x > 0";
discrete input Real neg "Argument of x < 0";
discrete input Real x "Independent value";
discrete input Real deltax "Half width of transition interval";
discrete output Real out "Smoothed value";
protected 
discrete Real scaledX1;
discrete Real y;
constant Real asin1 = 1.5707963267948966;
public 
algorithm 
scaledX1 := x/deltax;
if (scaledX1 <= -0.999999999) then 
out := neg;
elseif (scaledX1 >= 0.999999999) then 
out := pos;
else
y := (tanh(tan(scaledX1*asin1))+1)/2;
out := pos*y+(1-y)*neg;
end if;
annotation(derivative=Buildings.Utilities.Math.Functions.BaseClasses.der_spliceFunction, smoothOrder=1);
end Buildings.Utilities.Math.Functions.spliceFunction;

  */
DYMOLA_STATIC double   Buildings_Utilities_Math_Functions_spliceFunction(double 
   pos0_0, double  neg0_0, double  x0_0, double  deltax0_0) {
  PushContext("Buildings.Utilities.Math.Functions.spliceFunction")
  {
    /* Declare outputs and temporaries */
    double   out0_0;
    double   scaledX10_0;
    double   y0_0;
    double   asin10_0;
    out0_0=0;
    scaledX10_0=0;
    y0_0=0;
    asin10_0 = 1.5707963267948966;
    /* Start of real code */
      scaledX10_0 = divmacro(x0_0,"x",deltax0_0,"deltax");
      if (scaledX10_0 <= -0.999999999) {
        out0_0 = neg0_0;
      }
      else if (scaledX10_0 >= 0.999999999) {
        out0_0 = pos0_0;
      }
      else{
        y0_0 = (tanh(tan(scaledX10_0*asin10_0))+1)/(double)(2);
        out0_0 = pos0_0*y0_0+(1-y0_0)*neg0_0;
      }
    /* Output section */
    PopContext()
    return out0_0;
  }}

/* Flattened Modelica model:

function Buildings.Utilities.Math.Functions.splineDerivatives
discrete input Real x[:] "Support point, strict monotone increasing";
discrete input Real y[size(x, 1)] "Function values at x";
input Boolean ensureMonotonicity(start = Buildings.Utilities.Math.Functions.isMonotonic(y, false)) "Set to true to ensure monotonicity of the cubic hermite";
discrete output Real d[size(x, 1)] "Derivative at the support points";
protected 
Integer n(start = size(x, 1)) "Number of data points";
discrete Real delta[n-1] "Slope of secant line between data points";
discrete Real alpha "Coefficient to ensure monotonicity";
discrete Real beta "Coefficient to ensure monotonicity";
discrete Real tau "Coefficient to ensure monotonicity";
public 
algorithm 
if (n > 1) then 
assert(x[1] < x[n], "x must be strictly increasing.
  Received x[1] = "+       String(x[1], true, 0)+"
           x["+       String(n, true, 0)+"] = "+       String(x[n], true, 0));
assert(Buildings.Utilities.Math.Functions.isMonotonic(x, true), "x-values must be strictly monontone increasing or decreasing.");
if (ensureMonotonicity) then 
assert(Buildings.Utilities.Math.Functions.isMonotonic(y, false), "If ensureMonotonicity=true, y-values must be monontone increasing or decreasing.");
end if;
end if;
if (n == 1) then 
d[1] := 0;
elseif (n == 2) then 
d[1] := (y[2]-y[1])/(x[2]-x[1]);
d[2] := d[1];
else
for i in (1:n-1) loop
delta[i] := (y[i+1]-y[i])/(x[i+1]-x[i]);
end for;
d[1] := delta[1];
d[n] := delta[n-1];
for i in (2:n-1) loop
d[i] := (delta[i-1]+delta[i])/2;
end for;
end if;
if (n > 2 and ensureMonotonicity) then 
for i in (1:n-1) loop
if (abs(delta[i]) < 1E-60) then 
d[i] := 0;
d[i+1] := 0;
else
alpha := d[i]/delta[i];
beta := d[i+1]/delta[i];
if (alpha^2+beta^2 > 9) then 
tau := 3/(alpha^2+beta^2)^0.5;
d[i] := delta[i]*alpha*tau;
d[i+1] := delta[i]*beta*tau;
end if;
end if;
end for;
end if;
end Buildings.Utilities.Math.Functions.splineDerivatives;

  */
DYMOLA_STATIC RealArray    Buildings_Utilities_Math_Functions_splineDerivatives(
  RealArray   x0_0, RealArray   y0_0, int  ensureMonotonicity0_0) {
  char*retSMark_=GetStringMark();
  PushContext("Buildings.Utilities.Math.Functions.splineDerivatives")
  AssertModelica(DYNSizeSimple(y0_0,1)==DYNSizeSimple(x0_0, 1),"size(y, 1) == size(x, 1)","Dimension check of input to function failed");
  {
    /* Declare outputs and temporaries */
    RealArray    d0_0;
    int   n0_0;
    RealArray    delta0_0;
    double   alpha0_0;
    double   beta0_0;
    double   tau0_0;
    MarkObject retmark_ = PushMark();
    d0_0=RealTemporary( 1, DYNSizeSimple(x0_0, 1));
    RePushMark(&retmark_);
    RealFillAssign( d0_0, 0);
    n0_0 = DYNSizeSimple(x0_0, 1);
    delta0_0=RealTemporary( 1, n0_0-1);
    PushMark();
    RealFillAssign( delta0_0, 0);
    alpha0_0=0;
    beta0_0=0;
    tau0_0=0;
    /* Start of real code */
      if (n0_0 > 1) {
        AssertModelica(RealElement( x0_0, (SizeType)(1)) < RealElement( x0_0, 
          (SizeType)(n0_0)),"x[1] < x[n]", StringAdd(StringAdd(StringAdd(
          StringAdd(StringAdd("x must be strictly increasing.\n  Received x[1] = ",
          Real2String2(RealElement( x0_0, (SizeType)(1)), true, 0)),
          "\n           x["),Integer2String2(n0_0, true, 0)),"] = "),
          Real2String2(RealElement( x0_0, (SizeType)(n0_0)), true, 0)));
        AssertModelica(Buildings_Utilities_Math_Functions_isMonotonic(x0_0, true),
          "Buildings.Utilities.Math.Functions.isMonotonic(x, true)", 
          "x-values must be strictly monontone increasing or decreasing.");
        if (ensureMonotonicity0_0) {
          AssertModelica(Buildings_Utilities_Math_Functions_isMonotonic(y0_0, 
            false),"Buildings.Utilities.Math.Functions.isMonotonic(y, false)", 
            "If ensureMonotonicity=true, y-values must be monontone increasing or decreasing.");
        }
      }
      if (n0_0 == 1) {
        SetRealElement(0, d0_0, (SizeType)(1));
      }
      else if (n0_0 == 2) {
        SetRealElement(divmacro(RealElement( y0_0, (SizeType)(2))-RealElement( 
          y0_0, (SizeType)(1)),"y[2]-y[1]",RealElement( x0_0, (SizeType)(2))-
          RealElement( x0_0, (SizeType)(1)),"x[2]-x[1]"), d0_0, (SizeType)(1));
        SetRealElement(RealElement( d0_0, (SizeType)(1)), d0_0, (SizeType)(2));
      }
      else{
        {
          int end_ = (n0_0-1);
          int i0_0_0;
          for(i0_0_0 = 1;i0_0_0 <= end_;i0_0_0 += 1) {
            SetRealElement(divmacro(RealElement( y0_0, (SizeType)(i0_0_0+1))-
              RealElement( y0_0, (SizeType)(i0_0_0)),"y[i+1]-y[i]",RealElement( 
              x0_0, (SizeType)(i0_0_0+1))-RealElement( x0_0, (SizeType)(i0_0_0)),
              "x[i+1]-x[i]"), delta0_0, (SizeType)(i0_0_0));
          }
        }
        SetRealElement(RealElement( delta0_0, (SizeType)(1)), d0_0, (SizeType)(1));
        SetRealElement(RealElement( delta0_0, (SizeType)(n0_0-1)), d0_0, 
          (SizeType)(n0_0));
        {
          int end_ = (n0_0-1);
          int i0_0_0;
          for(i0_0_0 = 2;i0_0_0 <= end_;i0_0_0 += 1) {
            SetRealElement((RealElement( delta0_0, (SizeType)(i0_0_0-1))+
              RealElement( delta0_0, (SizeType)(i0_0_0)))/(double)(2), d0_0, 
              (SizeType)(i0_0_0));
          }
        }
      }
      if (n0_0 > 2 AND ensureMonotonicity0_0) {
        {
          int end_ = (n0_0-1);
          int i0_0_0;
          for(i0_0_0 = 1;i0_0_0 <= end_;i0_0_0 += 1) {
            if (fabs(RealElement( delta0_0, (SizeType)(i0_0_0))) < 1E-60) {
              SetRealElement(0, d0_0, (SizeType)(i0_0_0));
              SetRealElement(0, d0_0, (SizeType)(i0_0_0+1));
            }
            else{
              alpha0_0 = divmacro(RealElement( d0_0, (SizeType)(i0_0_0)),"d[i]",
                RealElement( delta0_0, (SizeType)(i0_0_0)),"delta[i]");
              beta0_0 = divmacro(RealElement( d0_0, (SizeType)(i0_0_0+1)),
                "d[i+1]",RealElement( delta0_0, (SizeType)(i0_0_0)),"delta[i]");
              if (sqr(alpha0_0)+sqr(beta0_0) > 9) {
                tau0_0 = divmacro(3,"3",powmacro(sqr(alpha0_0)+sqr(beta0_0),
                  "alpha^2+beta^2",0.5,"0.5"),"(alpha^2+beta^2)^0.5");
                SetRealElement(RealElement( delta0_0, (SizeType)(i0_0_0))*
                  alpha0_0*tau0_0, d0_0, (SizeType)(i0_0_0));
                SetRealElement(RealElement( delta0_0, (SizeType)(i0_0_0))*
                  beta0_0*tau0_0, d0_0, (SizeType)(i0_0_0+1));
              }
            }
          }
        }
      }
    /* Output section */
    PopMark(retmark_);
    SetStringMark(retSMark_);
    PopContext()
    return d0_0;
  }}

/* Flattened Modelica model:

function Modelica.Blocks.Continuous.Internal.Filter.base.CriticalDamping
input Integer order(min = 1.0) "Order of filter";
input Boolean normalized(start = true) "= true, if amplitude at f_cut = -3db, otherwise unmodified filter";
discrete output Real cr[order] "Coefficients of real poles";
protected 
discrete Real alpha(start = 1.0) "Frequency correction factor";
discrete Real alpha2 "= alpha*alpha";
discrete Real den1[order] "[p] coefficients of denominator first order polynomials (a*p + 1)";
discrete Real den2[0, 2] "[p^2, p] coefficients of denominator second order polynomials (b*p^2 + a*p + 1)";
discrete Real c0[0] "Coefficients of s^0 term if conjugate complex pole";
discrete Real c1[0] "Coefficients of s^1 term if conjugate complex pole";
public 
algorithm 
if (normalized) then 
alpha := sqrt(10^(0.3/order)-1);
else
alpha := 1.0;
end if;
for i in (1:order) loop
den1[i] := alpha;
end for;
(cr, c0, c1)  := Modelica.Blocks.Continuous.Internal.Filter.Utilities.toHighestPowerOne(den1, den2);
end Modelica.Blocks.Continuous.Internal.Filter.base.CriticalDamping;

  */
DYMOLA_STATIC RealArray    Modelica_Blocks_Continuous_Internal_Filter_base_CriticalDamping
  (int  order0_0, int  normalized0_0) {
  PushContext("Modelica.Blocks.Continuous.Internal.Filter.base.CriticalDamping")
  {
    /* Declare outputs and temporaries */
    RealArray    cr0_0;
    double   alpha0_0;
    double   alpha20_0;
    RealArray    den10_0;
    RealArray    den20_0;
    RealArray    c00_0;
    RealArray    c10_0;
    MarkObject retmark_ = PushMark();
    cr0_0=RealTemporary( 1, order0_0);
    RePushMark(&retmark_);
    RealFillAssign( cr0_0, 0);
    alpha0_0 = 1.0;
    alpha20_0=0;
    den10_0=RealTemporary( 1, order0_0);
    PushMark();
    RealFillAssign( den10_0, 0);
    den20_0=RealTemporary( 2, 0, 2);
    PushMark();
    RealFillAssign( den20_0, 0);
    c00_0=RealTemporary( 1, 0);
    PushMark();
    RealFillAssign( c00_0, 0);
    c10_0=RealTemporary( 1, 0);
    PushMark();
    RealFillAssign( c10_0, 0);
    /* Start of real code */
      if (normalized0_0) {
        alpha0_0 = sqrtGuarded(powmacro(10,"10",divmacro(0.3,"0.3",order0_0,
          "order"),"0.3/order")-1,"10^(0.3/order)-1");
      }
      else{
        alpha0_0 = 1.0;
      }
      {
        int end_ = order0_0;
        int i0_0_0;
        for(i0_0_0 = 1;i0_0_0 <= end_;i0_0_0 += 1) {
          SetRealVectorElement(alpha0_0, den10_0, (SizeType)(i0_0_0));
        }
      }
      {
        struct Modelica_Blocks_Continuous_Internal_Filter_Utilities_toHighestPowerOne_struct
           dummy_mult_=Modelica_Blocks_Continuous_Internal_Filter_Utilities_toHighestPowerOne
          (den10_0, den20_0);
        RealAssign (cr0_0, dummy_mult_.cr0_0_0member);
        RealAssign (c00_0, dummy_mult_.c00_0_0member);
        RealAssign (c10_0, dummy_mult_.c10_0_0member);
      }
      Release();
    /* Output section */
    PopMark(retmark_);
    PopContext()
    return cr0_0;
  }}

/* Flattened Modelica model:

function Modelica.Blocks.Continuous.Internal.Filter.roots.lowPass
discrete input Real cr_in[:] "Coefficients of real poles of base filter";
discrete input Real c0_in[:] "Coefficients of s^0 term of base filter if conjugate complex pole";
discrete input Real c1_in[size(c0_in, 1)] "Coefficients of s^1 term of base filter if conjugate complex pole";
discrete input Real f_cut(unit = "Hz") "Cut-off frequency";
discrete output Real r[size(cr_in, 1)] "Real eigenvalues";
discrete output Real a[size(c0_in, 1)] "Real parts of complex conjugate eigenvalues";
discrete output Real b[size(c0_in, 1)] "Imaginary parts of complex conjugate eigenvalues";
discrete output Real ku[size(c0_in, 1)] "Input gain";
protected 
discrete Real c0[size(c0_in, 1)];
discrete Real c1[size(c0_in, 1)];
discrete Real cr[size(cr_in, 1)];
public 
algorithm 
(cr, c0, c1)  := Modelica.Blocks.Continuous.Internal.Filter.coefficients.lowPass(cr_in, c0_in, c1_in, f_cut);
for i in (1:size(cr_in, 1)) loop
r[i] :=  -cr[i];
end for;
for i in (1:size(c0_in, 1)) loop
a[i] :=  -c1[i]/2;
b[i] := sqrt(c0[i]-a[i]*a[i]);
ku[i] := c0[i]/b[i];
end for;
end Modelica.Blocks.Continuous.Internal.Filter.roots.lowPass;

  */
DYMOLA_STATIC struct Modelica_Blocks_Continuous_Internal_Filter_roots_lowPass_struct
   Modelica_Blocks_Continuous_Internal_Filter_roots_lowPass(RealArray   crx_0in,
   RealArray   c0x_0in, RealArray   c1x_0in, double  fx_0cut) {
  PushContext("Modelica.Blocks.Continuous.Internal.Filter.roots.lowPass")
  AssertModelica(DYNSizeSimple(c1x_0in,1)==DYNSizeSimple(c0x_0in, 1),
    "size(c1_in, 1) == size(c0_in, 1)","Dimension check of input to function failed");
  {
    /* Declare outputs and temporaries */
    RealArray    r0_0;
    RealArray    a0_0;
    RealArray    b0_0;
    RealArray    ku0_0;
    RealArray    c00_0;
    RealArray    c10_0;
    RealArray    cr0_0;
    MarkObject retmark_ = PushMark();
    r0_0=RealTemporary( 1, DYNSizeSimple(crx_0in, 1));
    RePushMark(&retmark_);
    RealFillAssign( r0_0, 0);
    a0_0=RealTemporary( 1, DYNSizeSimple(c0x_0in, 1));
    RePushMark(&retmark_);
    RealFillAssign( a0_0, 0);
    b0_0=RealTemporary( 1, DYNSizeSimple(c0x_0in, 1));
    RePushMark(&retmark_);
    RealFillAssign( b0_0, 0);
    ku0_0=RealTemporary( 1, DYNSizeSimple(c0x_0in, 1));
    RePushMark(&retmark_);
    RealFillAssign( ku0_0, 0);
    c00_0=RealTemporary( 1, DYNSizeSimple(c0x_0in, 1));
    PushMark();
    RealFillAssign( c00_0, 0);
    c10_0=RealTemporary( 1, DYNSizeSimple(c0x_0in, 1));
    PushMark();
    RealFillAssign( c10_0, 0);
    cr0_0=RealTemporary( 1, DYNSizeSimple(crx_0in, 1));
    PushMark();
    RealFillAssign( cr0_0, 0);
    /* Start of real code */
      {
        struct Modelica_Blocks_Continuous_Internal_Filter_coefficients_lowPass_struct
           dummy_mult_=Modelica_Blocks_Continuous_Internal_Filter_coefficients_lowPass
          (crx_0in, c0x_0in, c1x_0in, fx_0cut);
        RealAssign (cr0_0, dummy_mult_.cr0_0_0member);
        RealAssign (c00_0, dummy_mult_.c00_0_0member);
        RealAssign (c10_0, dummy_mult_.c10_0_0member);
      }
      Release();
      {
        int end_ = DYNSizeSimple(crx_0in, 1);
        int i0_0_0;
        for(i0_0_0 = 1;i0_0_0 <= end_;i0_0_0 += 1) {
          SetRealVectorElement( -RealVectorElement( cr0_0, (SizeType)(i0_0_0)), 
            r0_0, (SizeType)(i0_0_0));
        }
      }
      {
        int end_ = DYNSizeSimple(c0x_0in, 1);
        int i0_0_0;
        for(i0_0_0 = 1;i0_0_0 <= end_;i0_0_0 += 1) {
          SetRealVectorElement( -RealVectorElement( c10_0, (SizeType)(i0_0_0))/
            (double)(2), a0_0, (SizeType)(i0_0_0));
          SetRealVectorElement(sqrtGuarded(RealVectorElement( c00_0, (SizeType)(
            i0_0_0))-RealVectorElement( a0_0, (SizeType)(i0_0_0))*
            RealVectorElement( a0_0, (SizeType)(i0_0_0)),"c0[i]-a[i]*a[i]"), 
            b0_0, (SizeType)(i0_0_0));
          SetRealVectorElement(divmacro(RealVectorElement( c00_0, (SizeType)(
            i0_0_0)),"c0[i]",RealVectorElement( b0_0, (SizeType)(i0_0_0)),"b[i]"),
             ku0_0, (SizeType)(i0_0_0));
        }
      }
    /* Output section */
    PopMark(retmark_);
    PopContext()
    {
      struct Modelica_Blocks_Continuous_Internal_Filter_roots_lowPass_struct out_;
      out_.r0_0_0member = r0_0;
      out_.a0_0_0member = a0_0;
      out_.b0_0_0member = b0_0;
      out_.ku0_0_0member = ku0_0;
      return out_;
    }
  }}

/* Flattened Modelica model:

function Modelica.Blocks.Sources.CombiTimeTable.getNextTimeEvent
input Modelica.Blocks.Types.ExternalCombiTimeTable tableID;
discrete input Real timeIn(unit = "s");
discrete input Real tableAvailable "Dummy input to ensure correct sorting of function calls";
discrete output Real nextTimeEvent(unit = "s") "Next time event in table";

external "C" nextTimeEvent = ModelicaStandardTables_CombiTimeTable_nextTimeEvent(tableID, timeIn);
annotation(Library={"ModelicaMatIO", "ModelicaStandardTables", "zlib"}, LibraryDirectory="modelica://Modelica/Resources/Library");
end Modelica.Blocks.Sources.CombiTimeTable.getNextTimeEvent;

  */
extern double (ModelicaStandardTables_CombiTimeTable_nextTimeEvent)(void*, 
  double );
DYMOLA_STATIC double   Modelica_Blocks_Sources_CombiTimeTable_getNextTimeEvent_M
  (struct DymStruc0 tableID0_0, double  timeIn0_0, double  tableAvailable0_0) {
  PushContext("Modelica.Blocks.Sources.CombiTimeTable.getNextTimeEvent")
  {
    /* Declare outputs and temporaries */
    double   nextTimeEvent0_0;
    nextTimeEvent0_0=0;
    /* Start of real code */
    {
      nextTimeEvent0_0 = (ModelicaStandardTables_CombiTimeTable_nextTimeEvent)(
        externalTable_[tableID0_0.id_0member].obj_, timeIn0_0);
      }
    /* Output section */
    PopContext()
    return nextTimeEvent0_0;
  }}

/* Flattened Modelica model:

function Modelica.Blocks.Sources.CombiTimeTable.getTableTimeTmax
input Modelica.Blocks.Types.ExternalCombiTimeTable tableID;
discrete input Real tableAvailable "Dummy input to ensure correct sorting of function calls";
discrete output Real timeMax(unit = "s") "Maximum time value in table";

external "C" timeMax = ModelicaStandardTables_CombiTimeTable_maximumTime(tableID);
annotation(Library={"ModelicaMatIO", "ModelicaStandardTables", "zlib"}, LibraryDirectory="modelica://Modelica/Resources/Library");
end Modelica.Blocks.Sources.CombiTimeTable.getTableTimeTmax;

  */
extern double (ModelicaStandardTables_CombiTimeTable_maximumTime)(void*);
DYMOLA_STATIC double   Modelica_Blocks_Sources_CombiTimeTable_getTableTimeTmax_M
  (struct DymStruc0 tableID0_0, double  tableAvailable0_0) {
  PushContext("Modelica.Blocks.Sources.CombiTimeTable.getTableTimeTmax")
  {
    /* Declare outputs and temporaries */
    double   timeMax0_0;
    timeMax0_0=0;
    /* Start of real code */
    {
      timeMax0_0 = (ModelicaStandardTables_CombiTimeTable_maximumTime)(
        externalTable_[tableID0_0.id_0member].obj_);
      }
    /* Output section */
    PopContext()
    return timeMax0_0;
  }}

/* Flattened Modelica model:

function Modelica.Blocks.Sources.CombiTimeTable.getTableTimeTmin
input Modelica.Blocks.Types.ExternalCombiTimeTable tableID;
discrete input Real tableAvailable "Dummy input to ensure correct sorting of function calls";
discrete output Real timeMin(unit = "s") "Minimum time value in table";

external "C" timeMin = ModelicaStandardTables_CombiTimeTable_minimumTime(tableID);
annotation(Library={"ModelicaMatIO", "ModelicaStandardTables", "zlib"}, LibraryDirectory="modelica://Modelica/Resources/Library");
end Modelica.Blocks.Sources.CombiTimeTable.getTableTimeTmin;

  */
extern double (ModelicaStandardTables_CombiTimeTable_minimumTime)(void*);
DYMOLA_STATIC double   Modelica_Blocks_Sources_CombiTimeTable_getTableTimeTmin_M
  (struct DymStruc0 tableID0_0, double  tableAvailable0_0) {
  PushContext("Modelica.Blocks.Sources.CombiTimeTable.getTableTimeTmin")
  {
    /* Declare outputs and temporaries */
    double   timeMin0_0;
    timeMin0_0=0;
    /* Start of real code */
    {
      timeMin0_0 = (ModelicaStandardTables_CombiTimeTable_minimumTime)(
        externalTable_[tableID0_0.id_0member].obj_);
      }
    /* Output section */
    PopContext()
    return timeMin0_0;
  }}

/* Flattened Modelica model:

function Modelica.Blocks.Sources.CombiTimeTable.getTableValue
input Modelica.Blocks.Types.ExternalCombiTimeTable tableID;
input Integer icol;
discrete input Real timeIn(unit = "s");
discrete input Real nextTimeEvent(unit = "s");
discrete input Real pre_nextTimeEvent(unit = "s");
discrete input Real tableAvailable "Dummy input to ensure correct sorting of function calls";
discrete output Real y;

external "C" y = ModelicaStandardTables_CombiTimeTable_getValue(tableID, icol, timeIn, nextTimeEvent, pre_nextTimeEvent);
annotation(derivative(noDerivative=nextTimeEvent, noDerivative=pre_nextTimeEvent, noDerivative=tableAvailable)=Modelica.Blocks.Sources.CombiTimeTable.getDerTableValue, Library={"ModelicaMatIO", "ModelicaStandardTables", "zlib"}, LibraryDirectory="modelica://Modelica/Resources/Library");
end Modelica.Blocks.Sources.CombiTimeTable.getTableValue;

  */
extern double (ModelicaStandardTables_CombiTimeTable_getValue)(void*, int , 
  double , double , double );
DYMOLA_STATIC double   Modelica_Blocks_Sources_CombiTimeTable_getTableValue_M(
  struct DymStruc0 tableID0_0, int  icol0_0, double  timeIn0_0, double  
  nextTimeEvent0_0, double  prex_0nextTimeEvent, double  tableAvailable0_0) {
  PushContext("Modelica.Blocks.Sources.CombiTimeTable.getTableValue")
  {
    /* Declare outputs and temporaries */
    double   y0_0;
    y0_0=0;
    /* Start of real code */
    {
      y0_0 = (ModelicaStandardTables_CombiTimeTable_getValue)(externalTable_[
        tableID0_0.id_0member].obj_, icol0_0, timeIn0_0, nextTimeEvent0_0, 
        prex_0nextTimeEvent);
      }
    /* Output section */
    PopContext()
    return y0_0;
  }}

/* Flattened Modelica model:

function Modelica.Blocks.Tables.CombiTable1Ds.getTableValue
input Modelica.Blocks.Types.ExternalCombiTable1D tableID;
input Integer icol;
discrete input Real u;
discrete input Real tableAvailable "Dummy input to ensure correct sorting of function calls";
discrete output Real y;

external "C" y = ModelicaStandardTables_CombiTable1D_getValue(tableID, icol, u);
annotation(derivative(noDerivative=tableAvailable)=Modelica.Blocks.Tables.CombiTable1Ds.getDerTableValue, Library={"ModelicaMatIO", "ModelicaStandardTables", "zlib"}, LibraryDirectory="modelica://Modelica/Resources/Library");
end Modelica.Blocks.Tables.CombiTable1Ds.getTableValue;

  */
extern double (ModelicaStandardTables_CombiTable1D_getValue)(void*, int , double );
DYMOLA_STATIC double   Modelica_Blocks_Tables_CombiTable1Ds_getTableValue_M(
  struct DymStruc0 tableID0_0, int  icol0_0, double  u0_0, double  
  tableAvailable0_0) {
  PushContext("Modelica.Blocks.Tables.CombiTable1Ds.getTableValue")
  {
    /* Declare outputs and temporaries */
    double   y0_0;
    y0_0=0;
    /* Start of real code */
    {
      y0_0 = (ModelicaStandardTables_CombiTable1D_getValue)(externalTable_[
        tableID0_0.id_0member].obj_, icol0_0, u0_0);
      }
    /* Output section */
    PopContext()
    return y0_0;
  }}

/* Flattened Modelica model:

function Modelica.Blocks.Tables.CombiTable1Ds.readTableData
input Modelica.Blocks.Types.ExternalCombiTable1D tableID;
input Boolean forceRead(start = false) "= true: Force reading of table data; = false: Only read, if not yet read.";
input Boolean verboseRead "= true: Print info message; = false: No info message";
discrete output Real readSuccess "Table read success";

external "C" readSuccess = ModelicaStandardTables_CombiTable1D_read(tableID, forceRead, verboseRead);
annotation(Library={"ModelicaMatIO", "ModelicaStandardTables", "zlib"}, LibraryDirectory="modelica://Modelica/Resources/Library");
end Modelica.Blocks.Tables.CombiTable1Ds.readTableData;

  */
extern double (ModelicaStandardTables_CombiTable1D_read)(void*, int , int );
DYMOLA_STATIC double   Modelica_Blocks_Tables_CombiTable1Ds_readTableData_M(
  struct DymStruc0 tableID0_0, int  forceRead0_0, int  verboseRead0_0) {
  PushContext("Modelica.Blocks.Tables.CombiTable1Ds.readTableData")
  {
    /* Declare outputs and temporaries */
    double   readSuccess0_0;
    readSuccess0_0=0;
    /* Start of real code */
    {
      readSuccess0_0 = (ModelicaStandardTables_CombiTable1D_read)(
        externalTable_[tableID0_0.id_0member].obj_, forceRead0_0, verboseRead0_0);
      }
    /* Output section */
    PopContext()
    return readSuccess0_0;
  }}

/* Flattened Modelica model:

function constructor
input String tableName "Table name";
input String fileName "File name";
discrete input Real table[:, :];
input Integer columns[:];
input Modelica.Blocks.Types.Smoothness smoothness;
output Modelica.Blocks.Types.ExternalCombiTable1D externalCombiTable1D;

external "C" externalCombiTable1D = ModelicaStandardTables_CombiTable1D_init(tableName, fileName, table, size(table, 1), size(table, 2), columns, size(columns, 1), smoothness);
annotation(Library={"ModelicaStandardTables"}, LibraryDirectory="modelica://Modelica/Resources/Library");
end constructor;

  */
extern void* (ModelicaStandardTables_CombiTable1D_init)(const char* , 
  const char* , double  const *, size_t, size_t, int  const *, size_t, int );
DYMOLA_STATIC struct DymStruc0  Modelica_Blocks_Types_ExternalCombiTable1D_M(
  const char*  tableName0_0, const char*  fileName0_0, RealArray   table0_0, 
  IntegerArray   columns0_0, int  smoothness0_0, int id_, int alwaysMakeNew_) {
  PushContext("Modelica.Blocks.Types.ExternalCombiTable1D")
  {
    /* Declare outputs and temporaries */
    struct DymStruc0  externalCombiTable1D0_0;
    externalCombiTable1D0_0.id_0member=0;
    /* Start of real code */
    {
      externalCombiTable1D0_0.id_0member=id_;
      if (externalTable_[id_].destructor_ && externalTable_[id_].obj_ && alwaysMakeNew_) {
      void*x_=externalTable_[id_].obj_;
      externalTable_[id_].obj_=0;
      (*(externalTable_[id_].destructor_))(x_);
      } else if (!externalTable_[id_].destructor_) {externalTable_[id_].obj_=0;}
      #if (defined(_OPENMP) && !defined(DISABLE_DYMOLA_OPENMP))
      if (!(externalTable_[id_].haveLock_)) {omp_init_lock(&(externalTable_[id_].lockExternal_));externalTable_[id_].haveLock_=1;}
      #endif
      externalTable_[id_].destructor_=Modelica_Blocks_Types_ExternalCombiTable1D_destructor_M;

        if (!externalTable_[id_].obj_) externalTable_[id_].obj_ = (
        ModelicaStandardTables_CombiTable1D_init)(tableName0_0, fileName0_0, 
        table0_0.data, table0_0.dims[1-1], table0_0.dims[2-1], columns0_0.data, 
        columns0_0.dims[1-1], smoothness0_0);
      }
    /* Output section */
    PopContext()
    return externalCombiTable1D0_0;
  }}

/* Flattened Modelica model:

function destructor
input Modelica.Blocks.Types.ExternalCombiTable1D externalCombiTable1D;

external "C" ModelicaStandardTables_CombiTable1D_close(externalCombiTable1D);
annotation(Library={"ModelicaStandardTables"}, LibraryDirectory="modelica://Modelica/Resources/Library");
end destructor;

  */
extern void (ModelicaStandardTables_CombiTable1D_close)(void*);
DYMOLA_STATIC void Modelica_Blocks_Types_ExternalCombiTable1D_destructor_M(
  void* externalCombiTable1D0_0) {
  PushContext("Modelica.Blocks.Types.ExternalCombiTable1D.destructor")
  {
    /* Declare outputs and temporaries */
    /* Start of real code */
    {
      (ModelicaStandardTables_CombiTable1D_close)(externalCombiTable1D0_0);
      }
    /* Output section */
    PopContext()
    return ;
  }}

/* Flattened Modelica model:

function constructor
input String tableName "Table name";
input String fileName "File name";
discrete input Real table[:, :];
discrete input Real startTime(unit = "s");
input Integer columns[:];
input Modelica.Blocks.Types.Smoothness smoothness;
input Modelica.Blocks.Types.Extrapolation extrapolation;
output Modelica.Blocks.Types.ExternalCombiTimeTable externalCombiTimeTable;

external "C" externalCombiTimeTable = ModelicaStandardTables_CombiTimeTable_init(tableName, fileName, table, size(table, 1), size(table, 2), startTime, columns, size(columns, 1), smoothness, extrapolation);
annotation(Library={"ModelicaStandardTables"}, LibraryDirectory="modelica://Modelica/Resources/Library");
end constructor;

  */
extern void* (ModelicaStandardTables_CombiTimeTable_init)(const char* , 
  const char* , double  const *, size_t, size_t, double , int  const *, size_t, 
  int , int );
DYMOLA_STATIC struct DymStruc0  Modelica_Blocks_Types_ExternalCombiTimeTable_M(
  const char*  tableName0_0, const char*  fileName0_0, RealArray   table0_0, 
  double  startTime0_0, IntegerArray   columns0_0, int  smoothness0_0, int  
  extrapolation0_0, int id_, int alwaysMakeNew_) {
  PushContext("Modelica.Blocks.Types.ExternalCombiTimeTable")
  {
    /* Declare outputs and temporaries */
    struct DymStruc0  externalCombiTimeTable0_0;
    externalCombiTimeTable0_0.id_0member=0;
    /* Start of real code */
    {
      externalCombiTimeTable0_0.id_0member=id_;
      if (externalTable_[id_].destructor_ && externalTable_[id_].obj_ && alwaysMakeNew_) {
      void*x_=externalTable_[id_].obj_;
      externalTable_[id_].obj_=0;
      (*(externalTable_[id_].destructor_))(x_);
      } else if (!externalTable_[id_].destructor_) {externalTable_[id_].obj_=0;}
      #if (defined(_OPENMP) && !defined(DISABLE_DYMOLA_OPENMP))
      if (!(externalTable_[id_].haveLock_)) {omp_init_lock(&(externalTable_[id_].lockExternal_));externalTable_[id_].haveLock_=1;}
      #endif
      externalTable_[id_].destructor_=Modelica_Blocks_Types_ExternalCombiTimeTable_destructor_M;

        if (!externalTable_[id_].obj_) externalTable_[id_].obj_ = (
        ModelicaStandardTables_CombiTimeTable_init)(tableName0_0, fileName0_0, 
        table0_0.data, table0_0.dims[1-1], table0_0.dims[2-1], startTime0_0, 
        columns0_0.data, columns0_0.dims[1-1], smoothness0_0, extrapolation0_0);
      }
    /* Output section */
    PopContext()
    return externalCombiTimeTable0_0;
  }}

/* Flattened Modelica model:

function destructor
input Modelica.Blocks.Types.ExternalCombiTimeTable externalCombiTimeTable;

external "C" ModelicaStandardTables_CombiTimeTable_close(externalCombiTimeTable);
annotation(Library={"ModelicaStandardTables"}, LibraryDirectory="modelica://Modelica/Resources/Library");
end destructor;

  */
extern void (ModelicaStandardTables_CombiTimeTable_close)(void*);
DYMOLA_STATIC void Modelica_Blocks_Types_ExternalCombiTimeTable_destructor_M(
  void* externalCombiTimeTable0_0) {
  PushContext("Modelica.Blocks.Types.ExternalCombiTimeTable.destructor")
  {
    /* Declare outputs and temporaries */
    /* Start of real code */
    {
      (ModelicaStandardTables_CombiTimeTable_close)(externalCombiTimeTable0_0);
      }
    /* Output section */
    PopContext()
    return ;
  }}

/* Flattened Modelica model:

function Modelica.Fluid.Utilities.checkBoundary
input String mediumName;
input String substanceNames[:] "Names of substances";
input Boolean singleState;
input Boolean define_p;
discrete input Real X_boundary[:];
input String modelName(start = "??? boundary ???");
protected 
Integer nX(start = size(X_boundary, 1));
String X_str;
public 
algorithm 
assert( not singleState or singleState and define_p, "
Wrong value of parameter define_p (= false) in model \""+modelName+"\":
The selected medium \""+mediumName+"\" has Medium.singleState=true.
Therefore, an boundary density cannot be defined and
define_p = true is required.
");
for i in (1:nX) loop
assert(X_boundary[i] >= 0.0, "
Wrong boundary mass fractions in medium \""+mediumName+"\" in model \""+modelName+"\":
The boundary value X_boundary("+       String(i, true, 0)+") = "+       String(X_boundary[i], true, 0)+"
is negative. It must be positive.
");
end for;
if (nX > 0 and abs(sum(X_boundary)-1.0) > 1E-10) then 
X_str := "";
for i in (1:nX) loop
X_str := X_str+"   X_boundary["+       String(i, true, 0)+"] = "+       String(X_boundary[i], true, 0)+" \""+substanceNames[i]+"\"\n";
end for;
ModelicaError("The boundary mass fractions in medium \""+mediumName+"\" in model \""+modelName+"\"\n"+"do not sum up to 1. Instead, sum(X_boundary) = "+       String(sum(X_boundary), true, 0)+":\n"+X_str);
end if;
end Modelica.Fluid.Utilities.checkBoundary;

  */
DYMOLA_STATIC void Modelica_Fluid_Utilities_checkBoundary(const char*  
  mediumName0_0, StringArray   substanceNames0_0, int  singleState0_0, int  
  definex_0p, RealArray   Xx_0boundary, const char*  modelName0_0) {
  char*retSMark_=GetStringMark();
  PushContext("Modelica.Fluid.Utilities.checkBoundary")
  {
    /* Declare outputs and temporaries */
    int   nX0_0;
    const char*   Xx_0str;
    MarkObject retmark_ = PushMark();
    nX0_0 = DYNSizeSimple(Xx_0boundary, 1);
    Xx_0str="";
    /* Start of real code */
      AssertModelica( NOT singleState0_0 OR singleState0_0 AND definex_0p,
        " not singleState or singleState and define_p", StringAdd(StringAdd(
        StringAdd(StringAdd("\nWrong value of parameter define_p (= false) in model \"",
        modelName0_0),"\":\nThe selected medium \""),mediumName0_0),
        "\" has Medium.singleState=true.\nTherefore, an boundary density cannot be defined and\ndefine_p = true is required.\n"));
      {
        int end_ = nX0_0;
        int i0_0_0;
        for(i0_0_0 = 1;i0_0_0 <= end_;i0_0_0 += 1) {
          AssertModelica(RealElement( Xx_0boundary, (SizeType)(i0_0_0)) >= 0.0,
            "X_boundary[i] >= 0.0", StringAdd(StringAdd(StringAdd(StringAdd(
            StringAdd(StringAdd(StringAdd(StringAdd("\nWrong boundary mass fractions in medium \"",
            mediumName0_0),"\" in model \""),modelName0_0),"\":\nThe boundary value X_boundary("),
            Integer2String2(i0_0_0, true, 0)),") = "),Real2String2(RealElement( 
            Xx_0boundary, (SizeType)(i0_0_0)), true, 0)),"\nis negative. It must be positive.\n"));
        }
      }
      if (nX0_0 > 0 AND fabs(Realsum( Xx_0boundary)-1.0) > 1E-10) {
        Xx_0str = SqueezeString("", retSMark_);
        Release();
        {
          int end_ = nX0_0;
          int i0_0_0;
          for(i0_0_0 = 1;i0_0_0 <= end_;i0_0_0 += 1) {
            Xx_0str = SqueezeString(StringAdd(StringAdd(StringAdd(StringAdd(
              StringAdd(StringAdd(StringAdd(Xx_0str,"   X_boundary["),
              Integer2String2(i0_0_0, true, 0)),"] = "),Real2String2(
              RealElement( Xx_0boundary, (SizeType)(i0_0_0)), true, 0))," \""),
              StringElement( substanceNames0_0, (SizeType)(i0_0_0))),"\"\n"), retSMark_);
          }
        }
        ModelicaError(StringAdd(StringAdd(StringAdd(StringAdd(StringAdd(
          StringAdd(StringAdd(StringAdd("The boundary mass fractions in medium \"",
          mediumName0_0),"\" in model \""),modelName0_0),"\"\n"),
          "do not sum up to 1. Instead, sum(X_boundary) = "),Real2String2(
          Realsum( Xx_0boundary), true, 0)),":\n"),Xx_0str));
        Release();
      }
    /* Output section */
    PopMark(retmark_);
    SetStringMark(retSMark_);
    PopContext()
    return ;
  }}

/* Flattened Modelica model:

function Modelica.Fluid.Utilities.cubicHermite
discrete input Real x "Abscissa value";
discrete input Real x1 "Lower abscissa value";
discrete input Real x2 "Upper abscissa value";
discrete input Real y1 "Lower ordinate value";
discrete input Real y2 "Upper ordinate value";
discrete input Real y1d "Lower gradient";
discrete input Real y2d "Upper gradient";
discrete output Real y "Interpolated ordinate value";
protected 
discrete Real h "Distance between x1 and x2";
discrete Real t "abscissa scaled with h, i.e., t=[0..1] within x=[x1..x2]";
discrete Real h00 "Basis function 00 of cubic Hermite spline";
discrete Real h10 "Basis function 10 of cubic Hermite spline";
discrete Real h01 "Basis function 01 of cubic Hermite spline";
discrete Real h11 "Basis function 11 of cubic Hermite spline";
discrete Real aux3 "t cube";
discrete Real aux2 "t square";
public 
algorithm 
h := x2-x1;
if (abs(h) > 0) then 
t := (x-x1)/h;
aux3 := t^3;
aux2 := t^2;
h00 := 2*aux3-3*aux2+1;
h10 := aux3-2*aux2+t;
h01 := ( -2*aux3)+3*aux2;
h11 := aux3-aux2;
y := y1*h00+h*y1d*h10+y2*h01+h*y2d*h11;
else
y := (y1+y2)/2;
end if;
annotation(smoothOrder=3);
end Modelica.Fluid.Utilities.cubicHermite;

  */
DYMOLA_STATIC double   Modelica_Fluid_Utilities_cubicHermite(double  x0_0, 
  double  x10_0, double  x20_0, double  y10_0, double  y20_0, double  y1d0_0, 
  double  y2d0_0) {
  PushContext("Modelica.Fluid.Utilities.cubicHermite")
  {
    /* Declare outputs and temporaries */
    double   y0_0;
    double   h0_0;
    double   t0_0;
    double   h000_0;
    double   h100_0;
    double   h010_0;
    double   h110_0;
    double   aux30_0;
    double   aux20_0;
    y0_0=0;
    h0_0=0;
    t0_0=0;
    h000_0=0;
    h100_0=0;
    h010_0=0;
    h110_0=0;
    aux30_0=0;
    aux20_0=0;
    /* Start of real code */
      h0_0 = x20_0-x10_0;
      if (fabs(h0_0) > 0) {
        t0_0 = divmacro(x0_0-x10_0,"x-x1",h0_0,"h");
        aux30_0 = powmacro2(t0_0,"t",3,"3");
        aux20_0 = sqr(t0_0);
        h000_0 = 2*aux30_0-3*aux20_0+1;
        h100_0 = aux30_0-2*aux20_0+t0_0;
        h010_0 = ( -2*aux30_0)+3*aux20_0;
        h110_0 = aux30_0-aux20_0;
        y0_0 = y10_0*h000_0+h0_0*y1d0_0*h100_0+y20_0*h010_0+h0_0*y2d0_0*h110_0;
      }
      else{
        y0_0 = (y10_0+y20_0)/(double)(2);
      }
    /* Output section */
    PopContext()
    return y0_0;
  }}

/* Flattened Modelica model:

function Modelica.Math.BooleanVectors.allTrue
input Boolean b[:] "Boolean vector";
output Boolean result "= true, if all elements of b are true";

algorithm 
result := size(b, 1) > 0;
for i in (1:size(b, 1)) loop
result := result and b[i];
end for;
end Modelica.Math.BooleanVectors.allTrue;

  */
DYMOLA_STATIC int   Modelica_Math_BooleanVectors_allTrue(IntegerArray   b0_0) {
  PushContext("Modelica.Math.BooleanVectors.allTrue")
  {
    /* Declare outputs and temporaries */
    int   result0_0;
    MarkObject retmark_ = PushMark();
    result0_0=0;
    /* Start of real code */
      result0_0 = DYNSizeSimple(b0_0, 1) > 0;
      {
        int end_ = DYNSizeSimple(b0_0, 1);
        int i0_0_0;
        for(i0_0_0 = 1;i0_0_0 <= end_;i0_0_0 += 1) {
          result0_0 = result0_0 AND IntegerVectorElement( b0_0, (SizeType)(
            i0_0_0));
        }
      }
    /* Output section */
    PopMark(retmark_);
    PopContext()
    return result0_0;
  }}

/* Flattened Modelica model:

function Buildings.Fluid.HeatExchangers.BaseClasses.Internal.f_nonlinear
discrete input Real x "Independent variable of function";
discrete input Real p(start = 0.0) "Disregarded variables (here always used for pressure)";
discrete input Real X[:](start = fill(0, 0)) "Disregarded variables (her always used for composition)";
constant input Modelica.Media.Common.OneNonLinearEquation.f_nonlinear_Data f_nonlinear_data = Modelica.Media.Common.OneNonLinearEquation.f_nonlinear_Data(

);
discrete output Real y "= f_nonlinear(x)";

algorithm 
assert(x > 0, "NTU needs to be strictly positive.
Received NTU = "+       String(x, true, 0)+"
         Z   = "+       String(p, true, 0));
y := Buildings.Fluid.HeatExchangers.BaseClasses.epsilon_ntuZ(x, p, 3);
end Buildings.Fluid.HeatExchangers.BaseClasses.Internal.f_nonlinear;

  */
DYMOLA_STATIC double   Buildings_Fluid_HeatExchangers_BaseClasses_Internal_fx_0nonlinear
  (double  x0_0, double  p0_0, RealArray   X0_0, struct DymStruc2 
  fx_0nonlinearx_0data) {
  char*retSMark_=GetStringMark();
  PushContext("Buildings.Fluid.HeatExchangers.BaseClasses.Internal.f_nonlinear")
  {
    /* Declare outputs and temporaries */
    double   y0_0;
    y0_0=0;
    /* Start of real code */
      AssertModelica(x0_0 > 0,"x > 0", StringAdd(StringAdd(StringAdd(
        "NTU needs to be strictly positive.\nReceived NTU = ",Real2String2(x0_0,
         true, 0)),"\n         Z   = "),Real2String2(p0_0, true, 0)));
      y0_0 = Buildings_Fluid_HeatExchangers_BaseClasses_epsilonx_0ntuZ(x0_0, 
        p0_0, 3);
    /* Output section */
    SetStringMark(retSMark_);
    PopContext()
    return y0_0;
  }}

/* Flattened Modelica model:

function Buildings.Utilities.Math.Functions.regStep
discrete input Real x "Abscissa value";
discrete input Real y1 "Ordinate value for x > 0";
discrete input Real y2 "Ordinate value for x < 0";
discrete input Real x_small(start = 1E-05, min = 0.0) "Approximation of step for -x_small <= x <= x_small; x_small >= 0 required";
discrete output Real y "Ordinate value to approximate y = if x > 0 then y1 else y2";

algorithm 
y := smooth(1, (if x > x_small then y1 else (if x <  -x_small then y2 else (if x_small > 0 then x/x_small*((x/x_small)^2-3)*(y2-y1)/4+(y1+y2)/2 else (y1+y2)/2))));
annotation(Inline=true);
end Buildings.Utilities.Math.Functions.regStep;

  */
DYMOLA_STATIC double   Buildings_Utilities_Math_Functions_regStep(double  x0_0, 
  double  y10_0, double  y20_0, double  xx_0small) {
  PushContext("Buildings.Utilities.Math.Functions.regStep")
  {
    /* Declare outputs and temporaries */
    double   y0_0;
    y0_0=0;
    /* Start of real code */
      y0_0 = IF x0_0 > xx_0small THEN y10_0 ELSE IF x0_0 <  -xx_0small THEN 
        y20_0 ELSE IF xx_0small > 0 THEN divmacro(x0_0,"x",xx_0small,"x_small")*
        (sqr(divmacro(x0_0,"x",xx_0small,"x_small"))-3)*(y20_0-y10_0)/(double)(4)
        +(y10_0+y20_0)/(double)(2) ELSE (y10_0+y20_0)/(double)(2);
    /* Output section */
    PopContext()
    return y0_0;
  }}

/* Flattened Modelica model:

function Modelica.Blocks.Continuous.Internal.Filter.Utilities.toHighestPowerOne
discrete input Real den1[:] "[s] coefficients of polynomials (den1[i]*s + 1)";
discrete input Real den2[:, 2] "[s^2, s] coefficients of polynomials (den2[i,1]*s^2 + den2[i,2]*s + 1)";
discrete output Real cr[size(den1, 1)] "[s^0] coefficients of polynomials cr[i]*(s+1/cr[i])";
discrete output Real c0[size(den2, 1)] "[s^0] coefficients of polynomials (s^2 + (den2[i,2]/den2[i,1])*s + (1/den2[i,1]))";
discrete output Real c1[size(den2, 1)] "[s^1] coefficients of polynomials (s^2 + (den2[i,2]/den2[i,1])*s + (1/den2[i,1]))";

algorithm 
for i in (1:size(den1, 1)) loop
cr[i] := 1/den1[i];
end for;
for i in (1:size(den2, 1)) loop
c1[i] := den2[i, 2]/den2[i, 1];
c0[i] := 1/den2[i, 1];
end for;
end Modelica.Blocks.Continuous.Internal.Filter.Utilities.toHighestPowerOne;

  */
DYMOLA_STATIC struct Modelica_Blocks_Continuous_Internal_Filter_Utilities_toHighestPowerOne_struct
   Modelica_Blocks_Continuous_Internal_Filter_Utilities_toHighestPowerOne(
  RealArray   den10_0, RealArray   den20_0) {
  PushContext("Modelica.Blocks.Continuous.Internal.Filter.Utilities.toHighestPowerOne")
  AssertModelica(DYNSizeSimple(den20_0,2)==2,"size(den2, 2) == 2","Dimension check of input to function failed");
  {
    /* Declare outputs and temporaries */
    RealArray    cr0_0;
    RealArray    c00_0;
    RealArray    c10_0;
    MarkObject retmark_ = PushMark();
    cr0_0=RealTemporary( 1, DYNSizeSimple(den10_0, 1));
    RePushMark(&retmark_);
    RealFillAssign( cr0_0, 0);
    c00_0=RealTemporary( 1, DYNSizeSimple(den20_0, 1));
    RePushMark(&retmark_);
    RealFillAssign( c00_0, 0);
    c10_0=RealTemporary( 1, DYNSizeSimple(den20_0, 1));
    RePushMark(&retmark_);
    RealFillAssign( c10_0, 0);
    /* Start of real code */
      {
        int end_ = DYNSizeSimple(den10_0, 1);
        int i0_0_0;
        for(i0_0_0 = 1;i0_0_0 <= end_;i0_0_0 += 1) {
          SetRealVectorElement(divmacro(1,"1",RealVectorElement( den10_0, 
            (SizeType)(i0_0_0)),"den1[i]"), cr0_0, (SizeType)(i0_0_0));
        }
      }
      {
        int end_ = DYNSizeSimple(den20_0, 1);
        int i0_0_0;
        for(i0_0_0 = 1;i0_0_0 <= end_;i0_0_0 += 1) {
          SetRealVectorElement(divmacro(RealMatrixElement( den20_0, (SizeType)(
            i0_0_0), (SizeType)(2)),"den2[i, 2]",RealMatrixElement( den20_0, 
            (SizeType)(i0_0_0), (SizeType)(1)),"den2[i, 1]"), c10_0, (SizeType)(
            i0_0_0));
          SetRealVectorElement(divmacro(1,"1",RealMatrixElement( den20_0, 
            (SizeType)(i0_0_0), (SizeType)(1)),"den2[i, 1]"), c00_0, (SizeType)(
            i0_0_0));
        }
      }
    /* Output section */
    PopMark(retmark_);
    PopContext()
    {
      struct Modelica_Blocks_Continuous_Internal_Filter_Utilities_toHighestPowerOne_struct out_;
      out_.cr0_0_0member = cr0_0;
      out_.c00_0_0member = c00_0;
      out_.c10_0_0member = c10_0;
      return out_;
    }
  }}

/* Flattened Modelica model:

function Modelica.Blocks.Continuous.Internal.Filter.coefficients.lowPass
discrete input Real cr_in[:] "Coefficients of real poles";
discrete input Real c0_in[:] "Coefficients of s^0 term if conjugate complex pole";
discrete input Real c1_in[size(c0_in, 1)] "Coefficients of s^1 term if conjugate complex pole";
discrete input Real f_cut(unit = "Hz") "Cut-off frequency";
discrete output Real cr[size(cr_in, 1)] "Coefficient of real pole";
discrete output Real c0[size(c0_in, 1)] "Coefficients of s^0 term if conjugate complex pole";
discrete output Real c1[size(c0_in, 1)] "Coefficients of s^1 term if conjugate complex pole";
protected 
discrete Real w_cut(start = 6.283185307179586*f_cut, unit = "rad/s") "Cut-off angular frequency";
discrete Real w_cut2(start = w_cut*w_cut);
public 
algorithm 
assert(f_cut > 0, "Cut-off frequency f_cut must be positive");
cr := w_cut*cr_in;
c1 := w_cut*c1_in;
c0 := w_cut2*c0_in;
end Modelica.Blocks.Continuous.Internal.Filter.coefficients.lowPass;

  */
DYMOLA_STATIC struct Modelica_Blocks_Continuous_Internal_Filter_coefficients_lowPass_struct
   Modelica_Blocks_Continuous_Internal_Filter_coefficients_lowPass(RealArray   
  crx_0in, RealArray   c0x_0in, RealArray   c1x_0in, double  fx_0cut) {
  PushContext("Modelica.Blocks.Continuous.Internal.Filter.coefficients.lowPass")
  AssertModelica(DYNSizeSimple(c1x_0in,1)==DYNSizeSimple(c0x_0in, 1),
    "size(c1_in, 1) == size(c0_in, 1)","Dimension check of input to function failed");
  {
    /* Declare outputs and temporaries */
    RealArray    cr0_0;
    RealArray    c00_0;
    RealArray    c10_0;
    double   wx_0cut;
    double   wx_0cut2;
    MarkObject retmark_ = PushMark();
    cr0_0=RealTemporary( 1, DYNSizeSimple(crx_0in, 1));
    RePushMark(&retmark_);
    RealFillAssign( cr0_0, 0);
    c00_0=RealTemporary( 1, DYNSizeSimple(c0x_0in, 1));
    RePushMark(&retmark_);
    RealFillAssign( c00_0, 0);
    c10_0=RealTemporary( 1, DYNSizeSimple(c0x_0in, 1));
    RePushMark(&retmark_);
    RealFillAssign( c10_0, 0);
    wx_0cut = 6.283185307179586*fx_0cut;
    wx_0cut2 = wx_0cut*wx_0cut;
    /* Start of real code */
      AssertModelica(fx_0cut > 0,"f_cut > 0", "Cut-off frequency f_cut must be positive");
      RealAssign (cr0_0, RealScale (crx_0in,wx_0cut));
      Release();
      RealAssign (c10_0, RealScale (c1x_0in,wx_0cut));
      Release();
      RealAssign (c00_0, RealScale (c0x_0in,wx_0cut2));
      Release();
    /* Output section */
    PopMark(retmark_);
    PopContext()
    {
      struct Modelica_Blocks_Continuous_Internal_Filter_coefficients_lowPass_struct out_;
      out_.cr0_0_0member = cr0_0;
      out_.c00_0_0member = c00_0;
      out_.c10_0_0member = c10_0;
      return out_;
    }
  }}
/* DSblock C-code: */

BreakSectionFunctionDef(1)
BreakSectionFunctionDef(0)
BreakSectionFunctionDef(2)
BreakSectionFunctionDef(3)
BreakSectionFunctionDef(4)
BreakSectionFunctionDef(5)
  BreakSectionDef(6);
BreakSectionFunctionDef(7)
BreakSectionFunctionDef(8)
BreakSectionFunctionDef(9)
#define NX_    21
#define NX2_   1
#define NU_    0
#define NY_    0
#define NW_    1535
#define NP_    394
#define NPS_   0
#define ND_   0
#define NXP_   0
#define NInitial_   1
#define MAXAuxStr_   11
#define MAXAuxStrLen_   500
#define NHash1_ -2107463037
#define NHash2_ -521050856
#define NHash3_ 0
#define NI_    0
#define NRelF_ 24
#define NRel_  24
#define NTim_  7
#define NSamp_ 0
#define NCons_ 0
#define NA_    844
#define SizePre_ 9
#define SizeEq_ 11
#define SizeDelay_ 0
#define QNLmax_ 2
#define MAXAux 40
#define NrDymolaTimers_ 0
#define NWhen_ 7
#define NCheckIf_ 0
#define NGlobalHelp_ 262
#define NGlobalHelpI_ 69
#ifndef NExternalObject_
#define NExternalObject_ 4
#endif
#include <moutil.c>
DYMOLA_STATIC unsigned int FMIClockValueReferences_[1]={0};
DYMOLA_STATIC unsigned int FMIClockFirstValueReferences_[1]={0};
PreNonAliasDef(0)
PreNonAliasDef(1)
PreNonAliasDef(2)
PreNonAliasDef(3)
PreNonAliasDef(4)
PreNonAliasDef(5)
#if !defined(DYM2CCUR)
 DYMOLA_STATIC const char*modelName="Buildings.Applications.DHC.Loads.Examples.CouplingETS_RC_Yanfei_Cooling";
#endif
DYMOLA_STATIC const char*usedLibraries[]={0};
DYMOLA_STATIC const char*dllLibraryPath[]={0};
DYMOLA_STATIC const char*default_dymosim_license_filename=
 "c:/users/yli3/appdata/roaming/dassaultsystemes/dymola/dymola.lic";
#define QJacobianCGDef_ 1
DYMOLA_STATIC int QJacobianCG_[31]={7 , 8 , 1 , 3 , 4 , 7 , 8 , 9 , 13 , 14 , 3
   , 2 , 5 , 15 , 5 , 6 , 16 , 17 , 18 , 19 , 2 , 10 , 20 , 1 , 11 , 1 , 12 , 1
   , 21 , 0 , 0};
DYMOLA_STATIC int QJacobianGC_[148]={
1 , 0 , 1 , 4 , 4 , 0 , 7 , 8 , 9 , 9 , 0 , 0 , 13 , 14 , 0 , 14 , 14 , 14 , 4
   , 4 , 0 , 0 , 2 , 2 , 0 , 5 , 5 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 15 , 0 , 15 , 15
   , 15 , 0 , 0 , 0 , 6 , 6 , 6 , 6 , 19 , 6 , 6 , 6 , 0 , 0 , 0 , 6 , 0 , 16 , 0
   , 16 , 17 , 18 , 19 , 0 , 6 , 10 , 10 , 0 , 10 , 20 , 0 , 10 , 10 , 0 , 10 , 10
   , 10 , 0 , 0 , 0 , 0 , 0 , 0 , 20 , 20 , 10 , 11 , 11 , 0 , 11 , 0 , 0 , 11
   , 11 , 0 , 0 , 0 , 11 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 11 , 12 , 12 , 0 , 12
   , 0 , 0 , 12 , 12 , 0 , 0 , 0 , 12 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 12 , 21
   , 21 , 0 , 21 , 0 , 0 , 21 , 21 , 0 , 0 , 0 , 21 , 0 , 0 , 0 , 0 , 0 , 0 , 0
   , 0 , 21 , 0};
DYMOLA_STATIC double QJacobianCD_[22]={0  , 44 , 50 , 66 , 77 , 80 , 81 , 110 , 121
   , 132 , 104 , 98 , 90 , 176 , 187 , 180 , 171 , 180 , 189 , 198 , 184 , 120};
#include <dsblock1.c>

/* Define variable names. */

#define Sections_

TranslatedEquations

InitialSection
#if defined(DynSimStruct) || defined(BUILDFMU)
DYNX(W_,0) = false;
memcpy(&DYNX(W_,1), &DymArrays0, sizeof(double)*12);
DYNX(W_,17) = 1E-06;
DYNX(W_,18) = 1367.7;
DYNX(W_,21) = 26;
DYNX(W_,76) = 3100;
DYNX(W_,77) = 120000;
memcpy(&DYNX(W_,79), &DymArrays1, sizeof(double)*3);
memcpy(&DYNX(W_,83), &DymArrays1, sizeof(double)*3);
DYNX(W_,87) = 0.0001;
DYNX(W_,89) = 0.0001;
DYNX(W_,91) = 0.0001;
DYNX(W_,93) = 0;
DYNX(W_,95) = 1E-06;
DYNX(W_,97) = 0.0001;
memcpy(&DYNX(W_,99), &DymArrays2, sizeof(double)*3);
DYNX(W_,115) = 3;
DYNX(W_,126) = 1800;
DYNX(W_,132) = 1800;
memcpy(&DYNX(W_,152), &DymArrays3, sizeof(double)*4);
memcpy(&DYNX(W_,157), &DymArrays4, sizeof(double)*3);
DYNX(W_,165) = 0.3979486313076103;
DYNX(W_,166) = 0.017202423838958484;
memcpy(&DYNX(W_,176), &DymArrays5, sizeof(double)*5);
DYNX(W_,187) = false;
memcpy(&DYNX(W_,197), &DymArrays6, sizeof(double)*9);
DYNX(W_,207) = true;
DYNX(W_,208) = true;
DYNX(W_,216) = 0.08715574274765814;
memcpy(&DYNX(W_,218), &DymArrays7, sizeof(double)*3);
DYNX(W_,252) = 0.3979486313076103;
DYNX(W_,253) = 0.017202423838958484;
DYNX(W_,265) = true;
DYNX(W_,266) = true;
DYNX(W_,274) = 0.08715574274765814;
memcpy(&DYNX(W_,276), &DymArrays7, sizeof(double)*3);
DYNX(W_,310) = 0.3979486313076103;
DYNX(W_,311) = 0.017202423838958484;
DYNX(W_,326) = 0.3979486313076103;
DYNX(W_,327) = 0.017202423838958484;
DYNX(W_,342) = 0.3979486313076103;
DYNX(W_,343) = 0.017202423838958484;
DYNX(W_,354) = 2;
DYNX(W_,403) = 2;
DYNX(W_,404) = 2;
memcpy(&DYNX(W_,408), &DymArrays8, sizeof(double)*8);
DYNX(W_,416) = false;
memcpy(&DYNX(W_,417), &DymArrays9, sizeof(double)*3);
DYNX(W_,420) = false;
DYNX(W_,421) = false;
DYNX(W_,423) = 2;
DYNX(W_,431) = false;
DYNX(W_,432) = true;
DYNX(W_,434) = 0;
DYNX(W_,439) = 1.0;
DYNX(W_,445) = false;
DYNX(W_,447) = false;
memcpy(&DYNX(W_,448), &DymArrays10, sizeof(double)*4);
DYNX(W_,454) = 2;
DYNX(W_,478) = 2;
DYNX(W_,482) = 2;
DYNX(W_,507) = 3;
DYNX(W_,523) = 1.7976931348623157E+308;
DYNX(W_,527) = 1.0;
DYNX(W_,528) = 273.15;
DYNX(W_,532) = 1.0;
DYNX(W_,533) = 273.15;
DYNX(W_,537) = 2;
DYNX(W_,540) = 1;
DYNX(W_,552) = 1;
DYNX(W_,554) = true;
DYNX(W_,555) = false;
DYNX(W_,573) = 2;
DYNX(W_,576) = 1;
DYNX(W_,588) = 1;
DYNX(W_,590) = true;
DYNX(W_,591) = false;
DYNX(W_,610) = true;
DYNX(W_,611) = true;
memcpy(&DYNX(W_,619), &DymArrays11, sizeof(double)*4);
DYNX(W_,629) = true;
DYNX(W_,630) = true;
DYNX(W_,632) = 0.5;
DYNX(W_,633) = 0.5;
DYNX(W_,636) = false;
DYNX(W_,645) = 1000;
DYNX(W_,650) = 500;
DYNX(W_,653) = true;
DYNX(W_,654) = true;
DYNX(W_,659) = true;
DYNX(W_,660) = true;
DYNX(W_,661) = true;
DYNX(W_,662) = 0.5;
DYNX(W_,664) = false;
DYNX(W_,670) = 1000;
DYNX(W_,673) = true;
DYNX(W_,674) = true;
DYNX(W_,677) = true;
DYNX(W_,680) = false;
DYNX(W_,684) = true;
DYNX(W_,685) = true;
DYNX(W_,686) = false;
DYNX(W_,687) = false;
#endif
DYNSetAuxString(did_, "SimpleLiquidWater", 7);
#if defined(DynSimStruct) || defined(BUILDFMU)
DYNX(W_,698) = 1;
DYNX(W_,702) = 200;
DYNX(W_,704) = true;
DYNX(W_,705) = 0.5;
DYNX(W_,707) = false;
DYNX(W_,712) = 1000;
DYNX(W_,717) = 0.5;
DYNX(W_,718) = 1000;
DYNX(W_,725) = true;
DYNX(W_,726) = 0.5;
DYNX(W_,728) = false;
DYNX(W_,734) = 500;
DYNX(W_,737) = true;
DYNX(W_,738) = true;
DYNX(W_,741) = true;
DYNX(W_,744) = false;
DYNX(W_,748) = true;
DYNX(W_,749) = true;
DYNX(W_,750) = false;
DYNX(W_,751) = false;
DYNX(W_,765) = 200;
DYNX(W_,767) = true;
DYNX(W_,768) = 0.5;
DYNX(W_,770) = false;
DYNX(W_,775) = 500;
DYNX(W_,780) = 0.5;
DYNX(W_,781) = 500;
DYNX(W_,802) = true;
DYNX(W_,832) = 4;
DYNX(W_,848) = 1;
DYNX(W_,859) = 1;
DYNX(W_,861) = true;
DYNX(W_,862) = true;
DYNX(W_,878) = true;
DYNX(W_,893) = true;
DYNX(W_,909) = true;
DYNX(W_,912) = 1;
DYNX(W_,913) = true;
DYNX(W_,928) = true;
DYNX(W_,929) = 0.5;
DYNX(W_,931) = false;
DYNX(W_,941) = 0.5;
DYNX(W_,943) = 1;
DYNX(W_,949) = true;
DYNX(W_,950) = 2;
memcpy(&DYNX(W_,953), &DymArrays12, sizeof(double)*3);
DYNX(W_,958) = 2;
memcpy(&DYNX(W_,960), &DymArrays13, sizeof(double)*4);
DYNX(W_,986) = 1;
DYNX(W_,987) = false;
DYNX(W_,989) = 3;
DYNX(W_,991) = false;
DYNX(W_,992) = false;
DYNX(W_,993) = false;
DYNX(W_,994) = false;
DYNX(W_,995) = true;
DYNX(W_,996) = true;
DYNX(W_,997) = false;
DYNX(W_,998) = true;
DYNX(W_,1013) = true;
DYNX(W_,1029) = 1;
DYNX(W_,1030) = false;
DYNX(W_,1031) = 3;
DYNX(W_,1033) = false;
DYNX(W_,1034) = false;
DYNX(W_,1035) = false;
DYNX(W_,1036) = false;
DYNX(W_,1037) = false;
DYNX(W_,1038) = true;
DYNX(W_,1039) = false;
DYNX(W_,1040) = 4;
DYNX(W_,1041) = 4;
DYNX(W_,1045) = false;
DYNX(W_,1049) = 0.5;
DYNX(W_,1051) = false;
DYNX(W_,1064) = 3;
DYNX(W_,1068) = true;
DYNX(W_,1069) = true;
DYNX(W_,1081) = 2;
DYNX(W_,1082) = false;
DYNX(W_,1083) = 2;
memcpy(&DYNX(W_,1090), &DymArrays14, sizeof(double)*4);
DYNX(W_,1099) = true;
DYNX(W_,1100) = true;
DYNX(W_,1102) = 2;
DYNX(W_,1104) = false;
DYNX(W_,1116) = true;
DYNX(W_,1117) = false;
memcpy(&DYNX(W_,1121), &DymArrays12, sizeof(double)*3);
DYNX(W_,1126) = 2;
memcpy(&DYNX(W_,1129), &DymArrays13, sizeof(double)*4);
DYNX(W_,1138) = false;
DYNX(W_,1142) = false;
DYNX(W_,1143) = true;
DYNX(W_,1145) = true;
DYNX(W_,1146) = false;
DYNX(W_,1158) = true;
DYNX(W_,1184) = 2;
DYNX(W_,1190) = 2;
DYNX(W_,1197) = false;
DYNX(W_,1198) = true;
DYNX(W_,1205) = 2;
DYNX(W_,1210) = 3;
DYNX(W_,1217) = 4;
DYNX(W_,1250) = true;
DYNX(W_,1252) = 0.5;
DYNX(W_,1254) = false;
DYNX(W_,1260) = 2;
memcpy(&DYNX(W_,1264), &DymArrays15, sizeof(double)*6);
DYNX(W_,1275) = true;
DYNX(W_,1276) = true;
DYNX(W_,1278) = 2;
DYNX(W_,1289) = false;
DYNX(W_,1290) = false;
DYNX(W_,1291) = true;
DYNX(W_,1292) = 0.5;
DYNX(W_,1294) = false;
DYNX(W_,1299) = 2;
DYNX(W_,1304) = 0.5;
DYNX(W_,1305) = 2;
DYNX(W_,1319) = 1;
DYNX(W_,1333) = 1.7976931348623157E+308;
DYNX(W_,1350) = 2;
DYNX(W_,1358) = true;
DYNX(W_,1359) = 0;
DYNX(W_,1360) = false;
DYNX(W_,1361) = false;
DYNX(W_,1369) = false;
#endif
DYNSetAuxString(did_, "SimpleAir", 10);
#if defined(DynSimStruct) || defined(BUILDFMU)
DYNX(W_,1384) = false;
DYNX(W_,1391) = 2;
DYNX(W_,1392) = 1;
DYNX(W_,1397) = 2;
DYNX(W_,1398) = 2;
DYNX(W_,1409) = 1;
DYNX(W_,1425) = 1;
DYNX(W_,1431) = 1;
DYNX(W_,1440) = 1;
DYNX(W_,1449) = false;
DYNX(W_,1453) = false;
DYNX(W_,1457) = true;
DYNX(W_,1458) = true;
DYNX(W_,1459) = false;
DYNX(W_,1460) = false;
DYNX(W_,1474) = 200;
DYNX(W_,1477) = 1;
#endif
BreakSectionFunctionCallNew(0);
BreakSectionFunctionEnd()
BreakSectionFunctionStart(1);
#if defined(DynSimStruct) || defined(BUILDFMU)
DYNX(W_,1485) = true;
DYNX(W_,1486) = 2;
DYNX(W_,1487) = false;
DYNX(W_,1488) = false;
DYNX(W_,1494) = false;
DYNX(W_,1513) = false;
DYNX(W_,407) = 1;
DYNX(W_,626) = 0;
DYNX(W_,646) = false;
DYNX(W_,647) = 0.1;
DYNX(W_,651) = false;
DYNX(W_,652) = 0.1;
DYNX(W_,881) = 1;
DYNX(W_,896) = 1;
DYNX(W_,916) = 1;
DYNX(W_,951) = 4;
DYNX(W_,1001) = 1;
DYNX(W_,1017) = 1;
DYNX(W_,1070) = 4;
DYNX(W_,1238) = 6000;
DYNX(W_,1261) = false;
DYNX(W_,1262) = 0.1;
#endif
DYNSetAuxString(did_, "C:/Users/YLI3/Yanfei_Projects/modelica-buildings-yanfei/Buildings/Resources/weatherdata/USA_CA_San.Francisco.Intl.AP.724940_TMY3.mos",
   0);
#if defined(DynSimStruct) || defined(BUILDFMU)
memcpy(&DYNX(W_,13), &DymArrays16, sizeof(double)*4);
DYNX(W_,46) = true;
#endif
DYNSetAuxString(did_, "tab1", 1);
DYNSetAuxString(did_, "C:/Users/YLI3/Yanfei_Projects/modelica-buildings-yanfei/Buildings/Resources/weatherdata/USA_CA_San.Francisco.Intl.AP.724940_TMY3.mos",
   2);
#if defined(DynSimStruct) || defined(BUILDFMU)
memcpy(&DYNX(W_,47), &DymArrays17, sizeof(double)*27);
DYNX(W_,102) = 1;
DYNX(W_,109) = 1800;
DYNX(W_,111) = -28800.0;
DYNX(W_,112) = -2.1362830044410592;
DYNX(W_,114) = -576.0;
DYNX(W_,117) = true;
#endif
DYNSetAuxString(did_, "tab1", 3);
DYNSetAuxString(did_, "C:/Users/YLI3/Yanfei_Projects/modelica-buildings-yanfei/Buildings/Resources/weatherdata/USA_CA_San.Francisco.Intl.AP.724940_TMY3.mos",
   4);
#if defined(DynSimStruct) || defined(BUILDFMU)
memcpy(&DYNX(W_,118), &DymArrays18, sizeof(double)*4);
DYNX(W_,162) = 0.6565928646002667;
DYNX(W_,167) = 0.6565928646002667;
DYNX(W_,169) = -2.1362830044410592;
memcpy(&DYNX(W_,171), &DymArrays19, sizeof(double)*5);
memcpy(&DYNX(W_,181), &DymArrays20, sizeof(double)*6);
DYNX(W_,405) = 2;
DYNX(W_,406) = 2;
DYNX(W_,422) = 2;
DYNX(W_,424) = 2;
DYNX(W_,425) = 2;
DYNX(W_,429) = 1.0;
DYNX(W_,430) = true;
DYNX(W_,433) = 0.105;
DYNX(W_,435) = 1.05E-05;
DYNX(W_,436) = true;
DYNX(W_,437) = 52.5;
memcpy(&DYNX(W_,440), &DymArrays21, sizeof(double)*3);
DYNX(W_,452) = 11.5;
DYNX(W_,453) = 14.0;
DYNX(W_,455) = 0.45098039215686275;
DYNX(W_,456) = 0.5490196078431373;
#endif
DYNSetAuxString(did_, "NoName", 5);
DYNSetAuxString(did_, "NoName", 6);
#if defined(DynSimStruct) || defined(BUILDFMU)
DYNX(W_,511) = 1;
DYNX(W_,529) = 273.15;
DYNX(W_,530) = 1.0;
DYNX(W_,534) = 273.15;
DYNX(W_,535) = 1.0;
DYNX(W_,538) = 2;
DYNX(W_,539) = true;
memcpy(&DYNX(W_,547), &DymArrays22, sizeof(double)*3);
DYNX(W_,556) = 0;
DYNX(W_,562) = 1;
DYNX(W_,563) = -1;
DYNX(W_,570) = true;
DYNX(W_,571) = true;
DYNX(W_,574) = 2;
DYNX(W_,575) = true;
memcpy(&DYNX(W_,583), &DymArrays22, sizeof(double)*3);
DYNX(W_,592) = 0;
DYNX(W_,598) = 1;
DYNX(W_,599) = -1;
DYNX(W_,606) = true;
DYNX(W_,607) = true;
DYNX(W_,625) = 5;
DYNX(W_,634) = 5E-05;
DYNX(W_,635) = 5E-05;
DYNX(W_,643) = true;
DYNX(W_,644) = false;
DYNX(W_,648) = true;
DYNX(W_,649) = false;
DYNX(W_,655) = true;
DYNX(W_,663) = 5E-05;
DYNX(W_,666) = 0;
DYNX(W_,667) = 0;
DYNX(W_,668) = true;
DYNX(W_,669) = false;
DYNX(W_,671) = false;
DYNX(W_,672) = 0.1;
DYNX(W_,675) = true;
DYNX(W_,678) = 0.5;
DYNX(W_,679) = 5E-05;
DYNX(W_,682) = 0;
DYNX(W_,683) = 0;
DYNX(W_,688) = true;
memcpy(&DYNX(W_,690), &DymArrays23, sizeof(double)*8);
memcpy(&DYNX(W_,699), &DymArrays24, sizeof(double)*3);
DYNX(W_,706) = 5E-05;
DYNX(W_,709) = 0;
DYNX(W_,710) = 0;
DYNX(W_,711) = false;
DYNX(W_,713) = true;
DYNX(W_,714) = false;
DYNX(W_,721) = true;
DYNX(W_,719) = 0.1;
DYNX(W_,715) = 0.05;
DYNX(W_,716) = 0.001;
DYNX(W_,720) = 0.015811388300841896;
DYNX(W_,722) = 0;
DYNX(W_,727) = 5E-05;
DYNX(W_,730) = 0;
DYNX(W_,731) = 0;
DYNX(W_,732) = true;
DYNX(W_,733) = false;
DYNX(W_,735) = false;
DYNX(W_,736) = 0.1;
DYNX(W_,739) = true;
DYNX(W_,742) = 0.5;
DYNX(W_,743) = 5E-05;
DYNX(W_,746) = 0;
DYNX(W_,747) = 0;
DYNX(W_,752) = true;
memcpy(&DYNX(W_,754), &DymArrays25, sizeof(double)*11);
DYNX(W_,769) = 5E-05;
DYNX(W_,772) = 0;
DYNX(W_,773) = 0;
DYNX(W_,774) = false;
DYNX(W_,776) = true;
DYNX(W_,777) = false;
DYNX(W_,784) = true;
DYNX(W_,782) = 0.1;
DYNX(W_,778) = 0.05;
DYNX(W_,779) = 0.001;
DYNX(W_,783) = 0.022360679774997897;
DYNX(W_,785) = 0;
DYNX(W_,801) = 2;
memcpy(&DYNX(W_,811), &DymArrays26, sizeof(double)*4);
DYNX(W_,842) = 4;
DYNX(W_,843) = 0.0;
DYNX(W_,846) = true;
DYNX(W_,849) = 0.0;
memcpy(&DYNX(W_,854), &DymArrays22, sizeof(double)*3);
DYNX(W_,869) = 1;
DYNX(W_,870) = -1;
DYNX(W_,876) = true;
DYNX(W_,877) = true;
DYNX(W_,879) = 0.5;
DYNX(W_,880) = 5E-05;
DYNX(W_,882) = 3;
DYNX(W_,884) = true;
DYNX(W_,886) = 1.0;
DYNX(W_,887) = false;
DYNX(W_,894) = 0.5;
DYNX(W_,895) = 5E-05;
DYNX(W_,897) = 3;
DYNX(W_,899) = true;
DYNX(W_,901) = 1.0;
DYNX(W_,902) = false;
DYNX(W_,908) = 3;
DYNX(W_,910) = 0;
DYNX(W_,911) = 0;
DYNX(W_,914) = 0.5;
DYNX(W_,915) = 5E-05;
DYNX(W_,917) = 3;
DYNX(W_,919) = true;
DYNX(W_,921) = 1.0;
DYNX(W_,922) = false;
DYNX(W_,930) = 5E-05;
DYNX(W_,933) = 0;
DYNX(W_,934) = 0;
DYNX(W_,935) = false;
DYNX(W_,937) = true;
DYNX(W_,938) = false;
DYNX(W_,940) = 0.001;
DYNX(W_,957) = 4;
DYNX(W_,979) = 4184;
DYNX(W_,974) = 4184.0;
DYNX(W_,977) = 300000.0;
DYNX(W_,978) = 293.15;
DYNX(W_,1002) = 3;
DYNX(W_,1004) = true;
DYNX(W_,1006) = 1.0;
DYNX(W_,1007) = false;
DYNX(W_,1018) = 3;
DYNX(W_,1020) = true;
DYNX(W_,1022) = 1.0;
DYNX(W_,1023) = false;
memcpy(&DYNX(W_,1042), &DymArrays27, sizeof(double)*3);
DYNX(W_,1050) = 5E-05;
memcpy(&DYNX(W_,1053), &DymArrays28, sizeof(double)*6);
DYNX(W_,1063) = false;
DYNX(W_,1239) = 0.5;
DYNX(W_,1065) = 0.5;
DYNX(W_,1240) = 0.5;
DYNX(W_,1066) = 0.5;
DYNX(W_,1067) = false;
DYNX(W_,1080) = 0;
DYNX(W_,1084) = true;
DYNX(W_,1086) = 995.586;
DYNX(W_,1085) = 0.0005022167848884978;
DYNX(W_,1097) = 1;
DYNX(W_,1098) = false;
DYNX(W_,1101) = 0.5;
DYNX(W_,1103) = 5E-05;
DYNX(W_,1113) = 995.586;
memcpy(&DYNX(W_,1110), &DymArrays29, sizeof(double)*3);
DYNX(W_,1125) = 4;
DYNX(W_,1128) = 0.5;
DYNX(W_,1141) = 5E-05;
DYNX(W_,1148) = true;
DYNX(W_,1150) = 5.022167848884978E-07;
memcpy(&DYNX(W_,1154), &DymArrays30, sizeof(double)*3);
DYNX(W_,1159) = 0;
DYNX(W_,1160) = 0;
memcpy(&DYNX(W_,1166), &DymArrays31, sizeof(double)*4);
DYNX(W_,1170) = false;
memcpy(&DYNX(W_,1178), &DymArrays32, sizeof(double)*3);
DYNX(W_,1183) = true;
DYNX(W_,1185) = false;
DYNX(W_,1186) = 0.0010044335697769957;
DYNX(W_,1187) = 995.586;
DYNX(W_,1188) = true;
DYNX(W_,1189) = 0.0005022167848884978;
DYNX(W_,1191) = true;
DYNX(W_,1237) = true;
DYNX(W_,1201) = 12000.0;
DYNX(W_,1204) = 1;
memcpy(&DYNX(W_,1206), &DymArrays33, sizeof(double)*3);
memcpy(&DYNX(W_,1211), &DymArrays28, sizeof(double)*6);
memcpy(&DYNX(W_,1218), &DymArrays34, sizeof(double)*8);
DYNX(W_,1235) = 0;
memcpy(&DYNX(W_,1241), &DymArrays35, sizeof(double)*5);
DYNX(W_,1249) = 995.586;
DYNX(W_,1253) = 5E-05;
DYNX(W_,1256) = 0;
DYNX(W_,1257) = 0;
DYNX(W_,1258) = true;
DYNX(W_,1259) = false;
DYNX(W_,1263) = true;
DYNX(W_,1273) = 1;
DYNX(W_,1274) = false;
DYNX(W_,1277) = 0.5;
DYNX(W_,1279) = 5E-05;
#endif
BreakSectionFunctionEnd()
BreakSectionFunctionStart(2);
#if defined(DynSimStruct) || defined(BUILDFMU)
DYNX(W_,1280) = true;
DYNX(W_,1310) = 995.586;
memcpy(&DYNX(W_,1283), &DymArrays36, sizeof(double)*4);
DYNX(W_,1293) = 5E-05;
DYNX(W_,1296) = 0;
DYNX(W_,1297) = 0;
DYNX(W_,1298) = false;
DYNX(W_,1300) = true;
DYNX(W_,1301) = false;
DYNX(W_,1308) = true;
DYNX(W_,1306) = 0.1;
DYNX(W_,1302) = 0.05;
DYNX(W_,1303) = 0.001;
DYNX(W_,1307) = 0.35355339059327373;
DYNX(W_,1309) = 0;
DYNX(W_,1316) = 0;
#endif
DYNSetAuxString(did_, "NoName", 8);
DYNSetAuxString(did_, "NoName", 9);
#if defined(DynSimStruct) || defined(BUILDFMU)
DYNX(W_,1321) = 2;
DYNX(W_,1323) = 3600;
DYNX(W_,1335) = 293.15;
DYNX(W_,1338) = false;
DYNX(W_,1349) = 2;
DYNX(W_,1351) = 2;
DYNX(W_,1352) = 2;
DYNX(W_,1356) = 1.0;
DYNX(W_,1357) = true;
DYNX(W_,1370) = true;
DYNX(W_,1375) = 52.5;
memcpy(&DYNX(W_,1380), &DymArrays21, sizeof(double)*3);
DYNX(W_,1377) = 1005.45;
DYNX(W_,1376) = 0.0;
DYNX(W_,1379) = false;
memcpy(&DYNX(W_,1388), &DymArrays32, sizeof(double)*3);
DYNX(W_,1393) = 0.45098039215686275;
DYNX(W_,1394) = 0.5490196078431373;
DYNX(W_,1423) = 2;
DYNX(W_,1429) = 2;
DYNX(W_,1438) = 1;
DYNX(W_,1439) = 0.0;
DYNX(W_,1441) = 0.0;
DYNX(W_,1446) = 2;
DYNX(W_,1451) = 0.5;
DYNX(W_,1452) = 5E-05;
DYNX(W_,1455) = 0;
DYNX(W_,1456) = 0;
DYNX(W_,1461) = true;
memcpy(&DYNX(W_,1463), &DymArrays25, sizeof(double)*11);
DYNX(W_,1476) = 1;
DYNX(W_,1478) = 1;
DYNX(W_,1479) = 1;
DYNX(W_,1483) = 1.0;
DYNX(W_,1484) = false;
DYNX(W_,1495) = true;
DYNX(W_,1511) = 995.586;
DYNX(W_,1506) = 4184;
DYNX(W_,1503) = 0.0;
DYNX(W_,1507) = 995.586;
DYNX(W_,1508) = false;
DYNX(W_,1509) = 300000.0;
DYNX(W_,1510) = 293.15;
DYNX(W_,483) = true;
DYNX(W_,509) = false;
DYNX(W_,510) = 1;
DYNX(W_,623) = 1;
DYNX(W_,624) = 0;
DYNX(W_,627) = 0;
DYNX(W_,969) = 0;
DYNX(W_,1202) = 0.05;
DYNX(W_,1320) = false;
DYNX(W_,1322) = 1;
DYNX(W_,107) = 1800;
DYNX(W_,1499) = 0.0;
DYNX(W_,1161) = 0;
DYNX(W_,1163) = 0;
DYNX(W_,1071) = 1;
DYNX(W_,1162) = 0;
DYNX(W_,477) = 0;
DYNX(W_,476) = 0;
DYNX(W_,550) = 0;
DYNX(W_,586) = 0;
DYNX(W_,657) = 0;
DYNX(W_,658) = 0;
DYNX(W_,681) = 0.0;
DYNX(W_,703) = 0;
DYNX(W_,745) = 0.0;
DYNX(W_,766) = 0;
DYNX(W_,1108) = 0;
DYNX(W_,1109) = 0;
DYNX(W_,1147) = 0;
DYNX(W_,1164) = 0;
DYNX(W_,1385) = 0;
DYNX(W_,1454) = 0.0;
DYNX(W_,1475) = 0;
DYNX(W_,1491) = 1;
DYNX(W_,1492) = 0;
DYNX(W_,1514) = 0;
DYNX(W_,1499) = 0.0;
DYNX(W_,1499) = 0.0;
DYNX(W_,1500) = 0.0;
DYNX(W_,1493) = 0.018015268;
DYNX(W_,1490) = 995.586;
DYNX(W_,230) = 0.01;
memcpy(&DYNX(W_,1517), &DymArrays37, sizeof(double)*4);
DYNX(W_,288) = 0.01;
memcpy(&DYNX(W_,1521), &DymArrays38, sizeof(double)*12);
DYNX(W_,195) = 0.0;
DYNX(W_,196) = 0.0;
DYNX(W_,1341) = 0.0;
DYNX(W_,593) = 0.0;
DYNX(W_,1433) = false;
DYNX(W_,557) = 0.0;
DYNX(W_,1427) = false;
memcpy(&DYNX(W_,1345), &DymArrays32, sizeof(double)*3);
memcpy(&DYNX(W_,1342), &DymArrays32, sizeof(double)*3);
DYNX(W_,1339) = 0.0;
DYNX(W_,190) = 0.0;
DYNX(W_,191) = 0.0;
DYNX(W_,1374) = 0.0;
DYNX(W_,1373) = 0.0;
DYNX(W_,1368) = 0.0289651159;
DYNX(W_,1367) = 287.0508037566665;
DYNX(W_,1365) = 1.0;
DYNX(W_,1533) = 0.6565928646002667;
DYNX(W_,1534) = -2.1362830044410592;
DYNX(W_,1443) = false;
DYNX(W_,1442) = 0.0;
DYNX(W_,863) = 0.0;
DYNX(W_,676) = 0.0;
DYNX(W_,724) = 0.0;
DYNX(W_,740) = 0.0;
DYNX(W_,787) = 0.0;
DYNX(W_,1195) = 1.0;
DYNX(W_,1193) = 995.586;
DYNX(W_,1192) = 1.0;
DYNX(W_,1074) = 0.0;
DYNX(W_,1046) = 83680.0;
DYNX(W_,1139) = 83680.0;
DYNX(W_,1157) = 995.586;
DYNX(W_,1106) = 83680.0;
DYNX(W_,1450) = 83680.0;
memcpy(&DYNX(W_,103), &DymArrays39, sizeof(double)*3);
DYNX(W_,110) = 1800.0;
DYNX(W_,168) = 0.6565928646002667;
DYNX(W_,170) = -2.1362830044410592;
DYNX(W_,1516) = 0.6565928646002667;
DYNX(W_,1515) = -2.1362830044410592;
DYNX(F_,10) = 0.0;
#endif
if (!DymolaUserHomotopy) UpdateInitVars(time, X_, XD_, U_, DP_, IP_, LP_, F_, Y_, W_, QZ_, duser_, iuser_, cuser_, did_, 1);
BoundParameterSection
AssertModelica(DYNX(DP_,292) > 0,"coo.val.l > 0", "Valve leakage parameter l must be bigger than zero.");
AssertModelica(DYNX(DP_,307) > 10000.0,"souDis.p > 10000.0", StringAdd(
  StringAdd("In CouplingETS_RC_Yanfei_Cooling.souDis: The parameter value p=",
  Real2String2(DYNX(DP_,307), true, 0))," is low for water. This is likely an error."));
PopAllMarks();
AssertModelica(DYNX(DP_,316) > 10000.0,"sinDis.p > 10000.0", StringAdd(
  StringAdd("In CouplingETS_RC_Yanfei_Cooling.sinDis: The parameter value p=",
  Real2String2(DYNX(DP_,316), true, 0))," is low for water. This is likely an error."));
PopAllMarks();
AssertModelica4(DYNX(DP_,331),"pumpBuiding.nominalValuesDefineDefaultPressureCurve",
   "*** Warning: You are using a flow or pressure controlled mover with the\n             default pressure curve.\n             This leads to approximate calculations of the electrical power\n             consumption. Add the correct pressure curve in the record per\n             to obtain an accurate computation.\n             Setting nominalValuesDefineDefaultPressureCurve=true will suppress this warning.",
   1,DYNX(did_->helpvari_vec,0));
AssertModelica4(DYNX(DP_,331) OR DYNX(DP_,321) == false,"pumpBuiding.nominalValuesDefineDefaultPressureCurve or pumpBuiding.per.use_powerCharacteristic == false",
   "*** Warning: You are using a flow or pressure controlled mover with the\n             default pressure curve and you set use_powerCharacteristic = true.\n             Since this can cause wrong power consumption, the model will overwrite\n             this setting and use instead use_powerCharacteristic = false.Since this causes the efficiency curve to be used,\n             make sure that the efficiency curves in the performance record per\n             are correct or add the pressure curve of the mover.\n             Setting nominalValuesDefineDefaultPressureCurve=true will suppress this warning.",
   1,DYNX(did_->helpvari_vec,1));
AssertModelica(DYNX(DP_,4) > 3100.0,"weaDat.pAtm > 3100.0", StringAdd(
  "Pressure out of bounds.\n   PIn = ",Real2String2(DYNX(DP_,4), true, 0)));
PopAllMarks();
AssertModelica(DYNX(DP_,4) < 120000.0,"weaDat.pAtm < 120000.0", StringAdd(
  "Pressure out of bounds.\n   PIn = ",Real2String2(DYNX(DP_,4), true, 0)));
PopAllMarks();
AssertModelica(DYNX(DP_,210) >= DYNX(DP_,211),"building.conPIDMinT.yMax >= building.conPIDMinT.yMin",
   StringAdd(StringAdd(StringAdd(StringAdd("LimPID: Limits must be consistent. However, yMax (=",
  Real2String2(DYNX(DP_,210), true, 0)),") < yMin (="),Real2String2(
  DYNX(DP_,211), true, 0)),")"));
PopAllMarks();
AssertModelica(DYNX(DP_,225) >= DYNX(DP_,226),"building.conPIDMax.yMax >= building.conPIDMax.yMin",
   StringAdd(StringAdd(StringAdd(StringAdd("LimPID: Limits must be consistent. However, yMax (=",
  Real2String2(DYNX(DP_,225), true, 0)),") < yMin (="),Real2String2(
  DYNX(DP_,226), true, 0)),")"));
PopAllMarks();
AssertModelica(DYNX(DP_,291) > 0,"coo.val.filter.u_nominal > 0", 
  "u_nominal > 0 required");
AssertModelica(DYNX(DP_,286) > 0,"coo.val.filter.A_ripple > 0", "A_ripple > 0 required");
AssertModelica(DYNX(DP_,336) > 0,"pumpBuiding.filter.A_ripple > 0", 
  "A_ripple > 0 required");
BoundParameterSection
RealAssign (RealTemporaryDense( &DYNX(W_,19), 1, 2), (PushModelContext(1,
  "Buildings.BoundaryConditions.WeatherData.BaseClasses.getTimeSpanTMY3(weaDat.filNam, \"tab1\")")
  Buildings_BoundaryConditions_WeatherData_BaseClasses_getTimeSpanTMY3_M(
  "C:/Users/YLI3/Yanfei_Projects/modelica-buildings-yanfei/Buildings/Resources/weatherdata/USA_CA_San.Francisco.Intl.AP.724940_TMY3.mos",
   "tab1")));
PopAllMarks();
DYNX(W_,124) = DYNX(W_,19);
DYNX(W_,125) = DYNX(W_,20);
DYNX(W_,127) = DYNX(W_,125)-DYNX(W_,124);
DYNX(DYNhelp,0) = modulusDymola(DYNX(W_,127), 31536000);
DYNX(DYNhelp,1) = fabs(DYNX(DYNhelp,0));
DYNX(W_,128) = DYNX(DYNhelp,1) < 0.01;
DYNX(W_,130) = DYNX(W_,19);
DYNX(W_,131) = DYNX(W_,20);
DYNX(W_,133) = DYNX(W_,131)-DYNX(W_,130);
DYNX(DYNhelp,2) = modulusDymola(DYNX(W_,133), 31536000);
DYNX(DYNhelp,3) = fabs(DYNX(DYNhelp,2));
DYNX(W_,134) = DYNX(DYNhelp,3) < 0.01;
DYNX(W_,209) = DYNX(DP_,30);
DYNX(W_,210) = DYNX(DP_,29);
DYNX(W_,248) = DYNX(DP_,31);
DYNX(W_,249) = DYNX(DP_,32);
DYNX(W_,250) = DYNX(DP_,29);
DYNX(W_,255) = DYNX(W_,248);
DYNX(W_,256) = DYNX(W_,249);
DYNX(W_,257) = DYNX(W_,250);
DYNX(W_,267) = DYNX(DP_,36);
DYNX(W_,268) = DYNX(DP_,35);
DYNX(W_,306) = DYNX(DP_,37);
DYNX(W_,307) = DYNX(DP_,38);
DYNX(W_,308) = DYNX(DP_,35);
DYNX(W_,313) = DYNX(W_,306);
DYNX(W_,314) = DYNX(W_,307);
DYNX(W_,315) = DYNX(W_,308);
DYNX(W_,322) = DYNX(DP_,42);
DYNX(W_,323) = DYNX(DP_,43);
DYNX(W_,324) = DYNX(DP_,41);
DYNX(W_,329) = DYNX(W_,322);
DYNX(W_,330) = DYNX(W_,323);
DYNX(W_,331) = DYNX(W_,324);
DYNX(W_,338) = DYNX(DP_,45);
DYNX(W_,339) = DYNX(DP_,46);
DYNX(W_,340) = DYNX(DP_,44);
DYNX(W_,345) = DYNX(W_,338);
DYNX(W_,346) = DYNX(W_,339);
DYNX(W_,347) = DYNX(W_,340);
DYNX(W_,365) = DYNX(DP_,56)*DYNX(DP_,57);
DYNX(W_,366) = 1-DYNX(DP_,56);
DYNX(W_,367) = divmacro(DYNX(W_,366),"building.corGDouPan.rho_T1_diff",2-
  DYNX(W_,366),"2-building.corGDouPan.rho_T1_diff");
DYNX(W_,368) = DYNX(W_,367)+divmacro(sqr((1-DYNX(W_,367))*DYNX(DP_,57))*
  DYNX(W_,367),"((1-building.corGDouPan.rho_11_diff)*building.corGDouPan.Tai_diff)^2*building.corGDouPan.rho_11_diff",1
  -sqr(DYNX(W_,367)*DYNX(DP_,57)),"1-(building.corGDouPan.rho_11_diff*building.corGDouPan.Tai_diff)^2");
DYNX(W_,369) = 1-sqr(DYNX(W_,368));
DYNX(W_,370) = divmacro(sqr(DYNX(W_,365)),"building.corGDouPan.Ta1_diff^2",
  DYNX(W_,369),"building.corGDouPan.XN2_diff");
DYNX(W_,371) = 1-(DYNX(W_,365)+DYNX(W_,368));
DYNX(W_,372) = 0.04*DYNX(W_,371)*(1+divmacro(DYNX(W_,365)*DYNX(W_,368),
  "building.corGDouPan.Ta1_diff*building.corGDouPan.rho_1_diff",DYNX(W_,369),
  "building.corGDouPan.XN2_diff"))*DYNX(DP_,47);
DYNX(W_,373) = divmacro(DYNX(W_,371)*DYNX(W_,365)*(1-DYNX(DP_,47)/(double)(7.7)),
  "building.corGDouPan.a1_diff*building.corGDouPan.Ta1_diff*(1-building.corGDouPan.UWin/7.7)",
  DYNX(W_,369),"building.corGDouPan.XN2_diff");
DYNX(W_,374) = DYNX(W_,372)+DYNX(W_,373);
DYNX(W_,375) = divmacro(DYNX(W_,370)+DYNX(W_,374),"building.corGDouPan.Ta2_diff+building.corGDouPan.Qsek2_diff",
  DYNX(DP_,55),"building.corGDouPan.g_dir0");
DYNX(W_,376) = divmacro(DYNX(W_,370)+DYNX(W_,374),"building.corGDouPan.Ta2_diff+building.corGDouPan.Qsek2_diff",
  DYNX(DP_,55),"building.corGDouPan.g_dir0");
DYNX(W_,426) = DYNX(DP_,58);
DYNX(W_,427) = DYNX(DP_,59);
DYNX(W_,428) = DYNX(DP_,60);
DYNX(W_,443) = DYNX(W_,426);
DYNX(W_,444) = DYNX(W_,427);
DYNX(W_,438) = divmacro(DYNX(W_,443),"building.thermalZoneOneElement.volAir.state_start.p",
  287.0508037566665*DYNX(W_,444),"287.0508037566665*building.thermalZoneOneElement.volAir.state_start.T");
RealAssign (RealTemporaryDense( &DYNX(W_,457), 2, 2, 2), (PushModelContext(1,
  "Buildings.ThermalZones.ReducedOrder.RC.BaseClasses.splitFacVal(building.thermalZoneOneElement.dimension, building.thermalZoneOneElement.nOrientations, building.thermalZoneOneElement.AArray, building.thermalZoneOneElement.AExt, building.thermalZoneOneElement.AWin)")
  Buildings_ThermalZones_ReducedOrder_RC_BaseClasses_splitFacVal((Integer)(
  DYNX(W_,454)), (Integer)(DYNX(W_,409)), RealTemporaryDense( &DYNX(W_,452), 1, 2),
   RealTemporaryDense( &DYNX(W_,417), 1, 2), RealTemporaryDense( &DYNX(W_,411), 1,
   2))));
PopAllMarks();
DYNX(W_,464) = 11.5*DYNX(DP_,65);
DYNX(W_,468) = 14*DYNX(DP_,62);
DYNX(W_,469) = 6.37*DYNX(DP_,64);
DYNX(W_,470) = 6.37*DYNX(DP_,64);
DYNX(W_,471) = 0.63*DYNX(DP_,64);
DYNX(W_,472) = 0.63*DYNX(DP_,64);
DYNX(W_,475) = 11.5*DYNX(DP_,61);
DYNX(W_,516) = DYNX(DP_,198);
DYNX(W_,517) = DYNX(DP_,198);
DYNX(W_,518) = DYNX(DP_,198);
DYNX(W_,541) = DYNX(DP_,216);
DYNX(W_,553) = IF DYNX(DP_,219) THEN -1 ELSE 1;
DYNX(W_,543) = DYNX(W_,553)*DYNX(DP_,212);
DYNX(W_,544) =  -DYNX(W_,553);
DYNX(W_,558) = DYNX(W_,553);
DYNX(W_,559) =  -DYNX(W_,553);
DYNX(W_,565) = DYNX(DP_,207);
DYNX(W_,567) = divmacro(1,"1",DYNX(DP_,207)*DYNX(DP_,214),"building.conPIDMinT.k*building.conPIDMinT.Ni");
DYNX(W_,568) = DYNX(DP_,210);
DYNX(W_,569) = DYNX(DP_,211);
DYNX(W_,577) = DYNX(DP_,231);
DYNX(W_,589) = IF DYNX(DP_,234) THEN -1 ELSE 1;
DYNX(W_,579) = DYNX(W_,589)*DYNX(DP_,227);
DYNX(W_,580) =  -DYNX(W_,589);
DYNX(W_,594) = DYNX(W_,589);
DYNX(W_,595) =  -DYNX(W_,589);
DYNX(W_,601) = DYNX(DP_,222);
DYNX(W_,603) = divmacro(1,"1",DYNX(DP_,222)*DYNX(DP_,229),"building.conPIDMax.k*building.conPIDMax.Ni");
DYNX(W_,604) = DYNX(DP_,225);
DYNX(W_,605) = DYNX(DP_,226);
DYNX(W_,608) = DYNX(DP_,25);
DYNX(W_,609) =  -DYNX(DP_,27);
DYNX(W_,803) = DYNX(DP_,245);
DYNX(W_,804) = DYNX(DP_,246);
DYNX(W_,805) = DYNX(DP_,247);
DYNX(W_,833) = DYNX(DP_,250);
DYNX(W_,834) = DYNX(DP_,251);
DYNX(W_,835) = DYNX(DP_,252);
DYNX(W_,836) = DYNX(W_,623);
DYNX(W_,837) = DYNX(W_,624);
DYNX(W_,838) = DYNX(DP_,253);
BreakSectionFunctionEnd()
BreakSectionFunctionStart(3);
DYNX(W_,839) = DYNX(DP_,254);
DYNX(W_,840) = DYNX(DP_,255);
DYNX(W_,841) = DYNX(DP_,256);
DYNX(W_,844) = DYNX(DP_,257);
DYNX(W_,845) = DYNX(W_,627);
DYNX(W_,847) = DYNX(DP_,258);
DYNX(W_,860) = IF DYNX(W_,847) THEN -1 ELSE 1;
DYNX(W_,851) = DYNX(W_,860)*DYNX(W_,838);
DYNX(W_,852) =  -DYNX(W_,860);
DYNX(W_,864) = DYNX(W_,860);
DYNX(W_,865) =  -DYNX(W_,860);
DYNX(W_,871) = DYNX(W_,833);
DYNX(W_,873) = divmacro(1,"1",DYNX(W_,833)*DYNX(W_,840),"coo.con.k*coo.con.Ni");
DYNX(W_,874) = DYNX(W_,836);
DYNX(W_,875) = DYNX(W_,837);
DYNX(W_,888) = IF DYNX(DP_,270) < 1E-10 THEN 0 ELSE divmacro(1,"1",DYNX(DP_,270),
  "coo.senTDisSup.tauHeaTra");
DYNX(W_,889) = IF DYNX(W_,884) THEN divmacro(DYNX(DP_,270),"coo.senTDisSup.tauHeaTra",
  DYNX(W_,881),"coo.senTDisSup.tau") ELSE 1;
DYNX(W_,903) = IF DYNX(DP_,273) < 1E-10 THEN 0 ELSE divmacro(1,"1",DYNX(DP_,273),
  "coo.senTDisRet.tauHeaTra");
DYNX(W_,904) = IF DYNX(W_,899) THEN divmacro(DYNX(DP_,273),"coo.senTDisRet.tauHeaTra",
  DYNX(W_,896),"coo.senTDisRet.tau") ELSE 1;
DYNX(W_,923) = IF DYNX(DP_,278) < 1E-10 THEN 0 ELSE divmacro(1,"1",DYNX(DP_,278),
  "coo.TBuiRet.tauHeaTra");
DYNX(W_,924) = IF DYNX(W_,919) THEN divmacro(DYNX(DP_,278),"coo.TBuiRet.tauHeaTra",
  DYNX(W_,916),"coo.TBuiRet.tau") ELSE 1;
DYNX(W_,947) = DYNX(DP_,243);
DYNX(W_,936) = DYNX(W_,947)+DYNX(W_,969);
DYNX(W_,939) = 0.5*DYNX(DP_,281);
DYNX(W_,942) = fabs(DYNX(W_,936));
DYNX(W_,956) = divmacro(5,"5",6.283185307179586*DYNX(DP_,283),"6.283185307179586*coo.val.riseTime");
DYNX(W_,959) = DYNX(DP_,284);
DYNX(W_,971) = IF DYNX(W_,969) > 1E-15 THEN divmacro(0.5,"0.5",sqrtGuarded(
  DYNX(W_,969),"coo.val.dpFixed_nominal"),"sqrt(coo.val.dpFixed_nominal)") ELSE 0;
DYNX(W_,973) = divmacro(1,"1",DYNX(DP_,293),"coo.val.alp");
DYNX(W_,981) = DYNX(DP_,299);
DYNX(W_,982) = DYNX(W_,981)+DYNX(DP_,300);
DYNX(W_,983) = DYNX(W_,982)+DYNX(DP_,301);
DYNX(W_,999) = DYNX(DP_,2);
DYNX(W_,1000) = 0.0001*DYNX(W_,999);
DYNX(W_,1008) = IF DYNX(DP_,311) < 1E-10 THEN 0 ELSE divmacro(1,"1",
  DYNX(DP_,311),"TDisSup.tauHeaTra");
DYNX(W_,1009) = IF DYNX(W_,1004) THEN divmacro(DYNX(DP_,311),"TDisSup.tauHeaTra",
  DYNX(W_,1001),"TDisSup.tau") ELSE 1;
DYNX(W_,1015) = DYNX(DP_,2);
DYNX(W_,1016) = 0.0001*DYNX(W_,1015);
DYNX(W_,1024) = IF DYNX(DP_,314) < 1E-10 THEN 0 ELSE divmacro(1,"1",
  DYNX(DP_,314),"TDisRet.tauHeaTra");
DYNX(W_,1025) = IF DYNX(W_,1020) THEN divmacro(DYNX(DP_,314),"TDisRet.tauHeaTra",
  DYNX(W_,1017),"TDisRet.tau") ELSE 1;
DYNX(W_,1061) = DYNX(DP_,330);
DYNX(W_,1059) = divmacro(DYNX(W_,1061),"pumpBuiding.per.constantSpeed_rpm",
  DYNX(DP_,330),"pumpBuiding.per.speed_rpm_nominal");
DYNX(W_,1062) = DYNX(DP_,330);
DYNX(W_,1060) = divmacro(DYNX(W_,1062),"pumpBuiding.per.speeds_rpm[1]",
  DYNX(DP_,330),"pumpBuiding.per.speed_rpm_nominal");
DYNX(W_,1087) = DYNX(DP_,318);
DYNX(W_,1088) = DYNX(DP_,319);
DYNX(W_,1089) = 4184*(DYNX(W_,1088)-273.15);
DYNX(W_,1094) = DYNX(DP_,318);
DYNX(W_,1095) = DYNX(DP_,319);
DYNX(W_,1096) = DYNX(DP_,320);
DYNX(W_,1119) = DYNX(DP_,332);
DYNX(W_,1120) = divmacro(DYNX(W_,1101)*DYNX(W_,1119),"pumpBuiding.vol.m_flow_nominal*pumpBuiding.vol.tau",
  DYNX(W_,1113),"pumpBuiding.vol.rho_default");
DYNX(W_,1105) = DYNX(W_,1120);
DYNX(W_,1114) = DYNX(W_,1094);
DYNX(W_,1115) = DYNX(W_,1095);
DYNX(W_,1124) = divmacro(5,"5",6.283185307179586*DYNX(DP_,333),"6.283185307179586*pumpBuiding.riseTime");
DYNX(W_,1127) = DYNX(DP_,344);
DYNX(W_,1140) = DYNX(DP_,344);
DYNX(W_,1149) = DYNX(DP_,328);
DYNX(W_,1171) = DYNX(DP_,322);
DYNX(W_,1172) = DYNX(DP_,323);
DYNX(W_,1173) = DYNX(DP_,324);
DYNX(W_,1174) = DYNX(DP_,325);
DYNX(W_,1175) = DYNX(DP_,326);
DYNX(W_,1176) = DYNX(DP_,327);
DYNX(W_,1177) = DYNX(DP_,328);
DYNX(W_,1181) = DYNX(DP_,343);
DYNX(W_,1182) = DYNX(DP_,343);
DYNX(W_,1203) = divmacro(0.1*DYNX(W_,1201)*sqr(DYNX(W_,1202)),"0.1*(pumpBuiding.eff.dpMax*pumpBuiding.eff.delta^2)",
  DYNX(W_,1189),"pumpBuiding.eff.V_flow_max");
DYNX(W_,1209) = DYNX(W_,1169)+DYNX(W_,1167)*DYNX(W_,1203);
DYNX(DYNhelp,4) = DYNX(W_,1167)-DYNX(W_,1166);
DYNX(DYNhelp,5) = divmacro(1.0,"1.0",DYNX(DYNhelp,4),"pumpBuiding.eff.per.pressure.V_flow[2]-pumpBuiding.eff.per.pressure.V_flow[1]");
DYNX(W_,1236) = (PushModelContext(1,"Modelica.Math.BooleanVectors.allTrue({(pumpBuiding.eff.per.pressure.dp[2]-pumpBuiding.eff.per.pressure.dp[1])/(pumpBuiding.eff.per.pressure.V_flow[2]-pumpBuiding.eff.per.pressure.V_flow[1]) <  -pumpBuiding.eff.kRes})")
  Modelica_Math_BooleanVectors_allTrue(IntegerScalarArray ( 1, (int )(
  DYNX(DYNhelp,5)*(DYNX(W_,1169)-DYNX(W_,1168)) <  -DYNX(W_,1203)))));
PopAllMarks();
DYNX(W_,1247) = DYNX(DP_,345);
DYNX(W_,1248) = DYNX(DP_,346);
DYNX(W_,1270) = DYNX(DP_,351);
DYNX(W_,1271) = DYNX(DP_,352);
DYNX(W_,1272) = DYNX(DP_,353);
DYNX(W_,1281) = divmacro(0.5*DYNX(DP_,350),"0.5*CoolingUnit.tau",DYNX(W_,1310),
  "CoolingUnit.rho_default");
DYNX(W_,1287) = DYNX(W_,1270);
DYNX(W_,1288) = DYNX(W_,1271);
DYNX(W_,1311) = DYNX(DP_,351);
DYNX(W_,1312) = DYNX(DP_,352);
DYNX(W_,1313) = 4184*(DYNX(W_,1312)-273.15);
DYNX(W_,1317) =  -divmacro(1,"1",DYNX(DP_,3)*9,"cp*9");
DYNX(W_,1328) = DYNX(DP_,386);
DYNX(W_,1336) = DYNX(DP_,26);
DYNX(W_,1337) = DYNX(DP_,26);
DYNX(W_,1340) =  -divmacro(DYNX(W_,1336),"building.heaLoaO[1].Q_flowHea_nominal",
  DYNX(DP_,388)-DYNX(W_,1335),"building.heaLoaO[1].TOutHea_nominal-building.heaLoaO[1].TIndHea_nominal");
DYNX(W_,1353) = DYNX(W_,426);
DYNX(W_,1354) = DYNX(W_,427);
DYNX(W_,1355) = DYNX(W_,428);
DYNX(W_,1378) = divmacro(DYNX(W_,1353),"building.thermalZoneOneElement.volAir.dynBal.p_start",
  287.0508037566665*DYNX(W_,1354),"287.0508037566665*building.thermalZoneOneElement.volAir.dynBal.T_start");
DYNX(W_,1383) = 1005.45*(DYNX(W_,1354)-298.15);
DYNX(W_,1387) = DYNX(DP_,63);
DYNX(W_,1399) = DYNX(W_,457);
DYNX(W_,1400) = DYNX(W_,458);
DYNX(W_,1401) = DYNX(W_,459);
DYNX(W_,1402) = DYNX(W_,460);
DYNX(W_,1410) = DYNX(DP_,66);
DYNX(W_,1411) = DYNX(DP_,67);
DYNX(W_,1412) = DYNX(DP_,68);
DYNX(W_,1413) = DYNX(DP_,59);
DYNX(W_,1415) = DYNX(W_,1412);
DYNX(W_,1419) = DYNX(W_,1410);
DYNX(W_,1421) = DYNX(W_,1411);
DYNX(W_,1422) = divmacro(1,"1",DYNX(DP_,208),"building.conPIDMinT.Ti");
DYNX(W_,1424) = DYNX(DP_,216);
DYNX(W_,1426) = DYNX(W_,541);
DYNX(W_,1428) = divmacro(1,"1",DYNX(DP_,223),"building.conPIDMax.Ti");
DYNX(W_,1430) = DYNX(DP_,231);
DYNX(W_,1432) = DYNX(W_,577);
DYNX(W_,1435) = DYNX(W_,860)*DYNX(W_,839);
DYNX(W_,1436) =  -DYNX(W_,860);
DYNX(W_,1437) = divmacro(1,"1",DYNX(W_,834),"coo.con.Ti");
DYNX(W_,1444) = DYNX(W_,835);
DYNX(DYNhelp,6) = divmacro(1.0,"1.0",DYNX(W_,841),"coo.con.Nd");
DYNX(W_,1445) = RealBmax(DYNX(DYNhelp,6)*DYNX(W_,835), 1E-14);
DYNX(W_,1447) = DYNX(W_,844);
DYNX(DYNhelp,7) = fabs(DYNX(W_,1444));
DYNX(W_,1448) = DYNX(DYNhelp,7) < 1E-15;
DYNX(W_,1480) = DYNX(W_,1270);
DYNX(W_,1481) = DYNX(W_,1271);
DYNX(W_,1482) = DYNX(W_,1272);
DYNX(W_,1502) = DYNX(W_,1281);
DYNX(W_,1512) = 4184*(DYNX(W_,1481)-273.15);
BoundParameterConstantSection
DYNX(W_,1014) = 4184*(DYNX(DP_,317)-273.15);
DYNX(W_,640) = 273.15+0.0002390057361376673*DYNX(W_,1014);
DYNX(W_,1498) = 995.586*DYNX(W_,1502);
DYNX(Aux_,4) = DYNX(W_,1014);
DYNX(W_,907) = 273.15+0.0002390057361376673*DYNX(W_,1014);
DYNX(W_,1028) = 273.15+0.0002390057361376673*DYNX(W_,1014);
DYNX(W_,526) = 273.15+DYNX(DP_,205);
DYNX(W_,531) = 273.15+DYNX(DP_,206);
DYNX(Aux_,3) = DYNX(W_,1014);
DYNX(Aux_,11) = DYNX(W_,1014);
InitialBoundSection
{
  struct DymStruc0 dummy_DymStruc0;
  dummy_DymStruc0 = (PushModelContext(1,"Modelica.Blocks.Types.ExternalCombiTimeTable(\"NoName\", \"NoName\", QCoo.table, 0.0002777777777777778*QCoo.startTime, QCoo.columns, Modelica.Blocks.Types.Smoothness.LinearSegments, QCoo.extrapolation, 0, 1)")
    Modelica_Blocks_Types_ExternalCombiTimeTable_M("NoName", "NoName", 
    RealTemporaryDense( &DYNX(DP_,362), 2, 11, 2), 0.0002777777777777778*
    DYNX(DP_,387), IntegerTemporaryDense( &DYNX(W_,1321), 1, 1), 1, (Integer)(
    DYNX(DP_,385)), 0, 1));
  DYNX(W_,1329) = dummy_DymStruc0.id_0member;
PopAllMarks();
}
{
  struct DymStruc0 dummy_DymStruc0;
  dummy_DymStruc0 = (PushModelContext(1,"Modelica.Blocks.Types.ExternalCombiTimeTable(\"NoName\", \"NoName\", building.intGai.table, building.intGai.startTime, building.intGai.columns, Modelica.Blocks.Types.Smoothness.LinearSegments, building.intGai.extrapolation, 1, 1)")
    Modelica_Blocks_Types_ExternalCombiTimeTable_M("NoName", "NoName", 
    RealTemporaryDense( &DYNX(DP_,89), 2, 26, 4), DYNX(DP_,199), 
    IntegerTemporaryDense( &DYNX(DP_,194), 1, 3), 1, (Integer)(DYNX(DP_,197)), 1,
     1));
  DYNX(W_,519) = dummy_DymStruc0.id_0member;
PopAllMarks();
}
{
  struct DymStruc0 dummy_DymStruc0;
  dummy_DymStruc0 = (PushModelContext(1,"Modelica.Blocks.Types.ExternalCombiTable1D(\"tab1\", \"C:/Users/YLI3/Yanfei_Projects/modelica-buildings-yanfei/Buildings/Resources/weatherdata/USA_CA_San.Francisco.Intl.AP.724940_TMY3.mos\", weaDat.datRea.table, weaDat.datRea.columns, Modelica.Blocks.Types.Smoothness.ContinuousDerivative, 2, 0)")
    Modelica_Blocks_Types_ExternalCombiTable1D_M("tab1", "C:/Users/YLI3/Yanfei_Projects/modelica-buildings-yanfei/Buildings/Resources/weatherdata/USA_CA_San.Francisco.Intl.AP.724940_TMY3.mos",
     RealTemporaryDense( (Real*)(0), 2, 0, 2), IntegerTemporaryDense( 
    &DYNX(W_,47), 1, 26), 2, 2, 0));
  DYNX(W_,74) = dummy_DymStruc0.id_0member;
PopAllMarks();
}
BoundParameterConstantSection
DYNX(W_,336) = cos(DYNX(W_,329));
DYNX(W_,337) = sin(DYNX(W_,329));
InitialBoundSection
{
  struct DymStruc0 dummy_DymStruc0;
  dummy_DymStruc0 = (PushModelContext(1,"Modelica.Blocks.Types.ExternalCombiTable1D(\"tab1\", \"C:/Users/YLI3/Yanfei_Projects/modelica-buildings-yanfei/Buildings/Resources/weatherdata/USA_CA_San.Francisco.Intl.AP.724940_TMY3.mos\", weaDat.datRea1.table, weaDat.datRea1.columns, Modelica.Blocks.Types.Smoothness.ContinuousDerivative, 3, 0)")
    Modelica_Blocks_Types_ExternalCombiTable1D_M("tab1", "C:/Users/YLI3/Yanfei_Projects/modelica-buildings-yanfei/Buildings/Resources/weatherdata/USA_CA_San.Francisco.Intl.AP.724940_TMY3.mos",
     RealTemporaryDense( (Real*)(0), 2, 0, 2), IntegerTemporaryDense( 
    &DYNX(W_,118), 1, 3), 2, 3, 0));
  DYNX(W_,122) = dummy_DymStruc0.id_0member;
PopAllMarks();
}
BoundParameterConstantSection
DYNX(W_,262) = cos(DYNX(W_,255));
DYNX(W_,263) = sin(DYNX(W_,255));
DYNX(W_,352) = cos(DYNX(W_,345));
DYNX(W_,353) = sin(DYNX(W_,345));
DYNX(W_,320) = cos(DYNX(W_,313));
DYNX(W_,321) = sin(DYNX(W_,313));
DYNX(W_,1032) = DYNX(DP_,315);
DYNX(W_,990) = DYNX(DP_,306);
BoundParameterSection
InitialSection
#if defined(DynSimStruct) || defined(BUILDFMU)
DYNX(W_,129) = 0;
DYNX(W_,135) = 0;
DYNX(W_,462) = 0;
DYNX(W_,463) = 288.15;
DYNX(W_,467) = 288.15;
DYNX(W_,484) = 288.15;
DYNX(W_,485) = 288.15;
DYNX(W_,486) = 288.15;
DYNX(W_,487) = 288.15;
DYNX(W_,494) = 288.15;
DYNX(W_,495) = 288.15;
DYNX(W_,499) = 288.15;
DYNX(W_,501) = 288.15;
DYNX(W_,503) = 288.15;
DYNX(W_,520) = 0;
DYNX(W_,521) = 0;
DYNX(W_,612) = 0;
DYNX(W_,613) = 83680.0;
DYNX(W_,614) = 83680.0;
DYNX(W_,615) = 0;
DYNX(W_,617) = 83680.0;
DYNX(W_,618) = 83680.0;
DYNX(W_,631) = 300000;
DYNX(W_,639) = 293.15;
DYNX(W_,641) = 293.15;
DYNX(W_,642) = 293.15;
DYNX(W_,665) = 0;
DYNX(W_,708) = 0;
DYNX(W_,723) = 83680.0;
DYNX(W_,729) = 0;
DYNX(W_,771) = 0;
DYNX(W_,786) = 83680.0;
DYNX(W_,788) = 293.15;
DYNX(W_,789) = 293.15;
DYNX(W_,883) = 1;
DYNX(W_,891) = 293.15;
DYNX(W_,892) = 293.15;
DYNX(W_,898) = 1;
DYNX(W_,906) = 293.15;
DYNX(W_,918) = 1;
DYNX(W_,926) = 293.15;
DYNX(W_,927) = 293.15;
DYNX(W_,932) = 0;
DYNX(W_,988) = 83680.0;
DYNX(W_,1003) = 1;
DYNX(W_,1011) = 293.15;
DYNX(W_,1012) = 293.15;
DYNX(W_,1019) = 1;
DYNX(W_,1027) = 293.15;
DYNX(W_,1052) = 0;
DYNX(W_,1075) = 0;
DYNX(W_,1107) = 83680.0;
DYNX(W_,1196) = 0.0005022167848884978;
DYNX(W_,1246) = 83680.0;
DYNX(W_,1255) = 0;
DYNX(W_,1295) = 0;
DYNX(W_,1330) = 0;
DYNX(W_,1331) = 0;
DYNX(W_,1403) = 288.15;
DYNX(W_,1405) = 288.15;
DYNX(W_,1416) = 0;
#endif
DYNX(Aux_,0) = 83680.0;
DYNX(Aux_,1) = 83680.0;
DYNX(Aux_,2) = 83680.0;
DYNX(Aux_,5) = 83680.0;
DYNX(Aux_,6) = 83680.0;
DYNX(Aux_,7) = 83680.0;
DYNX(Aux_,8) = 83680.0;
DYNX(Aux_,9) = 83680.0;
DYNX(Aux_,10) = 83680.0;
DYNX(Aux_,12) = 83680.0;
DYNX(Aux_,15) = 83680.0;
DYNX(Aux_,16) = 83680.0;
DYNX(Aux_,17) = 83680.0;
DYNX(Aux_,22) = 83680.0;
DYNX(Aux_,23) = 83680.0;
DYNX(Aux_,24) = 83680.0;
DYNX(Aux_,0) = 83680.0;
DYNX(Aux_,1) = 83680.0;
DYNX(Aux_,2) = 83680.0;
DYNX(Aux_,5) = 83680.0;
DYNX(Aux_,6) = 83680.0;
DYNX(Aux_,7) = 83680.0;
DYNX(Aux_,8) = 83680.0;
DYNX(Aux_,9) = 83680.0;
DYNX(Aux_,10) = 83680.0;
DYNX(Aux_,12) = 83680.0;
DYNX(Aux_,15) = 83680.0;
DYNX(Aux_,16) = 83680.0;
DYNX(Aux_,17) = 83680.0;
DYNX(Aux_,22) = 83680.0;
DYNX(Aux_,23) = 83680.0;
DYNX(Aux_,24) = 83680.0;
#if defined(DynSimStruct) || defined(BUILDFMU)
DYNX(F_,15) = 0;
#endif
InitialSection
InitialStartSection
InitialStartSection2
DYNX(W_,188) = DYNX(W_,427);
DYNX(W_,446) = DYNX(W_,1383);
DYNX(W_,616) = DYNX(W_,1480);
DYNX(W_,825) = DYNX(W_,824);
DYNX(W_,890) = DYNX(DP_,268);
DYNX(W_,905) = DYNX(DP_,271);
DYNX(W_,925) = DYNX(DP_,276);
DYNX(W_,1010) = DYNX(DP_,309);
DYNX(W_,1026) = DYNX(DP_,312);
DYNX(W_,1047) = DYNX(DP_,318);
DYNX(W_,1048) = DYNX(W_,1089);
DYNX(W_,1073) = DYNX(W_,1095);
DYNX(W_,1076) =  -DYNX(DP_,341);
DYNX(W_,1251) = DYNX(W_,1313);
DYNX(W_,1282) = DYNX(W_,1271);
DYNX(W_,1362) = DYNX(W_,1353);
DYNX(W_,1363) = DYNX(W_,1378);
DYNX(W_,1364) = DYNX(W_,1354);
DYNX(W_,1489) = DYNX(W_,1481);
InitialStartSection
DYNX(Aux_,13) = DYNX(W_,1089);
DYNX(Aux_,13) = DYNX(W_,1089);
InitialStartSection2
DYNX(X_,0) = DYNX(DP_,268);
DYNX(X_,1) = DYNX(DP_,271);
DYNX(X_,2) = DYNX(DP_,275);
DYNX(X_,3) = DYNX(DP_,276);
DYNX(X_,6) = DYNX(DP_,309);
DYNX(X_,7) = DYNX(DP_,312);
DYNX(X_,13) = 52.5*DYNX(W_,1378)*(1005.45*(DYNX(W_,1354)-298.15)-
  287.0508037566665*DYNX(W_,1354));
DYNX(X_,14) = 52.5*DYNX(W_,438);
DYNX(X_,15) = DYNX(W_,1413);
DYNX(X_,19) = DYNX(W_,1447);
DYNX(X_,20) = 4165531.824*DYNX(W_,1502)*(DYNX(W_,1481)-273.15);
InitialSection
if (!DymolaUserHomotopy) UpdateInitVars(time, X_, XD_, U_, DP_, IP_, LP_, F_, Y_, W_, QZ_, duser_, iuser_, cuser_, did_, 1);
DefaultSection
InitializeData(0)
InitialBoundSection
DYNX(Aux_,33) = DYNX(W_,1331);
DYNX(Aux_,32) = DYNX(W_,1330);
DYNX(Aux_,35) = DYNX(W_,521);
DYNX(Aux_,34) = DYNX(W_,520);
DYNX(Aux_,36) = DYNX(W_,984);
DYNX(Aux_,37) = DYNX(W_,985);
DYNX(Aux_,38) = DYNX(W_,135);
DYNX(Aux_,39) = DYNX(W_,129);
InitialSection
InitialSection2
DYNX(F_,8) = 0.0;
DYNX(W_,872) = 0.0;
DYNX(F_,19) = 0;
DYNX(F_,4) = 0.0;
DYNX(F_,14) = 0.0;
DYNX(X_,12) = 293.15;
RealAssign (RealTemporaryDense( &DYNX(W_,19), 1, 2), (PushModelContext(1,
  "Buildings.BoundaryConditions.WeatherData.BaseClasses.getTimeSpanTMY3(weaDat.filNam, \"tab1\")")
  Buildings_BoundaryConditions_WeatherData_BaseClasses_getTimeSpanTMY3_M(
  "C:/Users/YLI3/Yanfei_Projects/modelica-buildings-yanfei/Buildings/Resources/weatherdata/USA_CA_San.Francisco.Intl.AP.724940_TMY3.mos",
   "tab1")));
PopAllMarks();
DYNX(W_,124) = DYNX(W_,19);
DYNX(W_,125) = DYNX(W_,20);
DYNX(W_,127) = DYNX(W_,125)-DYNX(W_,124);
DYNX(W_,130) = DYNX(W_,19);
DYNX(W_,131) = DYNX(W_,20);
DYNX(W_,133) = DYNX(W_,131)-DYNX(W_,130);
DYNX(W_,209) = DYNX(DP_,30);
DYNX(W_,210) = DYNX(DP_,29);
DYNX(W_,248) = DYNX(DP_,31);
DYNX(W_,249) = DYNX(DP_,32);
DYNX(W_,250) = DYNX(DP_,29);
DYNX(W_,255) = DYNX(W_,248);
DYNX(W_,256) = DYNX(W_,249);
DYNX(W_,257) = DYNX(W_,250);
DYNX(W_,267) = DYNX(DP_,36);
DYNX(W_,268) = DYNX(DP_,35);
DYNX(W_,306) = DYNX(DP_,37);
DYNX(W_,307) = DYNX(DP_,38);
DYNX(W_,308) = DYNX(DP_,35);
DYNX(W_,313) = DYNX(W_,306);
DYNX(W_,314) = DYNX(W_,307);
DYNX(W_,315) = DYNX(W_,308);
DYNX(W_,322) = DYNX(DP_,42);
DYNX(W_,323) = DYNX(DP_,43);
DYNX(W_,324) = DYNX(DP_,41);
DYNX(W_,329) = DYNX(W_,322);
DYNX(W_,330) = DYNX(W_,323);
DYNX(W_,331) = DYNX(W_,324);
DYNX(W_,338) = DYNX(DP_,45);
DYNX(W_,339) = DYNX(DP_,46);
DYNX(W_,340) = DYNX(DP_,44);
DYNX(W_,345) = DYNX(W_,338);
DYNX(W_,346) = DYNX(W_,339);
DYNX(W_,347) = DYNX(W_,340);
DYNX(W_,365) = DYNX(DP_,56)*DYNX(DP_,57);
DYNX(W_,366) = 1-DYNX(DP_,56);
DYNX(W_,367) = divmacro(DYNX(W_,366),"building.corGDouPan.rho_T1_diff",2-
  DYNX(W_,366),"2-building.corGDouPan.rho_T1_diff");
DYNX(W_,368) = DYNX(W_,367)+divmacro(sqr((1-DYNX(W_,367))*DYNX(DP_,57))*
  DYNX(W_,367),"((1-building.corGDouPan.rho_11_diff)*building.corGDouPan.Tai_diff)^2*building.corGDouPan.rho_11_diff",1
  -sqr(DYNX(W_,367)*DYNX(DP_,57)),"1-(building.corGDouPan.rho_11_diff*building.corGDouPan.Tai_diff)^2");
DYNX(W_,369) = 1-sqr(DYNX(W_,368));
DYNX(W_,370) = divmacro(sqr(DYNX(W_,365)),"building.corGDouPan.Ta1_diff^2",
  DYNX(W_,369),"building.corGDouPan.XN2_diff");
DYNX(W_,371) = 1-(DYNX(W_,365)+DYNX(W_,368));
DYNX(W_,372) = 0.04*DYNX(W_,371)*(1+divmacro(DYNX(W_,365)*DYNX(W_,368),
  "building.corGDouPan.Ta1_diff*building.corGDouPan.rho_1_diff",DYNX(W_,369),
  "building.corGDouPan.XN2_diff"))*DYNX(DP_,47);
DYNX(W_,373) = divmacro(DYNX(W_,371)*DYNX(W_,365)*(1-DYNX(DP_,47)/(double)(7.7)),
  "building.corGDouPan.a1_diff*building.corGDouPan.Ta1_diff*(1-building.corGDouPan.UWin/7.7)",
  DYNX(W_,369),"building.corGDouPan.XN2_diff");
DYNX(W_,374) = DYNX(W_,372)+DYNX(W_,373);
DYNX(W_,375) = divmacro(DYNX(W_,370)+DYNX(W_,374),"building.corGDouPan.Ta2_diff+building.corGDouPan.Qsek2_diff",
  DYNX(DP_,55),"building.corGDouPan.g_dir0");
DYNX(W_,376) = divmacro(DYNX(W_,370)+DYNX(W_,374),"building.corGDouPan.Ta2_diff+building.corGDouPan.Qsek2_diff",
  DYNX(DP_,55),"building.corGDouPan.g_dir0");
DYNX(W_,426) = DYNX(DP_,58);
DYNX(W_,427) = DYNX(DP_,59);
DYNX(W_,428) = DYNX(DP_,60);
DYNX(W_,443) = DYNX(W_,426);
DYNX(W_,444) = DYNX(W_,427);
DYNX(W_,438) = divmacro(DYNX(W_,443),"building.thermalZoneOneElement.volAir.state_start.p",
  287.0508037566665*DYNX(W_,444),"287.0508037566665*building.thermalZoneOneElement.volAir.state_start.T");
RealAssign (RealTemporaryDense( &DYNX(W_,457), 2, 2, 2), (PushModelContext(1,
  "Buildings.ThermalZones.ReducedOrder.RC.BaseClasses.splitFacVal(building.thermalZoneOneElement.dimension, building.thermalZoneOneElement.nOrientations, building.thermalZoneOneElement.AArray, building.thermalZoneOneElement.AExt, building.thermalZoneOneElement.AWin)")
  Buildings_ThermalZones_ReducedOrder_RC_BaseClasses_splitFacVal((Integer)(
  DYNX(W_,454)), (Integer)(DYNX(W_,409)), RealTemporaryDense( &DYNX(W_,452), 1, 2),
   RealTemporaryDense( &DYNX(W_,417), 1, 2), RealTemporaryDense( &DYNX(W_,411), 1,
   2))));
PopAllMarks();
DYNX(W_,464) = 11.5*DYNX(DP_,65);
DYNX(W_,468) = 14*DYNX(DP_,62);
DYNX(W_,469) = 6.37*DYNX(DP_,64);
DYNX(W_,470) = 6.37*DYNX(DP_,64);
DYNX(W_,471) = 0.63*DYNX(DP_,64);
DYNX(W_,472) = 0.63*DYNX(DP_,64);
DYNX(W_,475) = 11.5*DYNX(DP_,61);
DYNX(W_,516) = DYNX(DP_,198);
DYNX(W_,517) = DYNX(DP_,198);
DYNX(W_,518) = DYNX(DP_,198);
DYNX(W_,541) = DYNX(DP_,216);
DYNX(W_,553) = IF DYNX(DP_,219) THEN -1 ELSE 1;
DYNX(W_,543) = DYNX(W_,553)*DYNX(DP_,212);
DYNX(W_,544) =  -DYNX(W_,553);
DYNX(W_,558) = DYNX(W_,553);
DYNX(W_,559) =  -DYNX(W_,553);
DYNX(W_,565) = DYNX(DP_,207);
DYNX(W_,567) = divmacro(1,"1",DYNX(DP_,207)*DYNX(DP_,214),"building.conPIDMinT.k*building.conPIDMinT.Ni");
DYNX(W_,568) = DYNX(DP_,210);
DYNX(W_,569) = DYNX(DP_,211);
AssertModelica(DYNX(W_,568) >= DYNX(W_,569),"building.conPIDMinT.limiter.uMax >= building.conPIDMinT.limiter.uMin",
   StringAdd(StringAdd(StringAdd(StringAdd("Limiter: Limits must be consistent. However, uMax (=",
  Real2String2(DYNX(W_,568), true, 0)),") < uMin (="),Real2String2(DYNX(W_,569),
   true, 0)),")"));
PopAllMarks();
DYNX(W_,577) = DYNX(DP_,231);
DYNX(W_,589) = IF DYNX(DP_,234) THEN -1 ELSE 1;
DYNX(W_,579) = DYNX(W_,589)*DYNX(DP_,227);
DYNX(W_,580) =  -DYNX(W_,589);
DYNX(W_,594) = DYNX(W_,589);
DYNX(W_,595) =  -DYNX(W_,589);
DYNX(W_,601) = DYNX(DP_,222);
DYNX(W_,603) = divmacro(1,"1",DYNX(DP_,222)*DYNX(DP_,229),"building.conPIDMax.k*building.conPIDMax.Ni");
DYNX(W_,604) = DYNX(DP_,225);
DYNX(W_,605) = DYNX(DP_,226);
AssertModelica(DYNX(W_,604) >= DYNX(W_,605),"building.conPIDMax.limiter.uMax >= building.conPIDMax.limiter.uMin",
   StringAdd(StringAdd(StringAdd(StringAdd("Limiter: Limits must be consistent. However, uMax (=",
  Real2String2(DYNX(W_,604), true, 0)),") < uMin (="),Real2String2(DYNX(W_,605),
   true, 0)),")"));
PopAllMarks();
DYNX(W_,608) = DYNX(DP_,25);
DYNX(W_,609) =  -DYNX(DP_,27);
BreakSectionFunctionEnd()
BreakSectionFunctionStart(4);
DYNX(W_,803) = DYNX(DP_,245);
DYNX(W_,804) = DYNX(DP_,246);
DYNX(W_,805) = DYNX(DP_,247);
DYNX(W_,819) = RealBmin(2092.0, 2092.0);
DYNX(W_,806) = fabs(divmacro(DYNX(W_,803),"coo.hex.Q_flow_nominal",(DYNX(W_,804)
  -DYNX(W_,805))*DYNX(W_,819),"(coo.hex.T_a1_nominal-coo.hex.T_a2_nominal)*coo.hex.CMin_flow_nominal"));
DYNX(W_,820) = RealBmax(2092.0, 2092.0);
AssertModelica(DYNX(W_,806) > 0 AND DYNX(W_,806) < 1,"coo.hex.eps_nominal > 0 and coo.hex.eps_nominal < 1",
   StringAdd(StringAdd(StringAdd(StringAdd(StringAdd(StringAdd(StringAdd(
  StringAdd("eps_nominal out of bounds, eps_nominal = ",Real2String2(
  DYNX(W_,806), true, 0)),"\n  To achieve the required heat transfer rate at epsilon=0.8, set |T_a1_nominal-T_a2_nominal| = "),
  Real2String2(fabs(1.25*DYNX(W_,803)*DYNX(W_,819)), true, 0)),"\n  or increase flow rates. The current parameters result in "),
  "\n  CMin_flow_nominal = "),Real2String2(DYNX(W_,819), true, 0)),
  "\n  CMax_flow_nominal = "),Real2String2(DYNX(W_,820), true, 0)));
PopAllMarks();
DYNX(W_,821) = divmacro(DYNX(W_,819),"coo.hex.CMin_flow_nominal",DYNX(W_,820),
  "coo.hex.CMax_flow_nominal");
DYNX(W_,810) = IF DYNX(W_,806) > 0 AND DYNX(W_,806) < 1 THEN (PushModelContext(1,
  "Buildings.Fluid.HeatExchangers.BaseClasses.ntu_epsilonZ(coo.hex.eps_nominal, coo.hex.Z_nominal, 2)")
  Buildings_Fluid_HeatExchangers_BaseClasses_ntux_0epsilonZ(DYNX(W_,806), 
  DYNX(W_,821), 2)) ELSE 0;
PopModelContext();
DYNX(W_,809) = DYNX(W_,810)*DYNX(W_,819);
DYNX(W_,826) = 2*DYNX(W_,809);
DYNX(W_,827) = 2*DYNX(W_,809);
DYNX(W_,833) = DYNX(DP_,250);
DYNX(W_,834) = DYNX(DP_,251);
DYNX(W_,835) = DYNX(DP_,252);
DYNX(W_,836) = DYNX(W_,623);
DYNX(W_,837) = DYNX(W_,624);
DYNX(W_,838) = DYNX(DP_,253);
DYNX(W_,839) = DYNX(DP_,254);
DYNX(W_,840) = DYNX(DP_,255);
DYNX(W_,841) = DYNX(DP_,256);
DYNX(W_,844) = DYNX(DP_,257);
DYNX(W_,845) = DYNX(W_,627);
DYNX(W_,847) = DYNX(DP_,258);
DYNX(W_,860) = IF DYNX(W_,847) THEN -1 ELSE 1;
DYNX(W_,851) = DYNX(W_,860)*DYNX(W_,838);
DYNX(W_,852) =  -DYNX(W_,860);
DYNX(W_,864) = DYNX(W_,860);
DYNX(W_,865) =  -DYNX(W_,860);
DYNX(W_,871) = DYNX(W_,833);
DYNX(W_,873) = divmacro(1,"1",DYNX(W_,833)*DYNX(W_,840),"coo.con.k*coo.con.Ni");
DYNX(W_,874) = DYNX(W_,836);
DYNX(W_,875) = DYNX(W_,837);
AssertModelica(DYNX(W_,874) >= DYNX(W_,875),"coo.con.limiter.uMax >= coo.con.limiter.uMin",
   StringAdd(StringAdd(StringAdd(StringAdd("Limiter: Limits must be consistent. However, uMax (=",
  Real2String2(DYNX(W_,874), true, 0)),") < uMin (="),Real2String2(DYNX(W_,875),
   true, 0)),")"));
PopAllMarks();
DYNX(W_,888) = IF DYNX(DP_,270) < 1E-10 THEN 0 ELSE divmacro(1,"1",DYNX(DP_,270),
  "coo.senTDisSup.tauHeaTra");
DYNX(W_,889) = IF DYNX(W_,884) THEN divmacro(DYNX(DP_,270),"coo.senTDisSup.tauHeaTra",
  DYNX(W_,881),"coo.senTDisSup.tau") ELSE 1;
DYNX(W_,903) = IF DYNX(DP_,273) < 1E-10 THEN 0 ELSE divmacro(1,"1",DYNX(DP_,273),
  "coo.senTDisRet.tauHeaTra");
DYNX(W_,904) = IF DYNX(W_,899) THEN divmacro(DYNX(DP_,273),"coo.senTDisRet.tauHeaTra",
  DYNX(W_,896),"coo.senTDisRet.tau") ELSE 1;
DYNX(W_,923) = IF DYNX(DP_,278) < 1E-10 THEN 0 ELSE divmacro(1,"1",DYNX(DP_,278),
  "coo.TBuiRet.tauHeaTra");
DYNX(W_,924) = IF DYNX(W_,919) THEN divmacro(DYNX(DP_,278),"coo.TBuiRet.tauHeaTra",
  DYNX(W_,916),"coo.TBuiRet.tau") ELSE 1;
DYNX(W_,947) = DYNX(DP_,243);
DYNX(W_,936) = DYNX(W_,947)+DYNX(W_,969);
DYNX(W_,939) = 0.5*DYNX(DP_,281);
DYNX(W_,942) = fabs(DYNX(W_,936));
DYNX(W_,956) = divmacro(5,"5",6.283185307179586*DYNX(DP_,283),"6.283185307179586*coo.val.riseTime");
AssertModelica(DYNX(W_,956) > 0,"coo.val.filter.f_cut > 0", "f_cut > 0 required");
DYNX(W_,959) = DYNX(DP_,284);
DYNX(W_,971) = IF DYNX(W_,969) > 1E-15 THEN divmacro(0.5,"0.5",sqrtGuarded(
  DYNX(W_,969),"coo.val.dpFixed_nominal"),"sqrt(coo.val.dpFixed_nominal)") ELSE 0;
DYNX(W_,973) = divmacro(1,"1",DYNX(DP_,293),"coo.val.alp");
DYNX(W_,981) = DYNX(DP_,299);
DYNX(W_,982) = DYNX(W_,981)+DYNX(DP_,300);
DYNX(W_,983) = DYNX(W_,982)+DYNX(DP_,301);
DYNX(W_,999) = DYNX(DP_,2);
DYNX(W_,1000) = 0.0001*DYNX(W_,999);
DYNX(W_,1008) = IF DYNX(DP_,311) < 1E-10 THEN 0 ELSE divmacro(1,"1",
  DYNX(DP_,311),"TDisSup.tauHeaTra");
DYNX(W_,1009) = IF DYNX(W_,1004) THEN divmacro(DYNX(DP_,311),"TDisSup.tauHeaTra",
  DYNX(W_,1001),"TDisSup.tau") ELSE 1;
DYNX(W_,1015) = DYNX(DP_,2);
DYNX(W_,1016) = 0.0001*DYNX(W_,1015);
DYNX(W_,1024) = IF DYNX(DP_,314) < 1E-10 THEN 0 ELSE divmacro(1,"1",
  DYNX(DP_,314),"TDisRet.tauHeaTra");
DYNX(W_,1025) = IF DYNX(W_,1020) THEN divmacro(DYNX(DP_,314),"TDisRet.tauHeaTra",
  DYNX(W_,1017),"TDisRet.tau") ELSE 1;
DYNX(W_,1061) = DYNX(DP_,330);
DYNX(W_,1059) = divmacro(DYNX(W_,1061),"pumpBuiding.per.constantSpeed_rpm",
  DYNX(DP_,330),"pumpBuiding.per.speed_rpm_nominal");
DYNX(W_,1062) = DYNX(DP_,330);
DYNX(W_,1060) = divmacro(DYNX(W_,1062),"pumpBuiding.per.speeds_rpm[1]",
  DYNX(DP_,330),"pumpBuiding.per.speed_rpm_nominal");
DYNX(W_,1087) = DYNX(DP_,318);
DYNX(W_,1088) = DYNX(DP_,319);
DYNX(W_,1089) = 4184*(DYNX(W_,1088)-273.15);
DYNX(W_,1094) = DYNX(DP_,318);
DYNX(W_,1095) = DYNX(DP_,319);
DYNX(W_,1096) = DYNX(DP_,320);
DYNX(W_,1119) = DYNX(DP_,332);
DYNX(W_,1120) = divmacro(DYNX(W_,1101)*DYNX(W_,1119),"pumpBuiding.vol.m_flow_nominal*pumpBuiding.vol.tau",
  DYNX(W_,1113),"pumpBuiding.vol.rho_default");
DYNX(W_,1105) = DYNX(W_,1120);
DYNX(W_,1114) = DYNX(W_,1094);
DYNX(W_,1115) = DYNX(W_,1095);
DYNX(W_,1124) = divmacro(5,"5",6.283185307179586*DYNX(DP_,333),"6.283185307179586*pumpBuiding.riseTime");
AssertModelica(DYNX(W_,1124) > 0,"pumpBuiding.filter.f_cut > 0", 
  "f_cut > 0 required");
DYNX(W_,1127) = DYNX(DP_,344);
DYNX(W_,1140) = DYNX(DP_,344);
DYNX(W_,1171) = DYNX(DP_,322);
DYNX(W_,1172) = DYNX(DP_,323);
DYNX(W_,1173) = DYNX(DP_,324);
DYNX(W_,1174) = DYNX(DP_,325);
DYNX(W_,1175) = DYNX(DP_,326);
DYNX(W_,1176) = DYNX(DP_,327);
DYNX(W_,1181) = DYNX(DP_,343);
DYNX(W_,1182) = DYNX(DP_,343);
DYNX(W_,1203) = divmacro(0.1*DYNX(W_,1201)*sqr(DYNX(W_,1202)),"0.1*(pumpBuiding.eff.dpMax*pumpBuiding.eff.delta^2)",
  DYNX(W_,1189),"pumpBuiding.eff.V_flow_max");
DYNX(W_,1209) = DYNX(W_,1169)+DYNX(W_,1167)*DYNX(W_,1203);
DYNX(W_,1247) = DYNX(DP_,345);
DYNX(W_,1248) = DYNX(DP_,346);
DYNX(W_,1270) = DYNX(DP_,351);
DYNX(W_,1271) = DYNX(DP_,352);
DYNX(W_,1272) = DYNX(DP_,353);
DYNX(W_,1281) = divmacro(0.5*DYNX(DP_,350),"0.5*CoolingUnit.tau",DYNX(W_,1310),
  "CoolingUnit.rho_default");
DYNX(W_,1287) = DYNX(W_,1270);
DYNX(W_,1288) = DYNX(W_,1271);
DYNX(W_,1311) = DYNX(DP_,351);
DYNX(W_,1312) = DYNX(DP_,352);
DYNX(W_,1313) = 4184*(DYNX(W_,1312)-273.15);
DYNX(W_,1317) =  -divmacro(1,"1",DYNX(DP_,3)*9,"cp*9");
DYNX(W_,1328) = DYNX(DP_,386);
DYNX(W_,1336) = DYNX(DP_,26);
DYNX(W_,1337) = DYNX(DP_,26);
DYNX(W_,1340) =  -divmacro(DYNX(W_,1336),"building.heaLoaO[1].Q_flowHea_nominal",
  DYNX(DP_,388)-DYNX(W_,1335),"building.heaLoaO[1].TOutHea_nominal-building.heaLoaO[1].TIndHea_nominal");
DYNX(W_,1353) = DYNX(W_,426);
DYNX(W_,1354) = DYNX(W_,427);
DYNX(W_,1355) = DYNX(W_,428);
DYNX(W_,1378) = divmacro(DYNX(W_,1353),"building.thermalZoneOneElement.volAir.dynBal.p_start",
  287.0508037566665*DYNX(W_,1354),"287.0508037566665*building.thermalZoneOneElement.volAir.dynBal.T_start");
DYNX(W_,1383) = 1005.45*(DYNX(W_,1354)-298.15);
DYNX(W_,1387) = DYNX(DP_,63);
DYNX(W_,1399) = DYNX(W_,457);
DYNX(W_,1400) = DYNX(W_,458);
DYNX(W_,1401) = DYNX(W_,459);
DYNX(W_,1402) = DYNX(W_,460);
DYNX(W_,1410) = DYNX(DP_,66);
DYNX(W_,1411) = DYNX(DP_,67);
DYNX(W_,1412) = DYNX(DP_,68);
DYNX(W_,1413) = DYNX(DP_,59);
DYNX(W_,1415) = DYNX(W_,1412);
DYNX(W_,1419) = DYNX(W_,1410);
DYNX(W_,1421) = DYNX(W_,1411);
DYNX(W_,1422) = divmacro(1,"1",DYNX(DP_,208),"building.conPIDMinT.Ti");
DYNX(W_,1424) = DYNX(DP_,216);
DYNX(W_,1426) = DYNX(W_,541);
DYNX(W_,1428) = divmacro(1,"1",DYNX(DP_,223),"building.conPIDMax.Ti");
DYNX(W_,1430) = DYNX(DP_,231);
DYNX(W_,1432) = DYNX(W_,577);
DYNX(W_,1435) = DYNX(W_,860)*DYNX(W_,839);
DYNX(W_,1436) =  -DYNX(W_,860);
DYNX(W_,1437) = divmacro(1,"1",DYNX(W_,834),"coo.con.Ti");
DYNX(W_,1444) = DYNX(W_,835);
DYNX(W_,1445) = RealBmax(divmacro(DYNX(W_,835),"coo.con.Td",DYNX(W_,841),
  "coo.con.Nd"), 1E-14);
DYNX(W_,1447) = DYNX(W_,844);
DYNX(W_,1480) = DYNX(W_,1270);
DYNX(W_,1481) = DYNX(W_,1271);
DYNX(W_,1482) = DYNX(W_,1272);
DYNX(W_,1502) = DYNX(W_,1281);
DYNX(W_,1512) = 4184*(DYNX(W_,1481)-273.15);
DYNX(W_,128) = fabs(modulusDymola(DYNX(W_,127), 31536000)) < 0.01;
DYNX(W_,134) = fabs(modulusDymola(DYNX(W_,133), 31536000)) < 0.01;
DYNX(W_,1149) = DYNX(DP_,328);
DYNX(W_,1177) = DYNX(DP_,328);
DYNX(W_,1236) = (PushModelContext(1,"Modelica.Math.BooleanVectors.allTrue({(pumpBuiding.eff.per.pressure.dp[2]-pumpBuiding.eff.per.pressure.dp[1])/(pumpBuiding.eff.per.pressure.V_flow[2]-pumpBuiding.eff.per.pressure.V_flow[1]) <  -pumpBuiding.eff.kRes})")
  Modelica_Math_BooleanVectors_allTrue(IntegerScalarArray ( 1, (int )(divmacro(
  DYNX(W_,1169)-DYNX(W_,1168),"pumpBuiding.eff.per.pressure.dp[2]-pumpBuiding.eff.per.pressure.dp[1]",
  DYNX(W_,1167)-DYNX(W_,1166),"pumpBuiding.eff.per.pressure.V_flow[2]-pumpBuiding.eff.per.pressure.V_flow[1]")
   <  -DYNX(W_,1203)))));
PopAllMarks();
DYNX(W_,1448) = fabs(DYNX(W_,1444)) < 1E-15;
DYNX(W_,815) = 4184;
DYNX(W_,817) = 2092.0;
DYNX(W_,816) = 4184;
DYNX(W_,818) = 2092.0;
DYNX(W_,824) = 2;
DYNX(W_,794) = 4184;
DYNX(W_,795) = 4184;
DYNX(W_,1199) = 0;
DYNX(W_,1200) = 0;
DYNX(W_,1228) = 0.0;
DYNX(W_,1229) = 0.0;
DYNX(W_,1230) = 0.0;
DYNX(W_,1231) = 0.0;
DYNX(W_,1232) = 0.0;
DYNX(W_,1233) = 0.0;
DYNX(W_,1234) = 0.0;
InitialBoundSection
{
  struct DymStruc0 dummy_DymStruc0;
  dummy_DymStruc0 = (PushModelContext(1,"Modelica.Blocks.Types.ExternalCombiTable1D(\"tab1\", \"C:/Users/YLI3/Yanfei_Projects/modelica-buildings-yanfei/Buildings/Resources/weatherdata/USA_CA_San.Francisco.Intl.AP.724940_TMY3.mos\", weaDat.datRea.table, weaDat.datRea.columns, Modelica.Blocks.Types.Smoothness.ContinuousDerivative, 2, 0)")
    Modelica_Blocks_Types_ExternalCombiTable1D_M("tab1", "C:/Users/YLI3/Yanfei_Projects/modelica-buildings-yanfei/Buildings/Resources/weatherdata/USA_CA_San.Francisco.Intl.AP.724940_TMY3.mos",
     RealTemporaryDense( (Real*)(0), 2, 0, 2), IntegerTemporaryDense( 
    &DYNX(W_,47), 1, 26), 2, 2, 0));
  DYNX(W_,74) = dummy_DymStruc0.id_0member;
PopAllMarks();
}
DYNX(W_,75) = 0.0;
  {
    DYNX(W_,75) = (PushModelContext(1,"Modelica.Blocks.Tables.CombiTable1Ds.readTableData(\nweaDat.datRea.tableID, \nfalse, \nweaDat.datRea.verboseRead)")
      Modelica_Blocks_Tables_CombiTable1Ds_readTableData_M(DymStruc0_construct(
      (Integer)(DYNX(W_,74))), false, (Integer)(DYNX(DP_,15))));
    PopModelContext();
  }
{
  struct DymStruc0 dummy_DymStruc0;
  dummy_DymStruc0 = (PushModelContext(1,"Modelica.Blocks.Types.ExternalCombiTable1D(\"tab1\", \"C:/Users/YLI3/Yanfei_Projects/modelica-buildings-yanfei/Buildings/Resources/weatherdata/USA_CA_San.Francisco.Intl.AP.724940_TMY3.mos\", weaDat.datRea1.table, weaDat.datRea1.columns, Modelica.Blocks.Types.Smoothness.ContinuousDerivative, 3, 0)")
    Modelica_Blocks_Types_ExternalCombiTable1D_M("tab1", "C:/Users/YLI3/Yanfei_Projects/modelica-buildings-yanfei/Buildings/Resources/weatherdata/USA_CA_San.Francisco.Intl.AP.724940_TMY3.mos",
     RealTemporaryDense( (Real*)(0), 2, 0, 2), IntegerTemporaryDense( 
    &DYNX(W_,118), 1, 3), 2, 3, 0));
  DYNX(W_,122) = dummy_DymStruc0.id_0member;
PopAllMarks();
}
DYNX(W_,123) = 0.0;
  {
    DYNX(W_,123) = (PushModelContext(1,"Modelica.Blocks.Tables.CombiTable1Ds.readTableData(\nweaDat.datRea1.tableID, \nfalse, \nweaDat.datRea1.verboseRead)")
      Modelica_Blocks_Tables_CombiTable1Ds_readTableData_M(DymStruc0_construct(
      (Integer)(DYNX(W_,122))), false, (Integer)(DYNX(DP_,22))));
    PopModelContext();
  }
{
  struct DymStruc0 dummy_DymStruc0;
  dummy_DymStruc0 = (PushModelContext(1,"Modelica.Blocks.Types.ExternalCombiTimeTable(\"NoName\", \"NoName\", building.intGai.table, building.intGai.startTime, building.intGai.columns, Modelica.Blocks.Types.Smoothness.LinearSegments, building.intGai.extrapolation, 1, 1)")
    Modelica_Blocks_Types_ExternalCombiTimeTable_M("NoName", "NoName", 
    RealTemporaryDense( &DYNX(DP_,89), 2, 26, 4), DYNX(DP_,199), 
    IntegerTemporaryDense( &DYNX(DP_,194), 1, 3), 1, (Integer)(DYNX(DP_,197)), 1,
     1));
  DYNX(W_,519) = dummy_DymStruc0.id_0member;
PopAllMarks();
}
InitialSection2
DYNX(W_,522) = 0.0;
  {
    DYNX(W_,522) = 1.0;
  }
  DYNX(W_,514) = (PushModelContext(1,"Modelica.Blocks.Sources.CombiTimeTable.getTableTimeTmin(\nbuilding.intGai.tableID, \nbuilding.intGai.tableOnFileRead)")
    Modelica_Blocks_Sources_CombiTimeTable_getTableTimeTmin_M(DymStruc0_construct(
    (Integer)(DYNX(W_,519))), DYNX(W_,522)));
  PopModelContext();
  DYNX(W_,515) = (PushModelContext(1,"Modelica.Blocks.Sources.CombiTimeTable.getTableTimeTmax(\nbuilding.intGai.tableID, \nbuilding.intGai.tableOnFileRead)")
    Modelica_Blocks_Sources_CombiTimeTable_getTableTimeTmax_M(DymStruc0_construct(
    (Integer)(DYNX(W_,519))), DYNX(W_,522)));
  PopModelContext();
  DYNX(W_,512) = DYNX(W_,514);
  DYNX(W_,513) = DYNX(W_,515);
DYNX(W_,796) = RealBmin(0.2092, 0.2092);
DYNX(W_,822) = 0.0004780114722753346*(2092.0*DYNX(W_,804)-DYNX(W_,803));
DYNX(W_,823) = 0.0004780114722753346*(DYNX(W_,803)+2092.0*DYNX(W_,805));
DYNX(W_,948) = divmacro(0.5,"0.5",sqrtGuarded(DYNX(W_,947),"coo.val.dpValve_nominal"),
  "sqrt(coo.val.dpValve_nominal)");
DYNX(W_,944) = divmacro(DYNX(W_,948),"coo.val.Kv_SI",8.78410461157883E-07*
  DYNX(DP_,282),"8.78410461157883E-07*coo.val.rhoStd");
DYNX(W_,945) = divmacro(DYNX(W_,948),"coo.val.Kv_SI",1.2042949486827428E-05*
  DYNX(DP_,282)*0.0631,"1.2042949486827428E-05*(coo.val.rhoStd*0.0631)");
DYNX(W_,946) = divmacro(DYNX(W_,948),"coo.val.Kv_SI",sqrtGuarded(DYNX(DP_,282),
  "coo.val.rhoStd"),"sqrt(coo.val.rhoStd)");
RealAssign (RealTemporaryDense( &DYNX(W_,964), 1, 2), (PushModelContext(1,
  "Modelica.Blocks.Continuous.Internal.Filter.base.CriticalDamping(2, coo.val.filter.normalized)")
  Modelica_Blocks_Continuous_Internal_Filter_base_CriticalDamping(2, (Integer)(
  DYNX(DP_,288)))));
PopAllMarks();
{
  struct Modelica_Blocks_Continuous_Internal_Filter_roots_lowPass_struct
     dummy_mult_=(PushModelContext(1,"Modelica.Blocks.Continuous.Internal.Filter.roots.lowPass(coo.val.filter.cr, coo.val.filter.c0, coo.val.filter.c1, coo.val.filter.f_cut)")
    Modelica_Blocks_Continuous_Internal_Filter_roots_lowPass(RealTemporaryDense( 
    &DYNX(W_,964), 1, 2), RealTemporaryDense( (Real*)(0), 1, 0), 
    RealTemporaryDense( (Real*)(0), 1, 0), DYNX(W_,956)));
  RealAssign (RealTemporaryDense( &DYNX(W_,966), 1, 2), dummy_mult_.r0_0_0member);
  RealAssign (RealTemporaryDense( (Real*)(0), 1, 0), dummy_mult_.a0_0_0member);
  RealAssign (RealTemporaryDense( (Real*)(0), 1, 0), dummy_mult_.b0_0_0member);
  RealAssign (RealTemporaryDense( (Real*)(0), 1, 0), dummy_mult_.ku0_0_0member);
}
PopAllMarks();
RealAssign (RealTemporaryDense( &DYNX(W_,1133), 1, 2), (PushModelContext(1,
  "Modelica.Blocks.Continuous.Internal.Filter.base.CriticalDamping(2, pumpBuiding.filter.normalized)")
  Modelica_Blocks_Continuous_Internal_Filter_base_CriticalDamping(2, (Integer)(
  DYNX(DP_,338)))));
PopAllMarks();
{
  struct Modelica_Blocks_Continuous_Internal_Filter_roots_lowPass_struct
     dummy_mult_=(PushModelContext(1,"Modelica.Blocks.Continuous.Internal.Filter.roots.lowPass(pumpBuiding.filter.cr, pumpBuiding.filter.c0, pumpBuiding.filter.c1, pumpBuiding.filter.f_cut)")
    Modelica_Blocks_Continuous_Internal_Filter_roots_lowPass(RealTemporaryDense( 
    &DYNX(W_,1133), 1, 2), RealTemporaryDense( (Real*)(0), 1, 0), 
    RealTemporaryDense( (Real*)(0), 1, 0), DYNX(W_,1124)));
  RealAssign (RealTemporaryDense( &DYNX(W_,1135), 1, 2), dummy_mult_.r0_0_0member);
  RealAssign (RealTemporaryDense( (Real*)(0), 1, 0), dummy_mult_.a0_0_0member);
  RealAssign (RealTemporaryDense( (Real*)(0), 1, 0), dummy_mult_.b0_0_0member);
  RealAssign (RealTemporaryDense( (Real*)(0), 1, 0), dummy_mult_.ku0_0_0member);
}
PopAllMarks();
RealAssign (RealTemporaryDense( &DYNX(W_,1226), 1, 2), (PushModelContext(1,
  "Buildings.Utilities.Math.Functions.splineDerivatives(pumpBuiding.eff.pCur1.V_flow, pumpBuiding.eff.pCur1.dp, Buildings.Utilities.Math.Functions.isMonotonic(pumpBuiding.eff.pCur1.dp, false))")
  Buildings_Utilities_Math_Functions_splineDerivatives(RealTemporaryDense( 
  &DYNX(W_,1206), 1, 2), RealTemporaryDense( &DYNX(W_,1208), 1, 2), (Integer)(
  Buildings_Utilities_Math_Functions_isMonotonic(RealTemporaryDense( 
  &DYNX(W_,1208), 1, 2), false)))));
PopAllMarks();
InitialBoundSection
{
  struct DymStruc0 dummy_DymStruc0;
  dummy_DymStruc0 = (PushModelContext(1,"Modelica.Blocks.Types.ExternalCombiTimeTable(\"NoName\", \"NoName\", QCoo.table, 0.0002777777777777778*QCoo.startTime, QCoo.columns, Modelica.Blocks.Types.Smoothness.LinearSegments, QCoo.extrapolation, 0, 1)")
    Modelica_Blocks_Types_ExternalCombiTimeTable_M("NoName", "NoName", 
    RealTemporaryDense( &DYNX(DP_,362), 2, 11, 2), 0.0002777777777777778*
    DYNX(DP_,387), IntegerTemporaryDense( &DYNX(W_,1321), 1, 1), 1, (Integer)(
    DYNX(DP_,385)), 0, 1));
  DYNX(W_,1329) = dummy_DymStruc0.id_0member;
PopAllMarks();
}
InitialSection2
DYNX(W_,1332) = 0.0;
  {
    DYNX(W_,1332) = 1.0;
  }
  DYNX(W_,1326) = (PushModelContext(1,"Modelica.Blocks.Sources.CombiTimeTable.getTableTimeTmin(\nQCoo.tableID, \nQCoo.tableOnFileRead)")
    Modelica_Blocks_Sources_CombiTimeTable_getTableTimeTmin_M(DymStruc0_construct(
    (Integer)(DYNX(W_,1329))), DYNX(W_,1332)));
  PopModelContext();
  DYNX(W_,1327) = (PushModelContext(1,"Modelica.Blocks.Sources.CombiTimeTable.getTableTimeTmax(\nQCoo.tableID, \nQCoo.tableOnFileRead)")
    Modelica_Blocks_Sources_CombiTimeTable_getTableTimeTmax_M(DymStruc0_construct(
    (Integer)(DYNX(W_,1329))), DYNX(W_,1332)));
  PopModelContext();
  DYNX(W_,1324) = 3600.0*DYNX(W_,1326);
  DYNX(W_,1325) = 3600.0*DYNX(W_,1327);
DYNX(W_,1334) = 0.0002777777777777778*DYNTime;
InitialBoundSection
DYNX(W_,1331) = (PushModelContext(1,"Modelica.Blocks.Sources.CombiTimeTable.getNextTimeEvent(\nQCoo.tableID, \nQCoo.timeScaled, \nQCoo.tableOnFileRead)")
  Modelica_Blocks_Sources_CombiTimeTable_getNextTimeEvent_M(DymStruc0_construct(
  (Integer)(DYNX(W_,1329))), DYNX(W_,1334), DYNX(W_,1332)));
PopModelContext();
InitialSection2
  DYNX(W_,985) = real2integerEvent(divmacro(DYNTime-DYNX(DP_,305),
    "time-tra.startTime",DYNX(DP_,302),"tra.period"),"(time-tra.startTime)/tra.period",
     0);
  DYNX(W_,984) = DYNX(DP_,305)+DYNX(W_,985)*DYNX(DP_,302);
DYNX(W_,524) = DYNTime;
InitialBoundSection
DYNX(W_,521) = (PushModelContext(1,"Modelica.Blocks.Sources.CombiTimeTable.getNextTimeEvent(\nbuilding.intGai.tableID, \nbuilding.intGai.timeScaled, \nbuilding.intGai.tableOnFileRead)")
  Modelica_Blocks_Sources_CombiTimeTable_getNextTimeEvent_M(DymStruc0_construct(
  (Integer)(DYNX(W_,519))), DYNX(W_,524), DYNX(W_,522)));
PopModelContext();
InitialSection2
DYNX(W_,106) = DYNTime;
DYNX(W_,135) = IF DYNX(W_,134) THEN real2integerEvent(divmacro(DYNX(W_,106),
  "weaDat.modTim.y",DYNX(W_,133),"weaDat.conTim.lenWea"),"weaDat.modTim.y/weaDat.conTim.lenWea",
   1)*DYNX(W_,133)+DYNX(W_,133) ELSE DYNTime;
DYNX(W_,108) = 1800.0*DYNX(DP_,20)+DYNX(DP_,21)*DYNX(W_,106);
DYNX(W_,129) = IF DYNX(W_,128) THEN real2integerEvent(divmacro(DYNX(W_,108),
  "weaDat.add.y",DYNX(W_,127),"weaDat.conTim1.lenWea"),"weaDat.add.y/weaDat.conTim1.lenWea",
   2)*DYNX(W_,127)+DYNX(W_,127) ELSE DYNTime;
DYNX(W_,1330) = IF Less(DYNX(W_,1331),"QCoo.nextTimeEventScaled", 
  1.7976931348623157E+308,"1.7976931348623157E+308", 3) THEN 3600*DYNX(W_,1331)
   ELSE 1.7976931348623157E+308;
DYNX(W_,520) = IF Less(DYNX(W_,521),"building.intGai.nextTimeEventScaled", 
  1.7976931348623157E+308,"1.7976931348623157E+308", 4) THEN DYNX(W_,521) ELSE 
  1.7976931348623157E+308;
DYNX(W_,1014) = 4184*(DYNX(DP_,317)-273.15);
DYNX(W_,640) = 273.15+0.0002390057361376673*DYNX(W_,1014);
DYNX(W_,1498) = 995.586*DYNX(W_,1502);
InitialBoundSection
DYNX(Aux_,4) = DYNX(W_,1014);
InitialSection2
DYNX(W_,907) = 273.15+0.0002390057361376673*DYNX(W_,1014);
DYNX(W_,1028) = 273.15+0.0002390057361376673*DYNX(W_,1014);
DYNX(W_,526) = 273.15+DYNX(DP_,205);
DYNX(W_,531) = 273.15+DYNX(DP_,206);
InitialBoundSection
DYNX(Aux_,3) = DYNX(W_,1014);
DYNX(Aux_,11) = DYNX(W_,1014);
InitialSection2
DYNX(W_,336) = cos(DYNX(W_,329));
DYNX(W_,337) = sin(DYNX(W_,329));
DYNX(W_,262) = cos(DYNX(W_,255));
DYNX(W_,263) = sin(DYNX(W_,255));
DYNX(W_,352) = cos(DYNX(W_,345));
DYNX(W_,353) = sin(DYNX(W_,345));
DYNX(W_,320) = cos(DYNX(W_,313));
DYNX(W_,321) = sin(DYNX(W_,313));
DYNX(W_,1032) = DYNX(DP_,315);
DYNX(W_,990) = DYNX(DP_,306);
InitialBoundSection
DYNX(Aux_,36) = DYNX(W_,984);
InitialSection2
DYNX(W_,189) = DYNX(W_,1328)+(PushModelContext(1,"Modelica.Blocks.Sources.CombiTimeTable.getTableValue(\nQCoo.tableID, \n1, \nQCoo.timeScaled, \nQCoo.nextTimeEventScaled, \nQCoo.nextTimeEventScaled_.start, \nQCoo.tableOnFileRead)")
  Modelica_Blocks_Sources_CombiTimeTable_getTableValue_M(DymStruc0_construct(
  (Integer)(DYNX(W_,1329))), 1, DYNX(W_,1334), DYNX(W_,1331), DYNX(Aux_,33), 
  DYNX(W_,1332)));
PopModelContext();
DYNX(W_,1318) = DYNX(W_,1317)*DYNX(W_,189);
DYNX(W_,1137) = 2.0*DYNX(W_,1318);
 /* Linear system of equations to solve. */
DYNX(X_,8) = 0.0;
SolveScalarLinearParametric( -DYNX(W_,1135)," -pumpBuiding.filter.r[1]",  -
  DYNX(W_,1135)*DYNX(W_,1137)," -pumpBuiding.filter.r[1]*pumpBuiding.filter.uu[1]",
   DYNX(X_,8),"pumpBuiding.filter.x[1]");
 /* End of Equation Block */ 

DYNX(W_,615) = DYNX(W_,1127);
AssertModelica(Greater(DYNX(W_,615),"coo.port_a2.m_flow", -5E-05,"-5E-05", 5),
  "coo.port_a2.m_flow > -5E-05", StringAdd(StringAdd("In CouplingETS_RC_Yanfei_Cooling.pumpBuiding.vol: Model has flow reversal,\n  but the parameter allowFlowReversal is set to false.\n  m_flow_small    = 5e-05\n  ports[1].m_flow = ",
  Real2String2(DYNX(W_,615), true, 0)),"\n"));
PopAllMarks();
AssertModelica(Greater(DYNX(W_,615),"coo.port_a2.m_flow", -5E-05,"-5E-05", 5),
  "coo.port_a2.m_flow > -5E-05", "Reverting flow occurs even though allowFlowReversal is false");
 /* Linear system of equations to solve. */
DYNX(X_,9) = 0.0;
SolveScalarLinearParametric((-0.5)*DYNX(DP_,335),"(-0.5)*pumpBuiding.filter.gain",
    -DYNX(W_,615)," -coo.port_a2.m_flow", DYNX(X_,9),"pumpBuiding.filter.x[2]");
 /* End of Equation Block */ 

DYNX(X_,10) = 995.586*DYNX(DP_,348);
AssertModelica(Greater(DYNX(X_,10),"exp.m", 1E-08,"1E-08", 6),"exp.m > 1E-08", 
  "Expansion vessel is undersized. You need to increase the value of the parameter V_start.");
DYNX(X_,3) = DYNX(DP_,276);
DYNX(W_,1434) = DYNX(W_,1435)*DYNX(DP_,297)+DYNX(W_,1436)*DYNX(X_,3);
 /* Linear system of equations to solve. */
DYNX(X_,19) = DYNX(W_,1447);
SolveScalarLinearParametric( -(IF DYNX(W_,1448) THEN 0 ELSE divmacro(-1.0,"-1.0",
  DYNX(W_,1445),"coo.con.D.T"))," -(if coo.con.D.zeroGain then 0 else (-1.0)/coo.con.D.T)",
   IF DYNX(W_,1448) THEN 0 ELSE divmacro(DYNX(W_,1434),"coo.con.addD.y",
  DYNX(W_,1445),"coo.con.D.T"),"(if coo.con.D.zeroGain then 0 else coo.con.addD.y/coo.con.D.T)",
   DYNX(X_,19),"coo.con.D.x");
 /* End of Equation Block */ 

 /* Linear system of equations to solve. */
DYNX(W_,858) = 0.0;
SolveScalarLinearParametric( -DYNX(W_,871)," -coo.con.gainPID.k", 0.0,"0.0", 
  DYNX(W_,858),"coo.con.addPID.y");
 /* End of Equation Block */ 

DYNX(W_,850) = DYNX(W_,851)*DYNX(DP_,297)+DYNX(W_,852)*DYNX(X_,3);
DYNX(W_,853) = DYNX(DP_,266)*DYNX(W_,850);
DYNX(W_,857) = IF DYNX(W_,1448) THEN 0 ELSE divmacro(DYNX(W_,1444)*(
  DYNX(W_,1434)-DYNX(X_,19)),"coo.con.D.k*(coo.con.addD.y-coo.con.D.x)",
  DYNX(W_,1445),"coo.con.D.T");
DYNX(X_,18) = DYNX(W_,858)-(DYNX(W_,853)+DYNX(W_,857));
DYNX(W_,830) = homotopy(IF 0.0 > DYNX(W_,874) THEN DYNX(W_,874) ELSE IF 0.0 < 
  DYNX(W_,875) THEN DYNX(W_,875) ELSE 0.0, 0.0);
DYNX(W_,968) = divmacro(DYNX(W_,830),"coo.con.y",DYNX(DP_,291),"coo.val.filter.u_nominal");
 /* Linear system of equations to solve. */
DYNX(X_,4) = 0.0;
SolveScalarLinearParametric( -DYNX(W_,966)," -coo.val.filter.r[1]",  -
  DYNX(W_,966)*DYNX(W_,968)," -coo.val.filter.r[1]*coo.val.filter.uu[1]", 
  DYNX(X_,4),"coo.val.filter.x[1]");
 /* End of Equation Block */ 

DYNX(W_,952) = DYNX(W_,959);
 /* Linear system of equations to solve. */
DYNX(X_,5) = 0.0;
SolveScalarLinearParametric( -DYNX(DP_,285)*DYNX(DP_,291)," -coo.val.filter.gain*coo.val.filter.u_nominal",
    -DYNX(W_,952)," -coo.val.y_actual", DYNX(X_,5),"coo.val.filter.x[2]");
 /* End of Equation Block */ 

DYNX(X_,20) = 4165531.824*DYNX(W_,1502)*(DYNX(W_,1481)-273.15);
DYNX(X_,11) = 4184.0*DYNX(X_,10)*(DYNX(DP_,346)-273.15);
DYNX(X_,0) = DYNX(DP_,268);
DYNX(X_,1) = DYNX(DP_,271);
DYNX(X_,2) = DYNX(DP_,275);
DYNX(X_,6) = DYNX(DP_,309);
DYNX(X_,7) = DYNX(DP_,312);
DYNX(W_,1362) = DYNX(W_,1353);
DYNX(W_,1364) = DYNX(W_,1354);
AssertModelica(GreaterEqual(DYNX(W_,1362),"building.thermalZoneOneElement.volAir.dynBal.medium.p",
   0.0,"0.0", 7),"building.thermalZoneOneElement.volAir.dynBal.medium.p >= 0.0",
   StringAdd(StringAdd(StringAdd(StringAdd(StringAdd(StringAdd("Pressure (= ",
  Real2String2(DYNX(W_,1362), true, 0))," Pa) of medium \""),"SimpleAir"),
  "\" is negative\n(Temperature = "),Real2String2(DYNX(W_,1364), true, 0))," K)"));
PopAllMarks();
AssertModelica(GreaterEqual(DYNX(W_,1364),"building.thermalZoneOneElement.volAir.dynBal.medium.T",
   273.15,"273.15", 8) AND LessEqual(DYNX(W_,1364),"building.thermalZoneOneElement.volAir.dynBal.medium.T",
   373.15,"373.15", 9),"building.thermalZoneOneElement.volAir.dynBal.medium.T >= 273.15 and building.thermalZoneOneElement.volAir.dynBal.medium.T <= 373.15",
   StringAdd(StringAdd(StringAdd(StringAdd(StringAdd(StringAdd(StringAdd(
  StringAdd("\nTemperature T (= ",Real2String2(DYNX(W_,1364), true, 0)),
  " K) is not\nin the allowed range ("),"273.15")," K <= T <= "),"373.15"),
  " K)\nrequired from medium model \""),"SimpleAir"),"\".\n"));
PopAllMarks();
BreakSectionFunctionEnd()
BreakSectionFunctionStart(5);
 /* Linear system of equations to solve. */
DYNX(W_,1363) = DYNX(W_,1378);
SolveScalarLinear((-287.0508037566665)*DYNX(W_,1364),"(-287.0508037566665)*building.thermalZoneOneElement.volAir.dynBal.medium.T",
    -DYNX(W_,1362)," -building.thermalZoneOneElement.volAir.dynBal.medium.p", 
  DYNX(W_,1363),"building.thermalZoneOneElement.volAir.dynBal.medium.d");
 /* End of Equation Block */ 

DYNX(X_,14) = 52.49999999999999*DYNX(W_,1363);
DYNX(W_,446) = 1005.45*(DYNX(W_,1364)-298.15);
DYNX(W_,1366) = DYNX(W_,446)-287.0508037566665*DYNX(W_,1364);
DYNX(X_,13) = DYNX(X_,14)*DYNX(W_,1366);
DYNX(W_,1417) = DYNX(W_,1415)*DYNX(W_,1416);
DYNX(W_,22) = IF DYNX(W_,134) THEN DYNX(W_,106)-DYNX(W_,135)+DYNX(W_,133) ELSE 
  DYNX(W_,106);
DYNX(W_,23) = (PushModelContext(1,"Modelica.Blocks.Tables.CombiTable1Ds.getTableValue(\nweaDat.datRea.tableID, \n1, \nweaDat.datRea.u, \nweaDat.datRea.tableOnFileRead)")
  Modelica_Blocks_Tables_CombiTable1Ds_getTableValue_M(DymStruc0_construct(
  (Integer)(DYNX(W_,74))), 1, DYNX(W_,22), DYNX(W_,75)));
PopModelContext();
DYNX(W_,142) = 273.15+DYNX(W_,23);
AssertModelica(Greater(DYNX(W_,142),"weaDat.TDryBul_in_internal", DYNX(DP_,16),
  "weaDat.cheTemDryBul.TMin", 10),"weaDat.TDryBul_in_internal > weaDat.cheTemDryBul.TMin",
   StringAdd("Temperature out of bounds.\n   TOut = ",Real2String2(DYNX(W_,142),
   true, 0)));
PopAllMarks();
AssertModelica(Less(DYNX(W_,142),"weaDat.TDryBul_in_internal", DYNX(DP_,17),
  "weaDat.cheTemDryBul.TMax", 11),"weaDat.TDryBul_in_internal < weaDat.cheTemDryBul.TMax",
   StringAdd("Temperature out of bounds.\n   TOut = ",Real2String2(DYNX(W_,142),
   true, 0)));
PopAllMarks();
DYNX(W_,151) = (PushModelContext(1,"Modelica.Blocks.Tables.CombiTable1Ds.getTableValue(\nweaDat.datRea.tableID, \n26, \nweaDat.datRea.u, \nweaDat.datRea.tableOnFileRead)")
  Modelica_Blocks_Tables_CombiTable1Ds_getTableValue_M(DymStruc0_construct(
  (Integer)(DYNX(W_,74))), 26, DYNX(W_,22), DYNX(W_,75)));
PopModelContext();
DYNX(W_,96) = IF DYNX(W_,151)-0.0001 > 1E-05 THEN DYNX(W_,151) ELSE IF 
  DYNX(W_,151)-0.0001 < -1E-05 THEN 0.0001 ELSE 5E-05+24999.999999999996*(
  DYNX(W_,151)-0.0001)*(sqr(99999.99999999999*(DYNX(W_,151)-0.0001))-3)*(0.0001-
  DYNX(W_,151))+0.5*DYNX(W_,151);
DYNX(W_,144) = powmacro(17635542.814071823*DYNX(W_,96),"17635542.814071823*weaDat.cheHorRad.HOut",
  0.25,"0.25");
AssertModelica(Greater(DYNX(W_,144),"weaDat.TBlaSky_in_internal", DYNX(DP_,23),
  "weaDat.cheTemBlaSky.TMin", 12),"weaDat.TBlaSky_in_internal > weaDat.cheTemBlaSky.TMin",
   StringAdd("Temperature out of bounds.\n   TOut = ",Real2String2(DYNX(W_,144),
   true, 0)));
PopAllMarks();
AssertModelica(Less(DYNX(W_,144),"weaDat.TBlaSky_in_internal", DYNX(DP_,24),
  "weaDat.cheTemBlaSky.TMax", 13),"weaDat.TBlaSky_in_internal < weaDat.cheTemBlaSky.TMax",
   StringAdd("Temperature out of bounds.\n   TOut = ",Real2String2(DYNX(W_,144),
   true, 0)));
PopAllMarks();
DYNX(W_,489) = divmacro((DYNX(W_,144)-DYNX(W_,142))*DYNX(DP_,79),
  "(weaDat.TBlaSky_in_internal-weaDat.TDryBul_in_internal)*building.eqAirTemp.hRad",
  DYNX(DP_,79)+DYNX(DP_,80),"building.eqAirTemp.hRad+building.eqAirTemp.hConWinOut");
DYNX(W_,486) = DYNX(W_,142)+DYNX(W_,489)*(1-DYNX(DP_,200));
DYNX(W_,487) = DYNX(W_,142)+DYNX(W_,489)*(1-DYNX(DP_,201));
DYNX(W_,495) = DYNX(W_,486)*DYNX(DP_,74)+DYNX(W_,487)*DYNX(DP_,75);
DYNX(W_,502) = DYNX(W_,516)+(PushModelContext(1,"Modelica.Blocks.Sources.CombiTimeTable.getTableValue(\nbuilding.intGai.tableID, \n1, \nbuilding.intGai.timeScaled, \nbuilding.intGai.nextTimeEventScaled, \nbuilding.intGai.nextTimeEventScaled_.start, \nbuilding.intGai.tableOnFileRead)")
  Modelica_Blocks_Sources_CombiTimeTable_getTableValue_M(DymStruc0_construct(
  (Integer)(DYNX(W_,519))), 1, DYNX(W_,524), DYNX(W_,521), DYNX(Aux_,35), 
  DYNX(W_,522)));
PopModelContext();
DYNX(W_,325) = asinGuarded((-0.3979486313076103)*cos(0.17202423838958483+
  1.9910212776572317E-07*DYNX(W_,106)),"(-0.3979486313076103)*cos(0.17202423838958483+1.9910212776572317E-07*weaDat.modTim.y)");
DYNX(W_,332) = cos(DYNX(W_,325));
DYNX(W_,113) = DYNX(W_,106)-576.0;
DYNX(W_,137) = 0.017261498096647215*(1.1574074074074073E-05*DYNX(W_,106)-80.0);
DYNX(W_,136) = 60*(9.87*sin(2*DYNX(W_,137))-7.53*cos(DYNX(W_,137))-1.5*sin(
  DYNX(W_,137)));
DYNX(W_,138) = DYNX(W_,113)+DYNX(W_,136);
DYNX(W_,328) = 0.2617993877991494*(0.0002777777777777778*DYNX(W_,138)-12);
DYNX(W_,334) = cos(DYNX(W_,328));
DYNX(W_,333) = sin(DYNX(W_,325));
DYNX(W_,335) = sin(DYNX(W_,328));
DYNX(W_,361) = acosGuarded(cos(DYNX(W_,331))*(DYNX(W_,332)*DYNX(W_,334)*
  DYNX(W_,336)+DYNX(W_,333)*DYNX(W_,337))+sin(DYNX(W_,331))*(sin(DYNX(W_,330))*
  DYNX(W_,332)*DYNX(W_,335)+cos(DYNX(W_,330))*(DYNX(W_,332)*DYNX(W_,334)*
  DYNX(W_,337)-DYNX(W_,333)*DYNX(W_,336))),"cos(building.HDirTil[1].incAng.incAng.til)*(building.HDirTil[1].incAng.incAng.dec_c*building.HDirTil[1].incAng.incAng.sol_c*building.HDirTil[1].incAng.incAng.lat_c+building.HDirTil[1].incAng.incAng.dec_s*building.HDirTil[1].incAng.incAng.lat_s)+sin(building.HDirTil[1].incAng.incAng.til)*(sin(building.HDirTil[1].incAng.incAng.azi)*building.HDirTil[1].incAng.incAng.dec_c*building.HDirTil[1].incAn...");
DYNX(W_,116) = IF DYNX(W_,128) THEN DYNX(W_,108)-DYNX(W_,129)+DYNX(W_,127) ELSE 
  DYNX(W_,108);
DYNX(W_,150) = (PushModelContext(1,"Modelica.Blocks.Tables.CombiTable1Ds.getTableValue(\nweaDat.datRea1.tableID, \n2, \nweaDat.datRea1.u, \nweaDat.datRea1.tableOnFileRead)")
  Modelica_Blocks_Tables_CombiTable1Ds_getTableValue_M(DymStruc0_construct(
  (Integer)(DYNX(W_,122))), 2, DYNX(W_,116), DYNX(W_,123)));
PopModelContext();
DYNX(W_,90) = IF DYNX(W_,150)-0.0001 > 1E-05 THEN DYNX(W_,150) ELSE IF 
  DYNX(W_,150)-0.0001 < -1E-05 THEN 0.0001 ELSE 5E-05+24999.999999999996*(
  DYNX(W_,150)-0.0001)*(sqr(99999.99999999999*(DYNX(W_,150)-0.0001))-3)*(0.0001-
  DYNX(W_,150))+0.5*DYNX(W_,150);
DYNX(W_,357) = RealBmax(0, cos(DYNX(W_,361))*DYNX(W_,90));
DYNX(W_,377) = 57.29577951308232*(57.29577951308232*(57.29577951308232*(
  57.29577951308232*(57.29577951308232*(57.29577951308232*DYNX(DP_,54)*
  DYNX(W_,361)+DYNX(DP_,53))*DYNX(W_,361)+DYNX(DP_,52))*DYNX(W_,361)+
  DYNX(DP_,51))*DYNX(W_,361)+DYNX(DP_,50))*DYNX(W_,361)+DYNX(DP_,49))*
  DYNX(W_,361)+DYNX(DP_,48);
DYNX(W_,379) = powmacro(0.907,"0.907",divmacro(1,"1",sqrtGuarded(1-sqr(
  0.6600660066006601*sin(DYNX(W_,361))),"1-(0.6600660066006601*sin(building.corGDouPan.inc[1]))^2"),
  "sqrt(1-(0.6600660066006601*sin(building.corGDouPan.inc[1]))^2)"),
  "1/sqrt(1-(0.6600660066006601*sin(building.corGDouPan.inc[1]))^2)");
DYNX(W_,381) = DYNX(W_,377)*DYNX(W_,379);
DYNX(W_,383) = 1-DYNX(W_,377);
DYNX(W_,385) = divmacro(DYNX(W_,383),"building.corGDouPan.rho_T1_dir[1]",2-
  DYNX(W_,383),"2-building.corGDouPan.rho_T1_dir[1]");
DYNX(W_,387) = DYNX(W_,385)+divmacro(sqr((1-DYNX(W_,385))*DYNX(W_,379))*
  DYNX(W_,385),"((1-building.corGDouPan.rho_11_dir[1])*building.corGDouPan.Tai_dir[1])^2*building.corGDouPan.rho_11_dir[1]",1
  -sqr(DYNX(W_,385)*DYNX(W_,379)),"1-(building.corGDouPan.rho_11_dir[1]*building.corGDouPan.Tai_dir[1])^2");
DYNX(W_,389) = 1.0-sqr(DYNX(W_,387));
DYNX(W_,391) = divmacro(sqr(DYNX(W_,381)),"building.corGDouPan.Ta1_dir[1]^2",
  DYNX(W_,389),"building.corGDouPan.XN2_dir[1]");
DYNX(W_,393) = 1-(DYNX(W_,381)+DYNX(W_,387));
DYNX(W_,395) = 0.04*DYNX(W_,393)*(1+divmacro(DYNX(W_,381)*DYNX(W_,387),
  "building.corGDouPan.Ta1_dir[1]*building.corGDouPan.rho_1_dir[1]",DYNX(W_,389),
  "building.corGDouPan.XN2_dir[1]"))*DYNX(DP_,47);
DYNX(W_,397) = divmacro(DYNX(W_,393)*DYNX(W_,381)*(1-DYNX(DP_,47)/(double)(7.7)),
  "building.corGDouPan.a1_dir[1]*building.corGDouPan.Ta1_dir[1]*(1-building.corGDouPan.UWin/7.7)",
  DYNX(W_,389),"building.corGDouPan.XN2_dir[1]");
DYNX(W_,399) = DYNX(W_,395)+DYNX(W_,397);
DYNX(W_,401) = divmacro(DYNX(W_,391)+DYNX(W_,399),"building.corGDouPan.Ta2_dir[1]+building.corGDouPan.Qsek2_dir[1]",
  DYNX(DP_,55),"building.corGDouPan.g_dir0");
DYNX(W_,149) = (PushModelContext(1,"Modelica.Blocks.Tables.CombiTable1Ds.getTableValue(\nweaDat.datRea1.tableID, \n3, \nweaDat.datRea1.u, \nweaDat.datRea1.tableOnFileRead)")
  Modelica_Blocks_Tables_CombiTable1Ds_getTableValue_M(DymStruc0_construct(
  (Integer)(DYNX(W_,122))), 3, DYNX(W_,116), DYNX(W_,123)));
PopModelContext();
DYNX(W_,88) = IF DYNX(W_,149)-0.0001 > 1E-05 THEN DYNX(W_,149) ELSE IF 
  DYNX(W_,149)-0.0001 < -1E-05 THEN 0.0001 ELSE 5E-05+24999.999999999996*(
  DYNX(W_,149)-0.0001)*(sqr(99999.99999999999*(DYNX(W_,149)-0.0001))-3)*(0.0001-
  DYNX(W_,149))+0.5*DYNX(W_,149);
DYNX(W_,148) = (PushModelContext(1,"Modelica.Blocks.Tables.CombiTable1Ds.getTableValue(\nweaDat.datRea1.tableID, \n1, \nweaDat.datRea1.u, \nweaDat.datRea1.tableOnFileRead)")
  Modelica_Blocks_Tables_CombiTable1Ds_getTableValue_M(DymStruc0_construct(
  (Integer)(DYNX(W_,122))), 1, DYNX(W_,116), DYNX(W_,123)));
PopModelContext();
DYNX(W_,86) = IF DYNX(W_,148)-0.0001 > 1E-05 THEN DYNX(W_,148) ELSE IF 
  DYNX(W_,148)-0.0001 < -1E-05 THEN 0.0001 ELSE 5E-05+24999.999999999996*(
  DYNX(W_,148)-0.0001)*(sqr(99999.99999999999*(DYNX(W_,148)-0.0001))-3)*(0.0001-
  DYNX(W_,148))+0.5*DYNX(W_,148);
DYNX(W_,222) = IF DYNX(W_,88)-5E-05 > 2.5E-05 THEN DYNX(W_,88) ELSE IF 
  DYNX(W_,88)-5E-05 < -2.5E-05 THEN 5E-05 ELSE 2.5E-05+10000.0*(DYNX(W_,88)-
  5E-05)*(sqr(40000.0*(DYNX(W_,88)-5E-05))-3)*(5E-05-DYNX(W_,88))+0.5*
  DYNX(W_,88);
DYNX(W_,164) = asinGuarded((-0.3979486313076103)*cos(0.17202423838958483+
  1.9910212776572317E-07*DYNX(W_,106)),"(-0.3979486313076103)*cos(0.17202423838958483+1.9910212776572317E-07*weaDat.modTim.y)");
DYNX(W_,163) = 0.2617993877991494*(0.0002777777777777778*DYNX(W_,138)-12);
DYNX(W_,160) = acosGuarded(0.7920766142499671*cos(DYNX(W_,164))*cos(DYNX(W_,163))
  +0.6104216879816025*sin(DYNX(W_,164)),"0.7920766142499671*(cos(weaDat.zenAng.decAng)*cos(weaDat.zenAng.solHouAng))+0.6104216879816025*sin(weaDat.zenAng.decAng)");
DYNX(W_,221) = 1.040895310738997*powmacro2(DYNX(W_,160),"weaDat.altAng.zen",3,
  "3");
DYNX(W_,217) = (PushModelContext(1,"Buildings.Utilities.Math.Functions.smoothLimit((weaDat.cheGloHorRad.HOut/building.HDifTil[1].skyCle.HDifHorBou+building.HDifTil[1].skyCle.tmp1)/(1+building.HDifTil[1].skyCle.tmp1), 1, 8, 0.01)")
  Buildings_Utilities_Math_Functions_smoothLimit(divmacro(divmacro(DYNX(W_,86),
  "weaDat.cheGloHorRad.HOut",DYNX(W_,222),"building.HDifTil[1].skyCle.HDifHorBou")
  +DYNX(W_,221),"weaDat.cheGloHorRad.HOut/building.HDifTil[1].skyCle.HDifHorBou+building.HDifTil[1].skyCle.tmp1",1
  +DYNX(W_,221),"1+building.HDifTil[1].skyCle.tmp1"), 1, 8, 0.01));
PopModelContext();
DYNX(W_,239) = IF 1.23-DYNX(W_,217) > 0.01 THEN 1 ELSE IF 1.23-DYNX(W_,217) < 
  -0.01 THEN 0 ELSE 0.5-25.0*(1.23-DYNX(W_,217))*(sqr(100.0*(1.23-DYNX(W_,217)))
  -3);
DYNX(W_,231) = IF 1.065-DYNX(W_,217) > 0.01 THEN 1 ELSE IF 1.065-DYNX(W_,217) < 
  -0.01 THEN 0 ELSE 0.5-25.0*(1.065-DYNX(W_,217))*(sqr(100.0*(1.065-DYNX(W_,217)))
  -3);
DYNX(W_,232) = DYNX(W_,239)-DYNX(W_,231);
DYNX(W_,240) = IF 1.5-DYNX(W_,217) > 0.01 THEN 1 ELSE IF 1.5-DYNX(W_,217) < 
  -0.01 THEN 0 ELSE 0.5-25.0*(1.5-DYNX(W_,217))*(sqr(100.0*(1.5-DYNX(W_,217)))-3);
DYNX(W_,233) = DYNX(W_,240)-DYNX(W_,239);
DYNX(W_,241) = IF 1.95-DYNX(W_,217) > 0.01 THEN 1 ELSE IF 1.95-DYNX(W_,217) < 
  -0.01 THEN 0 ELSE 0.5-25.0*(1.95-DYNX(W_,217))*(sqr(100.0*(1.95-DYNX(W_,217)))
  -3);
DYNX(W_,234) = DYNX(W_,241)-DYNX(W_,240);
DYNX(W_,242) = IF 2.8-DYNX(W_,217) > 0.01 THEN 1 ELSE IF 2.8-DYNX(W_,217) < 
  -0.01 THEN 0 ELSE 0.5-25.0*(2.8-DYNX(W_,217))*(sqr(100.0*(2.8-DYNX(W_,217)))-3);
DYNX(W_,235) = DYNX(W_,242)-DYNX(W_,241);
DYNX(W_,243) = IF 4.5-DYNX(W_,217) > 0.01 THEN 1 ELSE IF 4.5-DYNX(W_,217) < 
  -0.01 THEN 0 ELSE 0.5-25.0*(4.5-DYNX(W_,217))*(sqr(100.0*(4.5-DYNX(W_,217)))-3);
DYNX(W_,236) = DYNX(W_,243)-DYNX(W_,242);
DYNX(W_,244) = IF 6.2-DYNX(W_,217) > 0.01 THEN 1 ELSE IF 6.2-DYNX(W_,217) < 
  -0.01 THEN 0 ELSE 0.5-25.0*(6.2-DYNX(W_,217))*(sqr(100.0*(6.2-DYNX(W_,217)))-3);
DYNX(W_,237) = DYNX(W_,244)-DYNX(W_,243);
DYNX(W_,238) = IF DYNX(W_,217)-6.2 > 0.01 THEN 1 ELSE IF DYNX(W_,217)-6.2 < 
  -0.01 THEN 0 ELSE 0.5-25.0*(DYNX(W_,217)-6.2)*(sqr(100.0*(DYNX(W_,217)-6.2))-3);
DYNX(W_,224) = 0.1299457*DYNX(W_,232)-0.0083117*DYNX(W_,231)+0.3296958*
  DYNX(W_,233)+0.5682053*DYNX(W_,234)+0.873028*DYNX(W_,235)+1.1326077*
  DYNX(W_,236)+1.0601591*DYNX(W_,237)+0.677747*DYNX(W_,238);
DYNX(W_,225) = 0.5877285*DYNX(W_,231)+0.6825954*DYNX(W_,232)+0.4868735*
  DYNX(W_,233)+0.1874525*DYNX(W_,234)-0.3920403*DYNX(W_,235)-1.2367284*
  DYNX(W_,236)-1.5999137*DYNX(W_,237)-0.3272588*DYNX(W_,238);
DYNX(W_,246) = IF 1.5707963267948966-DYNX(W_,160) > 0.01 THEN DYNX(W_,160) ELSE 
  IF 1.5707963267948966-DYNX(W_,160) < -0.01 THEN 1.5707963267948966 ELSE 
  0.7853981633974483+25.0*(1.5707963267948966-DYNX(W_,160))*(sqr(100.0*(
  1.5707963267948966-DYNX(W_,160)))-3)*(1.5707963267948966-DYNX(W_,160))+0.5*
  DYNX(W_,160);
DYNX(W_,247) = 0.3183098861837907*DYNX(W_,246)*180;
DYNX(W_,245) = divmacro(1,"1",cos(DYNX(W_,246))+0.15*powmacro(93.9-DYNX(W_,247),
  "93.9-building.HDifTil[1].relAirMas.zenDeg",-1.253,"-1.253"),"cos(building.HDifTil[1].relAirMas.zenLim)+0.15*(93.9-building.HDifTil[1].relAirMas.zenDeg)^(-1.253)");
DYNX(W_,223) = IF 1-0.000731528895391368*DYNX(W_,88)*DYNX(W_,245) > 0.025 THEN 
  0.000731528895391368*DYNX(W_,88)*DYNX(W_,245) ELSE IF 1-0.000731528895391368*
  DYNX(W_,88)*DYNX(W_,245) < -0.025 THEN 1 ELSE 0.5+10.0*(1-0.000731528895391368
  *DYNX(W_,88)*DYNX(W_,245))*(sqr(40.0*(1-0.000731528895391368*DYNX(W_,88)*
  DYNX(W_,245)))-3)*(1-0.000731528895391368*DYNX(W_,88)*DYNX(W_,245))+
  0.000365764447695684*DYNX(W_,88)*DYNX(W_,245);
DYNX(W_,226) = (-0.0620636)*DYNX(W_,231)-0.1513725*DYNX(W_,232)-0.2210958*
  DYNX(W_,233)-0.295129*DYNX(W_,234)-0.3616149*DYNX(W_,235)-0.4118494*
  DYNX(W_,236)-0.3589221*DYNX(W_,237)-0.2504286*DYNX(W_,238);
DYNX(W_,211) = IF  -(DYNX(W_,224)+DYNX(W_,225)*DYNX(W_,223)+DYNX(W_,226)*
  DYNX(W_,160)) > 0.01 THEN 0 ELSE IF  -(DYNX(W_,224)+DYNX(W_,225)*DYNX(W_,223)+
  DYNX(W_,226)*DYNX(W_,160)) < -0.01 THEN DYNX(W_,224)+DYNX(W_,225)*DYNX(W_,223)
  +DYNX(W_,226)*DYNX(W_,160) ELSE 0.5*(DYNX(W_,224)+DYNX(W_,225)*DYNX(W_,223)+
  DYNX(W_,226)*DYNX(W_,160))-25.0*(DYNX(W_,224)+DYNX(W_,225)*DYNX(W_,223)+
  DYNX(W_,226)*DYNX(W_,160))*(sqr((-100.0)*(DYNX(W_,224)+DYNX(W_,225)*
  DYNX(W_,223)+DYNX(W_,226)*DYNX(W_,160)))-3)*(DYNX(W_,224)+DYNX(W_,225)*
  DYNX(W_,223)+DYNX(W_,226)*DYNX(W_,160));
DYNX(W_,251) = asinGuarded((-0.3979486313076103)*cos(0.17202423838958483+
  1.9910212776572317E-07*DYNX(W_,106)),"(-0.3979486313076103)*cos(0.17202423838958483+1.9910212776572317E-07*weaDat.modTim.y)");
DYNX(W_,258) = cos(DYNX(W_,251));
DYNX(W_,254) = 0.2617993877991494*(0.0002777777777777778*DYNX(W_,138)-12);
DYNX(W_,260) = cos(DYNX(W_,254));
DYNX(W_,259) = sin(DYNX(W_,251));
DYNX(W_,261) = sin(DYNX(W_,254));
DYNX(W_,213) = acosGuarded(cos(DYNX(W_,257))*(DYNX(W_,258)*DYNX(W_,260)*
  DYNX(W_,262)+DYNX(W_,259)*DYNX(W_,263))+sin(DYNX(W_,257))*(sin(DYNX(W_,256))*
  DYNX(W_,258)*DYNX(W_,261)+cos(DYNX(W_,256))*(DYNX(W_,258)*DYNX(W_,260)*
  DYNX(W_,263)-DYNX(W_,259)*DYNX(W_,262))),"cos(building.HDifTil[1].incAng.incAng.til)*(building.HDifTil[1].incAng.incAng.dec_c*building.HDifTil[1].incAng.incAng.sol_c*building.HDifTil[1].incAng.incAng.lat_c+building.HDifTil[1].incAng.incAng.dec_s*building.HDifTil[1].incAng.incAng.lat_s)+sin(building.HDifTil[1].incAng.incAng.til)*(sin(building.HDifTil[1].incAng.incAng.azi)*building.HDifTil[1].incAng.incAng.dec_c*building.HDifTil[1].incAn...");
DYNX(W_,214) = IF  -cos(DYNX(W_,213)) > 0.01 THEN 0 ELSE IF  -cos(DYNX(W_,213))
   < -0.01 THEN cos(DYNX(W_,213)) ELSE 0.5*cos(DYNX(W_,213))-25.0*cos(
  DYNX(W_,213))*(sqr((-100.0)*cos(DYNX(W_,213)))-3)*cos(DYNX(W_,213));
DYNX(W_,215) = IF 0.08715574274765814-cos(DYNX(W_,160)) > 0.01 THEN 
  0.08715574274765814 ELSE IF 0.08715574274765814-cos(DYNX(W_,160)) < -0.01
   THEN cos(DYNX(W_,160)) ELSE 0.04357787137382907+25.0*(0.08715574274765814-cos
  (DYNX(W_,160)))*(sqr(100.0*(0.08715574274765814-cos(DYNX(W_,160))))-3)*(cos(
  DYNX(W_,160))-0.08715574274765814)+0.5*cos(DYNX(W_,160));
DYNX(W_,227) = (-0.0596012)*DYNX(W_,231)-0.0189325*DYNX(W_,232)+0.055414*
  DYNX(W_,233)+0.1088631*DYNX(W_,234)+0.2255647*DYNX(W_,235)+0.2877813*
  DYNX(W_,236)+0.2642124*DYNX(W_,237)+0.1561313*DYNX(W_,238);
DYNX(W_,228) = 0.0721249*DYNX(W_,231)+0.065965*DYNX(W_,232)-0.0639588*
  DYNX(W_,233)-0.1519229*DYNX(W_,234)-0.4620442*DYNX(W_,235)-0.8230357*
  DYNX(W_,236)-1.127234*DYNX(W_,237)-1.3765031*DYNX(W_,238);
DYNX(W_,229) = (-0.0220216)*DYNX(W_,231)-0.0288748*DYNX(W_,232)-0.0260542*
  DYNX(W_,233)-0.0139754*DYNX(W_,234)+0.0012448*DYNX(W_,235)+0.0558651*
  DYNX(W_,236)+0.1310694*DYNX(W_,237)+0.2506212*DYNX(W_,238);
DYNX(W_,212) = DYNX(W_,227)+DYNX(W_,228)*DYNX(W_,223)+DYNX(W_,229)*DYNX(W_,160);
DYNX(W_,355) = DYNX(W_,88)*(0.5*(1-DYNX(W_,211))*(1+cos(DYNX(W_,210)))+divmacro(
  DYNX(W_,211)*DYNX(W_,214),"building.HDifTil[1].HDifTil.briCof1*building.HDifTil[1].HDifTil.a",
  DYNX(W_,215),"building.HDifTil[1].HDifTil.b")+DYNX(W_,212)*sin(DYNX(W_,210)));
DYNX(W_,359) = 0.5*DYNX(W_,86)*DYNX(W_,209)*(1-cos(DYNX(W_,210)));
DYNX(W_,363) = DYNX(W_,357)*DYNX(W_,401)+DYNX(W_,355)*DYNX(W_,375)+DYNX(W_,359)*
  DYNX(W_,376);
DYNX(W_,1404) = DYNX(W_,469)*DYNX(W_,363);
DYNX(W_,341) = asinGuarded((-0.3979486313076103)*cos(0.17202423838958483+
  1.9910212776572317E-07*DYNX(W_,106)),"(-0.3979486313076103)*cos(0.17202423838958483+1.9910212776572317E-07*weaDat.modTim.y)");
DYNX(W_,348) = cos(DYNX(W_,341));
DYNX(W_,344) = 0.2617993877991494*(0.0002777777777777778*DYNX(W_,138)-12);
DYNX(W_,350) = cos(DYNX(W_,344));
DYNX(W_,349) = sin(DYNX(W_,341));
DYNX(W_,351) = sin(DYNX(W_,344));
DYNX(W_,362) = acosGuarded(cos(DYNX(W_,347))*(DYNX(W_,348)*DYNX(W_,350)*
  DYNX(W_,352)+DYNX(W_,349)*DYNX(W_,353))+sin(DYNX(W_,347))*(sin(DYNX(W_,346))*
  DYNX(W_,348)*DYNX(W_,351)+cos(DYNX(W_,346))*(DYNX(W_,348)*DYNX(W_,350)*
  DYNX(W_,353)-DYNX(W_,349)*DYNX(W_,352))),"cos(building.HDirTil[2].incAng.incAng.til)*(building.HDirTil[2].incAng.incAng.dec_c*building.HDirTil[2].incAng.incAng.sol_c*building.HDirTil[2].incAng.incAng.lat_c+building.HDirTil[2].incAng.incAng.dec_s*building.HDirTil[2].incAng.incAng.lat_s)+sin(building.HDirTil[2].incAng.incAng.til)*(sin(building.HDirTil[2].incAng.incAng.azi)*building.HDirTil[2].incAng.incAng.dec_c*building.HDirTil[2].incAn...");
DYNX(W_,358) = RealBmax(0, cos(DYNX(W_,362))*DYNX(W_,90));
DYNX(W_,378) = 57.29577951308232*(57.29577951308232*(57.29577951308232*(
  57.29577951308232*(57.29577951308232*(57.29577951308232*DYNX(DP_,54)*
  DYNX(W_,362)+DYNX(DP_,53))*DYNX(W_,362)+DYNX(DP_,52))*DYNX(W_,362)+
  DYNX(DP_,51))*DYNX(W_,362)+DYNX(DP_,50))*DYNX(W_,362)+DYNX(DP_,49))*
  DYNX(W_,362)+DYNX(DP_,48);
DYNX(W_,380) = powmacro(0.907,"0.907",divmacro(1,"1",sqrtGuarded(1-sqr(
  0.6600660066006601*sin(DYNX(W_,362))),"1-(0.6600660066006601*sin(building.corGDouPan.inc[2]))^2"),
  "sqrt(1-(0.6600660066006601*sin(building.corGDouPan.inc[2]))^2)"),
  "1/sqrt(1-(0.6600660066006601*sin(building.corGDouPan.inc[2]))^2)");
DYNX(W_,382) = DYNX(W_,378)*DYNX(W_,380);
DYNX(W_,384) = 1-DYNX(W_,378);
DYNX(W_,386) = divmacro(DYNX(W_,384),"building.corGDouPan.rho_T1_dir[2]",2-
  DYNX(W_,384),"2-building.corGDouPan.rho_T1_dir[2]");
DYNX(W_,388) = DYNX(W_,386)+divmacro(sqr((1-DYNX(W_,386))*DYNX(W_,380))*
  DYNX(W_,386),"((1-building.corGDouPan.rho_11_dir[2])*building.corGDouPan.Tai_dir[2])^2*building.corGDouPan.rho_11_dir[2]",1
  -sqr(DYNX(W_,386)*DYNX(W_,380)),"1-(building.corGDouPan.rho_11_dir[2]*building.corGDouPan.Tai_dir[2])^2");
DYNX(W_,390) = 1.0-sqr(DYNX(W_,388));
DYNX(W_,392) = divmacro(sqr(DYNX(W_,382)),"building.corGDouPan.Ta1_dir[2]^2",
  DYNX(W_,390),"building.corGDouPan.XN2_dir[2]");
DYNX(W_,394) = 1-(DYNX(W_,382)+DYNX(W_,388));
DYNX(W_,396) = 0.04*DYNX(W_,394)*(1+divmacro(DYNX(W_,382)*DYNX(W_,388),
  "building.corGDouPan.Ta1_dir[2]*building.corGDouPan.rho_1_dir[2]",DYNX(W_,390),
  "building.corGDouPan.XN2_dir[2]"))*DYNX(DP_,47);
DYNX(W_,398) = divmacro(DYNX(W_,394)*DYNX(W_,382)*(1-DYNX(DP_,47)/(double)(7.7)),
  "building.corGDouPan.a1_dir[2]*building.corGDouPan.Ta1_dir[2]*(1-building.corGDouPan.UWin/7.7)",
  DYNX(W_,390),"building.corGDouPan.XN2_dir[2]");
DYNX(W_,400) = DYNX(W_,396)+DYNX(W_,398);
DYNX(W_,402) = divmacro(DYNX(W_,392)+DYNX(W_,400),"building.corGDouPan.Ta2_dir[2]+building.corGDouPan.Qsek2_dir[2]",
  DYNX(DP_,55),"building.corGDouPan.g_dir0");
DYNX(W_,280) = IF DYNX(W_,88)-5E-05 > 2.5E-05 THEN DYNX(W_,88) ELSE IF 
  DYNX(W_,88)-5E-05 < -2.5E-05 THEN 5E-05 ELSE 2.5E-05+10000.0*(DYNX(W_,88)-
  5E-05)*(sqr(40000.0*(DYNX(W_,88)-5E-05))-3)*(5E-05-DYNX(W_,88))+0.5*
  DYNX(W_,88);
DYNX(W_,279) = 1.040895310738997*powmacro2(DYNX(W_,160),"weaDat.altAng.zen",3,
  "3");
DYNX(W_,275) = (PushModelContext(1,"Buildings.Utilities.Math.Functions.smoothLimit((weaDat.cheGloHorRad.HOut/building.HDifTil[2].skyCle.HDifHorBou+building.HDifTil[2].skyCle.tmp1)/(1+building.HDifTil[2].skyCle.tmp1), 1, 8, 0.01)")
  Buildings_Utilities_Math_Functions_smoothLimit(divmacro(divmacro(DYNX(W_,86),
  "weaDat.cheGloHorRad.HOut",DYNX(W_,280),"building.HDifTil[2].skyCle.HDifHorBou")
  +DYNX(W_,279),"weaDat.cheGloHorRad.HOut/building.HDifTil[2].skyCle.HDifHorBou+building.HDifTil[2].skyCle.tmp1",1
  +DYNX(W_,279),"1+building.HDifTil[2].skyCle.tmp1"), 1, 8, 0.01));
PopModelContext();
DYNX(W_,297) = IF 1.23-DYNX(W_,275) > 0.01 THEN 1 ELSE IF 1.23-DYNX(W_,275) < 
  -0.01 THEN 0 ELSE 0.5-25.0*(1.23-DYNX(W_,275))*(sqr(100.0*(1.23-DYNX(W_,275)))
  -3);
DYNX(W_,289) = IF 1.065-DYNX(W_,275) > 0.01 THEN 1 ELSE IF 1.065-DYNX(W_,275) < 
  -0.01 THEN 0 ELSE 0.5-25.0*(1.065-DYNX(W_,275))*(sqr(100.0*(1.065-DYNX(W_,275)))
  -3);
DYNX(W_,290) = DYNX(W_,297)-DYNX(W_,289);
DYNX(W_,298) = IF 1.5-DYNX(W_,275) > 0.01 THEN 1 ELSE IF 1.5-DYNX(W_,275) < 
  -0.01 THEN 0 ELSE 0.5-25.0*(1.5-DYNX(W_,275))*(sqr(100.0*(1.5-DYNX(W_,275)))-3);
DYNX(W_,291) = DYNX(W_,298)-DYNX(W_,297);
DYNX(W_,299) = IF 1.95-DYNX(W_,275) > 0.01 THEN 1 ELSE IF 1.95-DYNX(W_,275) < 
  -0.01 THEN 0 ELSE 0.5-25.0*(1.95-DYNX(W_,275))*(sqr(100.0*(1.95-DYNX(W_,275)))
  -3);
DYNX(W_,292) = DYNX(W_,299)-DYNX(W_,298);
DYNX(W_,300) = IF 2.8-DYNX(W_,275) > 0.01 THEN 1 ELSE IF 2.8-DYNX(W_,275) < 
  -0.01 THEN 0 ELSE 0.5-25.0*(2.8-DYNX(W_,275))*(sqr(100.0*(2.8-DYNX(W_,275)))-3);
DYNX(W_,293) = DYNX(W_,300)-DYNX(W_,299);
DYNX(W_,301) = IF 4.5-DYNX(W_,275) > 0.01 THEN 1 ELSE IF 4.5-DYNX(W_,275) < 
  -0.01 THEN 0 ELSE 0.5-25.0*(4.5-DYNX(W_,275))*(sqr(100.0*(4.5-DYNX(W_,275)))-3);
DYNX(W_,294) = DYNX(W_,301)-DYNX(W_,300);
DYNX(W_,302) = IF 6.2-DYNX(W_,275) > 0.01 THEN 1 ELSE IF 6.2-DYNX(W_,275) < 
  -0.01 THEN 0 ELSE 0.5-25.0*(6.2-DYNX(W_,275))*(sqr(100.0*(6.2-DYNX(W_,275)))-3);
DYNX(W_,295) = DYNX(W_,302)-DYNX(W_,301);
DYNX(W_,296) = IF DYNX(W_,275)-6.2 > 0.01 THEN 1 ELSE IF DYNX(W_,275)-6.2 < 
  -0.01 THEN 0 ELSE 0.5-25.0*(DYNX(W_,275)-6.2)*(sqr(100.0*(DYNX(W_,275)-6.2))-3);
DYNX(W_,282) = 0.1299457*DYNX(W_,290)-0.0083117*DYNX(W_,289)+0.3296958*
  DYNX(W_,291)+0.5682053*DYNX(W_,292)+0.873028*DYNX(W_,293)+1.1326077*
  DYNX(W_,294)+1.0601591*DYNX(W_,295)+0.677747*DYNX(W_,296);
DYNX(W_,283) = 0.5877285*DYNX(W_,289)+0.6825954*DYNX(W_,290)+0.4868735*
  DYNX(W_,291)+0.1874525*DYNX(W_,292)-0.3920403*DYNX(W_,293)-1.2367284*
  DYNX(W_,294)-1.5999137*DYNX(W_,295)-0.3272588*DYNX(W_,296);
DYNX(W_,304) = IF 1.5707963267948966-DYNX(W_,160) > 0.01 THEN DYNX(W_,160) ELSE 
  IF 1.5707963267948966-DYNX(W_,160) < -0.01 THEN 1.5707963267948966 ELSE 
  0.7853981633974483+25.0*(1.5707963267948966-DYNX(W_,160))*(sqr(100.0*(
  1.5707963267948966-DYNX(W_,160)))-3)*(1.5707963267948966-DYNX(W_,160))+0.5*
  DYNX(W_,160);
DYNX(W_,305) = 0.3183098861837907*DYNX(W_,304)*180;
DYNX(W_,303) = divmacro(1,"1",cos(DYNX(W_,304))+0.15*powmacro(93.9-DYNX(W_,305),
  "93.9-building.HDifTil[2].relAirMas.zenDeg",-1.253,"-1.253"),"cos(building.HDifTil[2].relAirMas.zenLim)+0.15*(93.9-building.HDifTil[2].relAirMas.zenDeg)^(-1.253)");
DYNX(W_,281) = IF 1-0.000731528895391368*DYNX(W_,88)*DYNX(W_,303) > 0.025 THEN 
  0.000731528895391368*DYNX(W_,88)*DYNX(W_,303) ELSE IF 1-0.000731528895391368*
  DYNX(W_,88)*DYNX(W_,303) < -0.025 THEN 1 ELSE 0.5+10.0*(1-0.000731528895391368
  *DYNX(W_,88)*DYNX(W_,303))*(sqr(40.0*(1-0.000731528895391368*DYNX(W_,88)*
  DYNX(W_,303)))-3)*(1-0.000731528895391368*DYNX(W_,88)*DYNX(W_,303))+
  0.000365764447695684*DYNX(W_,88)*DYNX(W_,303);
DYNX(W_,284) = (-0.0620636)*DYNX(W_,289)-0.1513725*DYNX(W_,290)-0.2210958*
  DYNX(W_,291)-0.295129*DYNX(W_,292)-0.3616149*DYNX(W_,293)-0.4118494*
  DYNX(W_,294)-0.3589221*DYNX(W_,295)-0.2504286*DYNX(W_,296);
DYNX(W_,269) = IF  -(DYNX(W_,282)+DYNX(W_,283)*DYNX(W_,281)+DYNX(W_,284)*
  DYNX(W_,160)) > 0.01 THEN 0 ELSE IF  -(DYNX(W_,282)+DYNX(W_,283)*DYNX(W_,281)+
  DYNX(W_,284)*DYNX(W_,160)) < -0.01 THEN DYNX(W_,282)+DYNX(W_,283)*DYNX(W_,281)
  +DYNX(W_,284)*DYNX(W_,160) ELSE 0.5*(DYNX(W_,282)+DYNX(W_,283)*DYNX(W_,281)+
  DYNX(W_,284)*DYNX(W_,160))-25.0*(DYNX(W_,282)+DYNX(W_,283)*DYNX(W_,281)+
  DYNX(W_,284)*DYNX(W_,160))*(sqr((-100.0)*(DYNX(W_,282)+DYNX(W_,283)*
  DYNX(W_,281)+DYNX(W_,284)*DYNX(W_,160)))-3)*(DYNX(W_,282)+DYNX(W_,283)*
  DYNX(W_,281)+DYNX(W_,284)*DYNX(W_,160));
DYNX(W_,309) = asinGuarded((-0.3979486313076103)*cos(0.17202423838958483+
  1.9910212776572317E-07*DYNX(W_,106)),"(-0.3979486313076103)*cos(0.17202423838958483+1.9910212776572317E-07*weaDat.modTim.y)");
DYNX(W_,316) = cos(DYNX(W_,309));
DYNX(W_,312) = 0.2617993877991494*(0.0002777777777777778*DYNX(W_,138)-12);
DYNX(W_,318) = cos(DYNX(W_,312));
DYNX(W_,317) = sin(DYNX(W_,309));
DYNX(W_,319) = sin(DYNX(W_,312));
DYNX(W_,271) = acosGuarded(cos(DYNX(W_,315))*(DYNX(W_,316)*DYNX(W_,318)*
  DYNX(W_,320)+DYNX(W_,317)*DYNX(W_,321))+sin(DYNX(W_,315))*(sin(DYNX(W_,314))*
  DYNX(W_,316)*DYNX(W_,319)+cos(DYNX(W_,314))*(DYNX(W_,316)*DYNX(W_,318)*
  DYNX(W_,321)-DYNX(W_,317)*DYNX(W_,320))),"cos(building.HDifTil[2].incAng.incAng.til)*(building.HDifTil[2].incAng.incAng.dec_c*building.HDifTil[2].incAng.incAng.sol_c*building.HDifTil[2].incAng.incAng.lat_c+building.HDifTil[2].incAng.incAng.dec_s*building.HDifTil[2].incAng.incAng.lat_s)+sin(building.HDifTil[2].incAng.incAng.til)*(sin(building.HDifTil[2].incAng.incAng.azi)*building.HDifTil[2].incAng.incAng.dec_c*building.HDifTil[2].incAn...");
DYNX(W_,272) = IF  -cos(DYNX(W_,271)) > 0.01 THEN 0 ELSE IF  -cos(DYNX(W_,271))
   < -0.01 THEN cos(DYNX(W_,271)) ELSE 0.5*cos(DYNX(W_,271))-25.0*cos(
  DYNX(W_,271))*(sqr((-100.0)*cos(DYNX(W_,271)))-3)*cos(DYNX(W_,271));
DYNX(W_,273) = IF 0.08715574274765814-cos(DYNX(W_,160)) > 0.01 THEN 
  0.08715574274765814 ELSE IF 0.08715574274765814-cos(DYNX(W_,160)) < -0.01
   THEN cos(DYNX(W_,160)) ELSE 0.04357787137382907+25.0*(0.08715574274765814-cos
  (DYNX(W_,160)))*(sqr(100.0*(0.08715574274765814-cos(DYNX(W_,160))))-3)*(cos(
  DYNX(W_,160))-0.08715574274765814)+0.5*cos(DYNX(W_,160));
DYNX(W_,285) = (-0.0596012)*DYNX(W_,289)-0.0189325*DYNX(W_,290)+0.055414*
  DYNX(W_,291)+0.1088631*DYNX(W_,292)+0.2255647*DYNX(W_,293)+0.2877813*
  DYNX(W_,294)+0.2642124*DYNX(W_,295)+0.1561313*DYNX(W_,296);
DYNX(W_,286) = 0.0721249*DYNX(W_,289)+0.065965*DYNX(W_,290)-0.0639588*
  DYNX(W_,291)-0.1519229*DYNX(W_,292)-0.4620442*DYNX(W_,293)-0.8230357*
  DYNX(W_,294)-1.127234*DYNX(W_,295)-1.3765031*DYNX(W_,296);
DYNX(W_,287) = (-0.0220216)*DYNX(W_,289)-0.0288748*DYNX(W_,290)-0.0260542*
  DYNX(W_,291)-0.0139754*DYNX(W_,292)+0.0012448*DYNX(W_,293)+0.0558651*
  DYNX(W_,294)+0.1310694*DYNX(W_,295)+0.2506212*DYNX(W_,296);
DYNX(W_,270) = DYNX(W_,285)+DYNX(W_,286)*DYNX(W_,281)+DYNX(W_,287)*DYNX(W_,160);
DYNX(W_,356) = DYNX(W_,88)*(0.5*(1-DYNX(W_,269))*(1+cos(DYNX(W_,268)))+divmacro(
  DYNX(W_,269)*DYNX(W_,272),"building.HDifTil[2].HDifTil.briCof1*building.HDifTil[2].HDifTil.a",
  DYNX(W_,273),"building.HDifTil[2].HDifTil.b")+DYNX(W_,270)*sin(DYNX(W_,268)));
DYNX(W_,360) = 0.5*DYNX(W_,86)*DYNX(W_,267)*(1-cos(DYNX(W_,268)));
DYNX(W_,364) = DYNX(W_,358)*DYNX(W_,402)+DYNX(W_,356)*DYNX(W_,375)+DYNX(W_,360)*
  DYNX(W_,376);
DYNX(W_,1406) = DYNX(W_,470)*DYNX(W_,364);
DYNX(W_,1408) =  -(DYNX(W_,1404)*DYNX(W_,1401)+DYNX(W_,1406)*DYNX(W_,1402));
DYNX(W_,188) = 298.15+0.0009945795414988312*DYNX(W_,446);
DYNX(W_,1407) =  -(DYNX(W_,1404)*DYNX(W_,1399)+DYNX(W_,1406)*DYNX(W_,1400));
DYNX(W_,488) = divmacro((DYNX(W_,144)-DYNX(W_,142))*DYNX(DP_,79),
  "(weaDat.TBlaSky_in_internal-weaDat.TDryBul_in_internal)*building.eqAirTemp.hRad",
  DYNX(DP_,79)+DYNX(DP_,78),"building.eqAirTemp.hRad+building.eqAirTemp.hConWallOut");
DYNX(W_,206) = DYNX(DP_,33)*DYNX(W_,355)+DYNX(DP_,34)*DYNX(W_,359);
DYNX(W_,492) = DYNX(DP_,81)*DYNX(W_,357)+DYNX(DP_,82)*DYNX(W_,206);
DYNX(W_,490) = divmacro(DYNX(DP_,71)*DYNX(W_,492),"building.eqAirTemp.aExt*building.eqAirTemp.HSol[1]",
  DYNX(DP_,79)+DYNX(DP_,78),"building.eqAirTemp.hRad+building.eqAirTemp.hConWallOut");
DYNX(W_,484) = DYNX(W_,142)+DYNX(W_,488)+DYNX(W_,490);
DYNX(W_,264) = DYNX(DP_,39)*DYNX(W_,356)+DYNX(DP_,40)*DYNX(W_,360);
DYNX(W_,493) = DYNX(DP_,83)*DYNX(W_,358)+DYNX(DP_,84)*DYNX(W_,264);
DYNX(W_,491) = divmacro(DYNX(DP_,71)*DYNX(W_,493),"building.eqAirTemp.aExt*building.eqAirTemp.HSol[2]",
  DYNX(DP_,79)+DYNX(DP_,78),"building.eqAirTemp.hRad+building.eqAirTemp.hConWallOut");
DYNX(W_,485) = DYNX(W_,142)+DYNX(W_,488)+DYNX(W_,491);
DYNX(W_,494) = DYNX(W_,484)*DYNX(DP_,72)+DYNX(W_,485)*DYNX(DP_,73)+DYNX(DP_,77)*
  DYNX(DP_,76);

 /* Linear system of equations to solve. */
/* Tag: initialization.linear[1] */
/* Introducing 18 common subexpressions used in 18 expressions */
/* Of the common subexpressions 18 are reals, 0 are integers, and 0
   are booleans. */
DYNX(DYNhelp,8) = DYNX(W_,502)*DYNX(DP_,86);
DYNX(DYNhelp,9) = DYNX(DYNhelp,8)*DYNX(W_,1419);
DYNX(DYNhelp,10) = DYNX(W_,475)*DYNX(W_,1419);
DYNX(DYNhelp,11) = 0.20338331410995772*DYNX(DYNhelp,9)-DYNX(DYNhelp,10);
DYNX(DYNhelp,12) = DYNX(DYNhelp,11)-1.0;
DYNX(DYNhelp,13) = DYNX(DP_,204)*DYNX(W_,1421);
DYNX(DYNhelp,14) = 0.24759707804690506*DYNX(DYNhelp,9)+DYNX(DYNhelp,10);
DYNX(DYNhelp,15) = DYNX(W_,1387)*DYNX(DYNhelp,14);
DYNX(DYNhelp,16) = DYNX(DP_,242)*DYNX(DYNhelp,15);
DYNX(DYNhelp,17) = 1-DYNX(DP_,86)*DYNX(DP_,85);
DYNX(DYNhelp,18) = DYNX(W_,502)*DYNX(DYNhelp,17);
DYNX(DYNhelp,19) = (-0.24759707804690506)*DYNX(DYNhelp,8)-DYNX(W_,475);
DYNX(DYNhelp,20) = DYNX(W_,468)-0.3014225297962323*DYNX(DYNhelp,8)+DYNX(W_,475);
DYNX(DYNhelp,21) = DYNX(DP_,242)*(1.0+DYNX(W_,1387)*DYNX(DYNhelp,20));
DYNX(DYNhelp,22) = DYNX(W_,475)-0.20338331410995772*DYNX(DYNhelp,8);
DYNX(DYNhelp,23) = DYNX(DYNhelp,22)*DYNX(W_,188);
DYNX(DYNhelp,24) = DYNX(DP_,204)*DYNX(W_,494);
DYNX(DYNhelp,25) = DYNX(DP_,242)*DYNX(W_,1387)*DYNX(DYNhelp,19);
/* Automatic tearing of linear system of 23 simultaneous equations
gave a linear system of 3 equations for numerical solution.*/
{
  const char*const varnames_[]={"building.theConWall.solid.T", "building.theConWin.solid.T",
     "building.thermalZoneOneElement.convExtWall.dT"};
  const double nominal_[]={300.0, 300.0, 1};
  DidLinearSystemOfEquations(J, b, y, 3, DYNX(DYNhelp,26), 42, DYNX(did_->helpvari_vec,2), 10);
  /* Jacobian depending on continuous variables */
  SetNeedFactor(J);
  if (NeedFactor(J)) {
    MatrixZeros(J);
    SetMatrixLeading(J, 1, 1, 3, 1.0+DYNX(DYNhelp,13));
    SetMatrixLeading(J, 1, 2, 3, DYNX(DYNhelp,16)+DYNX(DYNhelp,14));
    SetMatrixLeading(J, 1, 3, 3, DYNX(DYNhelp,11)-DYNX(W_,1419)*DYNX(W_,464)-1.0);
    SetMatrixLeading(J, 2, 2, 3, DYNX(DYNhelp,21)+DYNX(DYNhelp,20));
    SetMatrixLeading(J, 2, 3, 3, DYNX(DYNhelp,19));
    SetMatrixLeading(J, 3, 1, 3, DYNX(DP_,204));
    SetMatrixLeading(J, 3, 2, 3, DYNX(DYNhelp,25)+DYNX(DYNhelp,19));
    SetMatrixLeading(J, 3, 3, 3, DYNX(DYNhelp,22)+DYNX(W_,464));
  }
  SetVector(b, 1, DYNX(W_,1419)*DYNX(W_,1407)-(DYNX(DYNhelp,12)*DYNX(W_,188)-
    DYNX(DYNhelp,13)*DYNX(W_,494)-DYNX(DYNhelp,16)*DYNX(W_,495)+0.45098039215686275
    *DYNX(W_,1419)*DYNX(DYNhelp,18)));
  SetVector(b, 2,  -(DYNX(W_,1408)+DYNX(DYNhelp,19)*DYNX(W_,188)-
    DYNX(DYNhelp,21)*DYNX(W_,495)-0.5490196078431373*DYNX(DYNhelp,18)-
    DYNX(W_,468)*DYNX(W_,188)));
  SetVector(b, 3,  -(DYNX(W_,1417)+DYNX(DYNhelp,23)-DYNX(DYNhelp,24)-
    DYNX(DYNhelp,25)*DYNX(W_,495)-0.45098039215686275*DYNX(DYNhelp,18)+
    DYNX(W_,1407)));
  SetVector(y, 1, 288.15);
  SetVector(y, 2, 288.15);
  SetVector(y, 3, 0);
  SolveLinearSystemOfEquations(J, b, y, 1);
  DYNX(W_,501) = GetVector(y, 1);
  DYNX(W_,499) = GetVector(y, 2);
  DYNX(W_,462) = GetVector(y, 3);
  EndStaticLinearSystemOfEquations(J);
}
DYNX(W_,500) = DYNX(W_,501)-DYNX(W_,494);
DYNX(W_,463) = DYNX(W_,462)+DYNX(W_,188);
DYNX(W_,498) = DYNX(W_,499)-DYNX(W_,495);
DYNX(W_,497) = DYNX(DP_,242)*DYNX(W_,498);
DYNX(W_,1386) =  -DYNX(W_,1387)*DYNX(W_,497);
DYNX(W_,467) = DYNX(W_,499)-DYNX(W_,1386);
DYNX(W_,503) = 0.45098039215686275*DYNX(W_,463)+0.5490196078431373*DYNX(W_,467);
DYNX(W_,504) =  -DYNX(W_,502)*(1+DYNX(DP_,86)*(DYNX(W_,503)-DYNX(DP_,85)));
DYNX(W_,1395) = 0.45098039215686275*DYNX(W_,504);
DYNX(W_,1396) = 0.5490196078431373*DYNX(W_,504);
DYNX(W_,466) = DYNX(W_,467)-DYNX(W_,188);
DYNX(W_,465) = DYNX(W_,468)*DYNX(W_,466);
DYNX(W_,474) = DYNX(W_,467)-DYNX(W_,463);
DYNX(W_,473) = DYNX(W_,475)*DYNX(W_,474);
DYNX(W_,461) = DYNX(W_,464)*DYNX(W_,462);
DYNX(W_,1414) =  -(DYNX(W_,461)-DYNX(W_,473)+DYNX(W_,1395)+DYNX(W_,1407));
DYNX(W_,1418) = DYNX(W_,1419)*DYNX(W_,1414);
DYNX(W_,496) = DYNX(DP_,204)*DYNX(W_,500);
DYNX(W_,1420) = DYNX(W_,1421)*DYNX(W_,496);
DYNX(X_,15) = DYNX(W_,463)-DYNX(W_,1418);
 /* End of Equation Block */ 

DYNX(X_,16) = DYNX(W_,1424);
DYNX(X_,17) = DYNX(W_,1430);
InitialBoundSection
DYNX(Aux_,37) = DYNX(W_,985);
InitialSection2
DYNX(W_,970) = homotopy(DYNX(DP_,292)+DYNX(W_,952)*powmacro(DYNX(W_,952)*
  DYNX(W_,952)+DYNX(DP_,294)*DYNX(DP_,294),"coo.val.y_actual*coo.val.y_actual+coo.val.delta0*coo.val.delta0",
  0.5*(DYNX(W_,973)-1),"0.5*(coo.val.alpInv-1)")*(1-DYNX(DP_,292)), 
  DYNX(DP_,292)+DYNX(W_,952)*(1-DYNX(DP_,292)));
AssertModelica(Greater(DYNX(W_,970),"coo.val.phi", -0.2,"-0.2", 14),
  "coo.val.phi > -0.2", StringAdd("Valve control signal needs to be bigger than zero, received phi = ",
  Real2String2(DYNX(W_,970), true, 0)));
PopAllMarks();
DYNX(W_,972) = DYNX(W_,970)*DYNX(W_,948);
if (DymolaHomotopyLambda==0){
  BreakSectionCallNew(6);
}
else {

  { /* Non-linear system of equations to solve. */
  /* Tag: initialization.nonlinear[1] */
  const char*const varnames_[]={"coo.port_a1.m_flow"};
  const double nominal_[]={0.5};
  NonLinearSystemOfEquations(Jacobian__, residue__, x__, 1, 0, 1, -2, 
    DYNX(DYNhelp,68), 35, DYNX(did_->helpvari_vec,12), 23);
  SetInitVectorSimple(x__, 1, DYNX(W_,612), 0, 0);
  Residues;
    DYNX(W_,708) = homotopy((PushModelContext(1,"Buildings.Fluid.BaseClasses.FlowModels.basicFlowFunction_m_flow(coo.port_a1.m_flow, 0.015811388300841896, 0.05)")
      Buildings_Fluid_BaseClasses_FlowModels_basicFlowFunctionx_0mx_0flow(
      DYNX(W_,612), 0.015811388300841896, 0.05)), 2000.0*DYNX(W_,612));
    PopModelContext();
    DYNX(W_,932) = homotopy((PushModelContext(1,"Buildings.Fluid.BaseClasses.FlowModels.basicFlowFunction_m_flow(coo.port_a1.m_flow, coo.val.kVal, coo.val.m_flow_turbulent)")
      Buildings_Fluid_BaseClasses_FlowModels_basicFlowFunctionx_0mx_0flow(
      DYNX(W_,612), DYNX(W_,972), DYNX(W_,939))), 2.0*DYNX(W_,942)*DYNX(W_,612));
    PopModelContext();
  SetVector(residue__, 1, DYNX(W_,932)-DYNX(DP_,307)+DYNX(W_,708)+DYNX(DP_,316));

  Jacobian(Jacobian__)
  MatrixZeros(Jacobian__);
  SetMatrixLeading(Jacobian__, 1, 1, 1, homotopy((PushModelContext(1,
    "Buildings.Fluid.BaseClasses.FlowModels.basicFlowFunction_m_flow_der(coo.port_a1.m_flow, 0.015811388300841896, 0.05, 1.0)")
    Buildings_Fluid_BaseClasses_FlowModels_basicFlowFunctionx_0mx_0flowx_0der(
    DYNX(W_,612), 0.015811388300841896, 0.05, 1.0)), 2000.0)+homotopy(
    (PushModelContext(1,"Buildings.Fluid.BaseClasses.FlowModels.basicFlowFunction_m_flow_der(coo.port_a1.m_flow, coo.val.kVal, coo.val.m_flow_turbulent, 1.0)")
    Buildings_Fluid_BaseClasses_FlowModels_basicFlowFunctionx_0mx_0flowx_0der(
    DYNX(W_,612), DYNX(W_,972), DYNX(W_,939), 1.0)), 2.0*DYNX(W_,942)));
  PopModelContext();

  SolveNonLinearSystemOfEquationsInit(Jacobian__, residue__, x__,"Tag: initialization.nonlinear[1]");
  DYNX(W_,612) = GetVector(x__, 1);
  EndNonLinearSystemOfEquationsInit(residue__, x__, 1);
   /* End of Non-Linear Equation Block */ }



}
DYNX(W_,1075) = 0.0010044335697769957*DYNX(W_,615);
DYNX(W_,1295) = homotopy((PushModelContext(1,"Buildings.Fluid.BaseClasses.FlowModels.basicFlowFunction_m_flow(coo.port_a2.m_flow, 0.35355339059327373, 0.05)")
  Buildings_Fluid_BaseClasses_FlowModels_basicFlowFunctionx_0mx_0flow(
  DYNX(W_,615), 0.35355339059327373, 0.05)), 4.0*DYNX(W_,615));
PopModelContext();
DYNX(W_,771) = homotopy((PushModelContext(1,"Buildings.Fluid.BaseClasses.FlowModels.basicFlowFunction_m_flow(coo.port_a2.m_flow, 0.022360679774997897, 0.05)")
  Buildings_Fluid_BaseClasses_FlowModels_basicFlowFunctionx_0mx_0flow(
  DYNX(W_,615), 0.022360679774997897, 0.05)), 1000.0*DYNX(W_,615));
PopModelContext();
DYNX(W_,616) = DYNX(W_,771)+DYNX(DP_,345);
DYNX(W_,1047) = DYNX(W_,1295)+DYNX(W_,616);
DYNX(W_,1165) = DYNX(W_,1047)-DYNX(DP_,345);
BreakSectionFunctionEnd()
BreakSectionFunctionStart(7);
DYNX(W_,1194) = DYNX(W_,1165)*DYNX(W_,1075);
DYNX(W_,1078) = homotopy((PushModelContext(1,"Buildings.Fluid.Movers.BaseClasses.Characteristics.efficiency(\npumpBuiding.eff.per.hydraulicEfficiency, \npumpBuiding.VMachine_flow, \npumpBuiding.eff.hydDer, \n1, \n0.05)")
  Buildings_Fluid_Movers_BaseClasses_Characteristics_efficiency(DymStruc1_construct(
  RealTemporaryDense( &DYNX(W_,1171), 1, 1), RealTemporaryDense( &DYNX(W_,1172),
   1, 1)), DYNX(W_,1075), RealTemporaryDense( &DYNX(W_,1200), 1, 1), 1, 0.05)), 
  (PushModelContext(1,"Buildings.Fluid.Movers.BaseClasses.Characteristics.efficiency(\npumpBuiding.eff.per.hydraulicEfficiency, \n0.0005022167848884978, \npumpBuiding.eff.hydDer, \n1, \n0.05)")
  Buildings_Fluid_Movers_BaseClasses_Characteristics_efficiency(DymStruc1_construct(
  RealTemporaryDense( &DYNX(W_,1171), 1, 1), RealTemporaryDense( &DYNX(W_,1172),
   1, 1)), 0.0005022167848884978, RealTemporaryDense( &DYNX(W_,1200), 1, 1), 1, 
  0.05)));
PopAllMarks();
DYNX(W_,1079) = homotopy((PushModelContext(1,"Buildings.Fluid.Movers.BaseClasses.Characteristics.efficiency(\npumpBuiding.eff.per.motorEfficiency, \npumpBuiding.VMachine_flow, \npumpBuiding.eff.motDer, \n1, \n0.05)")
  Buildings_Fluid_Movers_BaseClasses_Characteristics_efficiency(DymStruc1_construct(
  RealTemporaryDense( &DYNX(W_,1173), 1, 1), RealTemporaryDense( &DYNX(W_,1174),
   1, 1)), DYNX(W_,1075), RealTemporaryDense( &DYNX(W_,1199), 1, 1), 1, 0.05)), 
  (PushModelContext(1,"Buildings.Fluid.Movers.BaseClasses.Characteristics.efficiency(\npumpBuiding.eff.per.motorEfficiency, \n0.0005022167848884978, \npumpBuiding.eff.motDer, \n1, \n0.05)")
  Buildings_Fluid_Movers_BaseClasses_Characteristics_efficiency(DymStruc1_construct(
  RealTemporaryDense( &DYNX(W_,1173), 1, 1), RealTemporaryDense( &DYNX(W_,1174),
   1, 1)), 0.0005022167848884978, RealTemporaryDense( &DYNX(W_,1199), 1, 1), 1, 
  0.05)));
PopAllMarks();
DYNX(W_,1077) = DYNX(W_,1078)*DYNX(W_,1079);
DYNX(W_,1072) = divmacro(DYNX(W_,1194),"pumpBuiding.eff.WFlo",IF DYNX(W_,1077)-
  1E-05 > 1E-06 THEN DYNX(W_,1077) ELSE IF DYNX(W_,1077)-1E-05 < -1E-06 THEN 
  1E-05 ELSE 5E-06+250000.0*(DYNX(W_,1077)-1E-05)*(sqr(1000000.0*(DYNX(W_,1077)-
  1E-05))-3)*(1E-05-DYNX(W_,1077))+0.5*DYNX(W_,1077),"smooth(1, smooth(1, (if noEvent(pumpBuiding.eta-1E-05 > 1E-06) then pumpBuiding.eta else (if noEvent(pumpBuiding.eta-1E-05 < -1E-06) then 1E-05 else 5E-06+250000.0*((pumpBuiding.eta-1E-05)*((1000000.0*(pumpBuiding.eta-1E-05))^2-3)*(1E-05-pumpBuiding.eta))+0.5*pumpBuiding.eta))))");
 /* Linear system of equations to solve. */
DYNX(W_,1152) = 0.0;
SolveScalarLinear(DYNX(W_,1078),"pumpBuiding.etaHyd", DYNX(W_,1194),
  "pumpBuiding.eff.WFlo", DYNX(W_,1152),"pumpBuiding.heaDis.WHyd");
 /* End of Equation Block */ 

DYNX(W_,1153) = (IF DYNX(W_,1149) THEN DYNX(W_,1072) ELSE DYNX(W_,1152))-
  DYNX(W_,1194);
DYNX(W_,1151) = homotopy(IF fabs(DYNX(W_,1075))-1.0044335697769956E-06 > 
  5.022167848884978E-07 THEN DYNX(W_,1153) ELSE IF fabs(DYNX(W_,1075))-
  1.0044335697769956E-06 < -5.022167848884978E-07 THEN 0 ELSE 0.5*DYNX(W_,1153)-
  497793.00000000006*(fabs(DYNX(W_,1075))-1.0044335697769956E-06)*(sqr(
  1991172.0000000002*(fabs(DYNX(W_,1075))-1.0044335697769956E-06))-3)*
  DYNX(W_,1153), 0);
DYNX(W_,545) = DYNX(W_,543)*DYNX(W_,526)+DYNX(W_,544)*DYNX(W_,188);
DYNX(W_,546) = DYNX(DP_,220)*DYNX(W_,545);
DYNX(W_,551) = DYNX(W_,546)+DYNX(X_,16);
DYNX(W_,566) = DYNX(W_,565)*DYNX(W_,551);
DYNX(W_,542) = homotopy(IF DYNX(W_,566) > DYNX(W_,568) THEN DYNX(W_,568) ELSE 
  IF DYNX(W_,566) < DYNX(W_,569) THEN DYNX(W_,569) ELSE DYNX(W_,566), 
  DYNX(W_,566));
DYNX(W_,581) = DYNX(W_,579)*DYNX(W_,531)+DYNX(W_,580)*DYNX(W_,188);
DYNX(W_,582) = DYNX(DP_,235)*DYNX(W_,581);
DYNX(W_,587) = DYNX(W_,582)+DYNX(X_,17);
DYNX(W_,602) = DYNX(W_,601)*DYNX(W_,587);
DYNX(W_,578) = homotopy(IF DYNX(W_,602) > DYNX(W_,604) THEN DYNX(W_,604) ELSE 
  IF DYNX(W_,602) < DYNX(W_,605) THEN DYNX(W_,605) ELSE DYNX(W_,602), 
  DYNX(W_,602));
InitialSection
InitialSectionB
Init_=false;InitializeData(2);Init_=true;
InitialSection2
(PushModelContext(1,"Modelica.Fluid.Utilities.checkBoundary(\"SimpleLiquidWater\", {\"SimpleLiquidWater\"}, true, true, souDis.X_in_internal, \"Boundary_pT\")")
  Modelica_Fluid_Utilities_checkBoundary("SimpleLiquidWater", StringTemporaryDense( 
  DymArrays40, 1, 1), true, true, RealTemporaryDense( &DYNX(W_,990), 1, 1), 
  "Boundary_pT"));
PopAllMarks();
(PushModelContext(1,"Modelica.Fluid.Utilities.checkBoundary(\"SimpleLiquidWater\", {\"SimpleLiquidWater\"}, true, true, sinDis.X_in_internal, \"Boundary_pT\")")
  Modelica_Fluid_Utilities_checkBoundary("SimpleLiquidWater", StringTemporaryDense( 
  DymArrays40, 1, 1), true, true, RealTemporaryDense( &DYNX(W_,1032), 1, 1), 
  "Boundary_pT"));
PopAllMarks();
  AssertModelica(DYNX(DP_,350) > 1E-15,"CoolingUnit.tau > 1E-15", StringAdd(
    StringAdd("The parameter tau, or the volume of the model from which tau may be derived, is unreasonably small.\n You need to set energyDynamics == Modelica.Fluid.Types.Dynamics.SteadyState to model steady-state.\n Received tau = ",
    Real2String2(DYNX(DP_,350), true, 0)),"\n"));
  PopAllMarks();
  AssertModelica(DYNX(DP_,350) > 1E-15,"CoolingUnit.tau > 1E-15", StringAdd(
    StringAdd("The parameter tau, or the volume of the model from which tau may be derived, is unreasonably small.\n You need to set massDynamics == Modelica.Fluid.Types.Dynamics.SteadyState to model steady-state.\n Received tau = ",
    Real2String2(DYNX(DP_,350), true, 0)),"\n"));
  PopAllMarks();
AssertModelica4(fabs(Realsum( RealTemporaryDense( &DYNX(DP_,72), 1, 2))+Realsum( 
  RealTemporaryDense( &DYNX(DP_,74), 1, 2))+DYNX(DP_,76)) > 0.1,"abs(sum(building.eqAirTemp.wfWall)+sum(building.eqAirTemp.wfWin)+building.eqAirTemp.wfGro) > 0.1",
   "The sum of the weighting factors (walls,windows and ground) in the\n   equivalent air temperature calculation is close to 0.\n   If there are no walls, windows and ground at all, this might be\n   irrelevant.",
   1,DYNX(did_->helpvari_vec,35));
PopAllMarks();
AssertModelica4(fabs(Realsum( RealTemporaryDense( &DYNX(DP_,72), 1, 2))+
  DYNX(DP_,76)-1) < 0.1,"abs(sum(building.eqAirTemp.wfWall)+building.eqAirTemp.wfGro-1) < 0.1",
   "The sum of the weightfactors (walls and ground)  is <0.9 or >1.1.\n   Normally, the sum should be 1.",
   1,DYNX(did_->helpvari_vec,36));
PopAllMarks();
AssertModelica4(fabs(Realsum( RealTemporaryDense( &DYNX(DP_,74), 1, 2))-1) < 0.1,
  "abs(sum(building.eqAirTemp.wfWin)-1) < 0.1", "The sum of the weightfactors (windows)  is <0.9 or >1.1.\n  Normally, the sum should be 1.",
   1,DYNX(did_->helpvari_vec,37));
PopAllMarks();
AssertModelica((PushModelContext(1,"Buildings.Utilities.Math.Functions.isMonotonic(pumpBuiding.eff.per.pressure.V_flow, true)")
  Buildings_Utilities_Math_Functions_isMonotonic(RealTemporaryDense( 
  &DYNX(W_,1166), 1, 2), true)),"Buildings.Utilities.Math.Functions.isMonotonic(pumpBuiding.eff.per.pressure.V_flow, true)",
   StringAdd("The fan pressure rise must be a strictly decreasing sequence with respect to the volume flow rate,\n  with the first element for the fan pressure raise being non-zero.\nThe following performance data have been entered:\n",
  (PushModelContext(1,"Buildings.Fluid.Movers.BaseClasses.FlowMachineInterface.getArrayAsString(pumpBuiding.eff.per.pressure.V_flow, \"pressure.V_flow\", 6, 6)")
  Buildings_Fluid_Movers_BaseClasses_FlowMachineInterface_getArrayAsString(
  RealTemporaryDense( &DYNX(W_,1166), 1, 2), "pressure.V_flow", 6, 6))));
PopAllMarks();
EndInitialSection

OutputSection
AssertModelica(Greater(DYNX(X_,10),"exp.m", 1E-08,"1E-08", 6),"exp.m > 1E-08", 
  "Expansion vessel is undersized. You need to increase the value of the parameter V_start.");
AssertModelica(DYNX(W_,128) OR Less(DYNTime-DYNX(W_,125),"time-weaDat.conTim1.weaDatEndTim",
   1800.0,"1800.0", 15),"weaDat.conTim1.canRepeatWeatherFile or time-weaDat.conTim1.weaDatEndTim < 1800.0",
   StringAdd(StringAdd(StringAdd(StringAdd("In CouplingETS_RC_Yanfei_Cooling.weaDat.conTim1: Insufficient weather data provided for the desired simulation period.\n    Based on the provided weather file the following start time ",
  Real2String2(DYNX(W_,124), true, 0))," and end time "),Real2String2(
  DYNX(W_,125), true, 0))," (last time stamp + average increment) for the weather data were determined"));
PopAllMarks();
AssertModelica(DYNX(W_,134) OR Less(DYNTime-DYNX(W_,131),"time-weaDat.conTim.weaDatEndTim",
   1800.0,"1800.0", 16),"weaDat.conTim.canRepeatWeatherFile or time-weaDat.conTim.weaDatEndTim < 1800.0",
   StringAdd(StringAdd(StringAdd(StringAdd("In CouplingETS_RC_Yanfei_Cooling.weaDat.conTim: Insufficient weather data provided for the desired simulation period.\n    Based on the provided weather file the following start time ",
  Real2String2(DYNX(W_,130), true, 0))," and end time "),Real2String2(
  DYNX(W_,131), true, 0))," (last time stamp + average increment) for the weather data were determined"));
PopAllMarks();

DynamicsSection
DYNX(W_,1334) = 0.0002777777777777778*DYNTime;
beginwhenBlock
whenModelica(GreaterEqualTimeMinor(PRE(DYNX(W_,1330), 7), 0), 0) 
  DYNX(W_,1331) = (PushModelContext(1,"Modelica.Blocks.Sources.CombiTimeTable.getNextTimeEvent(\nQCoo.tableID, \nQCoo.timeScaled, \nQCoo.tableOnFileRead)")
    Modelica_Blocks_Sources_CombiTimeTable_getNextTimeEvent_M(DymStruc0_construct(
    (Integer)(DYNX(W_,1329))), DYNX(W_,1334), DYNX(W_,1332)));
  PopModelContext();
endwhenModelica()
endwhenBlock


DYNX(DYNhelp,103) = (PushModelContext(1,"Modelica.Blocks.Sources.CombiTimeTable.getTableValue(\nQCoo.tableID, \n1, \nQCoo.timeScaled, \nQCoo.nextTimeEventScaled, \npre(QCoo.nextTimeEventScaled), \nQCoo.tableOnFileRead)")
  Modelica_Blocks_Sources_CombiTimeTable_getTableValue_M(DymStruc0_construct(
  (Integer)(DYNX(W_,1329))), 1, DYNX(W_,1334), DYNX(W_,1331), PRE(DYNX(W_,1331),
   4), DYNX(W_,1332)));
PopModelContext();
DYNX(W_,189) = DYNX(W_,1328)+DYNX(DYNhelp,103);
DYNX(W_,1318) = DYNX(W_,1317)*DYNX(W_,189);
DYNX(W_,1137) = 2.0*DYNX(W_,1318);
DYNX(F_,8) = DYNX(W_,1135)*(DYNX(X_,8)-DYNX(W_,1137));
DYNX(F_,9) = DYNX(W_,1136)*(DYNX(X_,9)-DYNX(X_,8));
DYNX(W_,615) = 0.5*DYNX(DP_,335)*DYNX(X_,9);
AssertModelica(Greater(DYNX(W_,615),"coo.port_a2.m_flow", -5E-05,"-5E-05", 5),
  "coo.port_a2.m_flow > -5E-05", StringAdd(StringAdd("In CouplingETS_RC_Yanfei_Cooling.pumpBuiding.vol: Model has flow reversal,\n  but the parameter allowFlowReversal is set to false.\n  m_flow_small    = 5e-05\n  ports[1].m_flow = ",
  Real2String2(DYNX(W_,615), true, 0)),"\n"));
PopAllMarks();
AssertModelica(Greater(DYNX(W_,615),"coo.port_a2.m_flow", -5E-05,"-5E-05", 5),
  "coo.port_a2.m_flow > -5E-05", "Reverting flow occurs even though allowFlowReversal is false");
DYNX(W_,850) = DYNX(W_,851)*DYNX(DP_,297)+DYNX(W_,852)*DYNX(X_,3);
DYNX(W_,853) = DYNX(DP_,266)*DYNX(W_,850);
DYNX(W_,1434) = DYNX(W_,1435)*DYNX(DP_,297)+DYNX(W_,1436)*DYNX(X_,3);
DYNX(W_,857) = IF DYNX(W_,1448) THEN 0 ELSE divmacro(DYNX(W_,1444)*(
  DYNX(W_,1434)-DYNX(X_,19)),"coo.con.D.k*(coo.con.addD.y-coo.con.D.x)",
  DYNX(W_,1445),"coo.con.D.T");
DYNX(W_,858) = DYNX(W_,853)+DYNX(W_,857)+DYNX(X_,18);
DYNX(W_,872) = DYNX(W_,871)*DYNX(W_,858);
DYNX(W_,830) = IF DYNX(W_,872) > DYNX(W_,874) THEN DYNX(W_,874) ELSE IF 
  DYNX(W_,872) < DYNX(W_,875) THEN DYNX(W_,875) ELSE DYNX(W_,872);
DYNX(W_,868) = DYNX(W_,830)-DYNX(W_,872);
DYNX(W_,866) = DYNX(W_,873)*DYNX(W_,868);
DYNX(W_,867) = DYNX(W_,864)*DYNX(DP_,297)+DYNX(W_,865)*DYNX(X_,3)+DYNX(DP_,267)*
  DYNX(W_,866);
DYNX(F_,18) = DYNX(W_,1437)*DYNX(W_,867);
DYNX(F_,19) = IF DYNX(W_,1448) THEN 0 ELSE divmacro(DYNX(W_,1434)-DYNX(X_,19),
  "coo.con.addD.y-coo.con.D.x",DYNX(W_,1445),"coo.con.D.T");
 /* Linear system of equations to solve. */
DYNX(W_,1251) = RememberSimple_(DYNX(W_,1251), 0);
SolveScalarLinearParametric( -DYNX(W_,1498)," -CoolingUnit.vol.dynBal.m",  -
  DYNX(X_,20)," -CoolingUnit.vol.dynBal.U", DYNX(W_,1251),"CoolingUnit.port_a.h_outflow");
 /* End of Equation Block */ 

DYNX(W_,952) = DYNX(DP_,285)*DYNX(DP_,291)*DYNX(X_,5);
DYNX(W_,970) = DYNX(DP_,292)+DYNX(W_,952)*powmacro(DYNX(W_,952)*DYNX(W_,952)+
  DYNX(DP_,294)*DYNX(DP_,294),"coo.val.y_actual*coo.val.y_actual+coo.val.delta0*coo.val.delta0",
  0.5*(DYNX(W_,973)-1),"0.5*(coo.val.alpInv-1)")*(1-DYNX(DP_,292));
AssertModelica(Greater(DYNX(W_,970),"coo.val.phi", -0.2,"-0.2", 14),
  "coo.val.phi > -0.2", StringAdd("Valve control signal needs to be bigger than zero, received phi = ",
  Real2String2(DYNX(W_,970), true, 0)));
PopAllMarks();
DYNX(W_,972) = DYNX(W_,970)*DYNX(W_,948);

{ /* Non-linear system of equations to solve. */
/* Tag: simulation.nonlinear[1] */
/* Introducing 3 common subexpressions and reusing 2 variables totally used in 0
   expressions */
/* Of the common subexpressions 5 are reals, 0 are integers, and 0
   are booleans. */
const char*const varnames_[]={"coo.port_a1.m_flow"};
const double nominal_[]={0.5};
NonLinearSystemOfEquationsNH(Jacobian__, residue__, x__, 1, 0, 2, 20, 1, 
  DYNX(DYNhelp,104), 37, DYNX(did_->helpvari_vec,38), 23);
NonLinearSystemSave(DYNX(W_,972), 0);
SetInitVectorNH(x__, 1, DYNX(W_,612), Remember_(DYNX(W_,612), 1));
Residues;
  DYNX(W_,708) = (PushModelContext(1,"Buildings.Fluid.BaseClasses.FlowModels.basicFlowFunction_m_flow(coo.port_a1.m_flow, 0.015811388300841896, 0.05)")
    Buildings_Fluid_BaseClasses_FlowModels_basicFlowFunctionx_0mx_0flow(
    DYNX(W_,612), 0.015811388300841896, 0.05));
  PopModelContext();
  DYNX(W_,932) = (PushModelContext(1,"Buildings.Fluid.BaseClasses.FlowModels.basicFlowFunction_m_flow(coo.port_a1.m_flow, coo.val.kVal, coo.val.m_flow_turbulent)")
    Buildings_Fluid_BaseClasses_FlowModels_basicFlowFunctionx_0mx_0flow(
    DYNX(W_,612), DYNX(W_,972), DYNX(W_,939)));
  PopModelContext();
SetVector(residue__, 1, DYNX(W_,932)-DYNX(DP_,307)+DYNX(W_,708)+DYNX(DP_,316));

Jacobian(Jacobian__)
MatrixZeros(Jacobian__);
SetMatrixLeading(Jacobian__, 1, 1, 1, (PushModelContext(1,"Buildings.Fluid.BaseClasses.FlowModels.basicFlowFunction_m_flow_der(coo.port_a1.m_flow, 0.015811388300841896, 0.05, 1.0)")
  Buildings_Fluid_BaseClasses_FlowModels_basicFlowFunctionx_0mx_0flowx_0der(
  DYNX(W_,612), 0.015811388300841896, 0.05, 1.0))+(PushModelContext(1,
  "Buildings.Fluid.BaseClasses.FlowModels.basicFlowFunction_m_flow_der(coo.port_a1.m_flow, coo.val.kVal, coo.val.m_flow_turbulent, 1.0)")
  Buildings_Fluid_BaseClasses_FlowModels_basicFlowFunctionx_0mx_0flowx_0der(
  DYNX(W_,612), DYNX(W_,972), DYNX(W_,939), 1.0)));
PopModelContext();

SolveNonLinearSystemOfEquationsNH(Jacobian__, residue__, x__, 2, 
  "Tag: simulation.nonlinear[1]");
DYNX(W_,612) = GetVector(x__, 1);
EndNonLinearSystemOfEquationsNH(residue__, x__, 2);
 /* End of Non-Linear Equation Block */ }



DYNX(W_,631) = DYNX(W_,708)+DYNX(DP_,316);
DYNX(DYNhelp,141) = (PushModelContext(1,"Buildings.Utilities.Math.Functions.regNonZeroPower(2.0*coo.port_a1.m_flow, coo.hex.n1, 0.1)")
  Buildings_Utilities_Math_Functions_regNonZeroPower(2.0*DYNX(W_,612), 
  DYNX(DP_,264), 0.1));
PopModelContext();
DYNX(W_,828) = DYNX(W_,826)*DYNX(DYNhelp,141);
DYNX(DYNhelp,142) = (PushModelContext(1,"Buildings.Utilities.Math.Functions.regNonZeroPower(2.0*coo.port_a2.m_flow, coo.hex.n2, 0.1)")
  Buildings_Utilities_Math_Functions_regNonZeroPower(2.0*DYNX(W_,615), 
  DYNX(DP_,265), 0.1));
PopModelContext();
DYNX(W_,829) = DYNX(W_,827)*DYNX(DYNhelp,142);
DYNX(W_,807) = divmacro(1,"1",divmacro(1,"1",DYNX(W_,828),"coo.hex.hA1")+
  divmacro(1,"1",DYNX(W_,829),"coo.hex.hA2"),"1/coo.hex.hA1+1/coo.hex.hA2");
DYNX(W_,797) = IF DYNX(W_,612) > 5E-05 THEN 1 ELSE IF DYNX(W_,612) < -5E-05
   THEN 0 ELSE 0.5-5000.0*DYNX(W_,612)*(sqr(20000.0*DYNX(W_,612))-3);
DYNX(W_,798) = 1-DYNX(W_,797);
DYNX(DYNhelp,143) = fabs(DYNX(W_,612));
DYNX(W_,790) = 4184.0*DYNX(DYNhelp,143)*(DYNX(W_,797)+DYNX(W_,798));
DYNX(W_,799) = IF DYNX(W_,615) > 5E-05 THEN 1 ELSE IF DYNX(W_,615) < -5E-05
   THEN 0 ELSE 0.5-5000.0*DYNX(W_,615)*(sqr(20000.0*DYNX(W_,615))-3);
DYNX(W_,800) = 1-DYNX(W_,799);
DYNX(DYNhelp,144) = fabs(DYNX(W_,615));
DYNX(W_,791) = 4184.0*DYNX(DYNhelp,144)*(DYNX(W_,799)+DYNX(W_,800));
DYNX(W_,825) = IF GreaterEqual(DYNX(W_,790)*DYNX(W_,791),"coo.hex.C1_flow*coo.hex.C2_flow",
   0,"0", 17) THEN 2 ELSE 1;
DYNX(DYNhelp,145) = DYNX(W_,825);
DYNX(W_,808) = (PushModelContext(1,"Buildings.Fluid.HeatExchangers.BaseClasses.epsilon_C(coo.hex.UA, coo.hex.C1_flow, coo.hex.C2_flow, Integer(coo.hex.flowRegime), coo.hex.CMin_flow_nominal, coo.hex.CMax_flow_nominal, coo.hex.delta)")
  Buildings_Fluid_HeatExchangers_BaseClasses_epsilonx_0C(DYNX(W_,807), 
  DYNX(W_,790), DYNX(W_,791), (Integer)(DYNX(DYNhelp,145)), DYNX(W_,819), 
  DYNX(W_,820), DYNX(DP_,263)));
PopModelContext();
DYNX(W_,792) = RealBmin(DYNX(W_,790), DYNX(W_,791));
DYNX(W_,641) = 273.15+0.0002390057361376673*DYNX(W_,1251);
 /* Linear system of equations to solve. */
DYNX(W_,1246) = RememberSimple_(DYNX(W_,1246), 2);
SolveScalarLinear(DYNX(X_,10),"exp.m", DYNX(X_,11),"exp.H", DYNX(W_,1246),
  "exp.port_a.h_outflow");
 /* End of Equation Block */ 

DYNX(W_,642) = 273.15+0.0002390057361376673*DYNX(W_,1246);
DYNX(W_,789) = DYNX(W_,799)*DYNX(W_,641)+DYNX(W_,800)*DYNX(W_,642);
beginwhenBlock
DYNX(DYNhelp,146) = divmacro(1.0,"1.0",DYNX(DP_,302),"tra.period");
DYNX(DYNhelp,147) = real2integer(DYNX(DYNhelp,146)*(DYNTime-DYNX(DP_,305)));
whenModelica(real2integerEventMinor(divmacro(DYNTime-DYNX(DP_,305),
  "time-tra.startTime",DYNX(DP_,302),"tra.period"),"(time-tra.startTime)/tra.period",
   0) > PRE(DYNX(W_,985), 2), 1) 
  DYNX(W_,985) = PRE(DYNX(W_,985), 2)+1;
  DYNX(W_,984) = DYNTime;
endwhenModelica()
endwhenBlock


DYNX(W_,980) = DYNX(DP_,304)+(IF LessTime(DYNX(DP_,305), 1) OR DYNX(DP_,303) == 0
   OR DYNX(DP_,303) > 0 AND DYNX(W_,985) >= DYNX(DP_,303) THEN 0 ELSE IF 
  LessTime(DYNX(W_,984)+DYNX(W_,981), 2) THEN divmacro(DYNX(DP_,298)*(DYNTime-
  DYNX(W_,984)),"tra.amplitude*(time-tra.T_start)",DYNX(DP_,299),"tra.rising")
   ELSE IF LessTime(DYNX(W_,984)+DYNX(W_,982), 3) THEN DYNX(DP_,298) ELSE IF 
  LessTime(DYNX(W_,984)+DYNX(W_,983), 4) THEN divmacro(DYNX(DP_,298)*(
  DYNX(W_,984)+DYNX(W_,983)-DYNTime),"tra.amplitude*(tra.T_start+tra.T_falling-time)",
  DYNX(DP_,301),"tra.falling") ELSE 0);
DYNX(W_,988) = 4184*(DYNX(W_,980)-273.15);
DYNX(W_,639) = 273.15+0.0002390057361376673*DYNX(W_,988);
DYNX(W_,788) = DYNX(W_,797)*DYNX(W_,639)+DYNX(W_,798)*DYNX(W_,640);
DYNX(W_,793) = DYNX(W_,792)*(DYNX(W_,789)-DYNX(W_,788));
DYNX(W_,656) = DYNX(W_,808)*DYNX(W_,793);
AssertModelica(fabs(DYNX(W_,656)) < 836800.0*RealBmax(5.0000000000000004E-08, 
  fabs(DYNX(W_,612))),"noEvent(abs(coo.hex.Q1_flow) < 836800.0*max(5.0000000000000004E-08, abs(coo.port_a1.m_flow)))",
   StringAdd(StringAdd(StringAdd(StringAdd(StringAdd(StringAdd(StringAdd(
  StringAdd("In CouplingETS_RC_Yanfei_Cooling.coo.hex.bal1.vol:\n   The heat flow rate equals ",
  Real2String2(DYNX(W_,656), true, 0))," W and the mass flow rate equals "),
  Real2String2(DYNX(W_,612), true, 0))," kg/s,\n   which results in a temperature difference "),
  Real2String2(divmacro(fabs(DYNX(W_,656)),"abs(coo.hex.Q1_flow)",4184.0*
  RealBmax(5.0000000000000004E-08, fabs(DYNX(W_,612))),"4184.0*max(5.0000000000000004E-08, abs(coo.port_a1.m_flow))"),
   true, 0))," K > dTMax="),"200")," K.\n   This may indicate that energy is not conserved for small mass flow rates.\n   The implementation may require prescribedHeatFlowRate = false."));
PopAllMarks();
AssertModelica(fabs(DYNX(W_,656)) < 836800.0*RealBmax(5.0000000000000004E-08, 
  fabs(DYNX(W_,615))),"noEvent(abs(coo.hex.Q1_flow) < 836800.0*max(5.0000000000000004E-08, abs(coo.port_a2.m_flow)))",
   StringAdd(StringAdd(StringAdd(StringAdd(StringAdd(StringAdd(StringAdd(
  StringAdd("In CouplingETS_RC_Yanfei_Cooling.coo.hex.bal2.vol:\n   The heat flow rate equals ",
  Real2String2( -DYNX(W_,656), true, 0))," W and the mass flow rate equals "),
  Real2String2(DYNX(W_,615), true, 0))," kg/s,\n   which results in a temperature difference "),
  Real2String2(divmacro(fabs(DYNX(W_,656)),"abs(coo.hex.Q1_flow)",4184.0*
  RealBmax(5.0000000000000004E-08, fabs(DYNX(W_,615))),"4184.0*max(5.0000000000000004E-08, abs(coo.port_a2.m_flow))"),
   true, 0))," K > dTMax="),"200")," K.\n   This may indicate that energy is not conserved for small mass flow rates.\n   The implementation may require prescribedHeatFlowRate = false."));
PopAllMarks();
DYNX(W_,753) = IF DYNX(W_,615) > 5.0000000000000004E-08 OR DYNX(W_,615) < 
  -5.0000000000000004E-08 THEN divmacro(1,"1",DYNX(W_,615),"coo.port_a2.m_flow")
   ELSE IF DYNX(W_,615) < 2.5000000000000002E-08 AND DYNX(W_,615) > 
  -2.5000000000000002E-08 THEN 399999999999999.94*DYNX(W_,615) ELSE 
  (PushModelContext(1,"Buildings.Utilities.Math.Functions.BaseClasses.smoothTransition(coo.port_a2.m_flow, 5.0000000000000004E-08, 20000000.0, -300000000.0, 4.76E+16, -2.888E+24, 8.544E+31, -1.216E+39, 6.656E+45)")
  Buildings_Utilities_Math_Functions_BaseClasses_smoothTransition(DYNX(W_,615), 
  5.0000000000000004E-08, 20000000.0, -300000000.0, 4.76E+16, -2.888E+24, 
  8.544E+31, -1.216E+39, 6.656E+45));
PopModelContext();
DYNX(W_,618) = DYNX(W_,1251)-DYNX(W_,656)*DYNX(W_,753);
DYNX(W_,926) = 273.15+0.0002390057361376673*DYNX(W_,618);
DYNX(W_,927) = 273.15+0.0002390057361376673*DYNX(W_,1246);
DYNX(W_,925) = IF DYNX(W_,615) > 5E-05 THEN DYNX(W_,926) ELSE IF DYNX(W_,615) < 
  -5E-05 THEN DYNX(W_,927) ELSE 5000.0*DYNX(W_,615)*(sqr(20000.0*DYNX(W_,615))-3)
  *(DYNX(W_,927)-DYNX(W_,926))+0.5*(DYNX(W_,926)+DYNX(W_,927));
DYNX(W_,920) = 2.0*DYNX(W_,615);
DYNX(W_,918) = IF DYNX(W_,615) > 5E-05 THEN DYNX(W_,920) ELSE IF DYNX(W_,615) < 
  -5E-05 THEN  -DYNX(W_,920) ELSE (-10000.0)*DYNX(W_,615)*(sqr(20000.0*
  DYNX(W_,615))-3)*DYNX(W_,920);
DYNX(F_,3) = (DYNX(W_,925)-DYNX(X_,3))*DYNX(W_,918);
DYNX(W_,968) = divmacro(DYNX(W_,830),"coo.con.y",DYNX(DP_,291),"coo.val.filter.u_nominal");
DYNX(F_,4) = DYNX(W_,966)*(DYNX(X_,4)-DYNX(W_,968));
DYNX(F_,5) = DYNX(W_,967)*(DYNX(X_,5)-DYNX(X_,4));
if (Init_) {
DYNX(DYNhelp,148) = RealBmax( -DYNX(F_,10), 0.0);
}
DYNX(Aux_,27) = DYNX(W_,615)+DYNX(DYNhelp,148);
DYNX(Aux_,28) = IF DYNX(Aux_,27) > 5E-11 THEN 1.0 ELSE IF DYNX(Aux_,27) > 0.0
   THEN sqr(20000000000.0*DYNX(Aux_,27))*(3.0-40000000000.0*DYNX(Aux_,27)) ELSE 
  0.0;
DYNX(Aux_,29) = IF DYNX(Aux_,27) > 1E-10 THEN 1.0 ELSE IF DYNX(Aux_,27) > 0.0
   THEN sqr(10000000000.0*DYNX(Aux_,27))*(3.0-20000000000.0*DYNX(Aux_,27)) ELSE 
  0.0;
DYNX(DYNhelp,149) = 1.0-DYNX(Aux_,28);
DYNX(DYNhelp,150) = DYNX(Aux_,28)*DYNX(W_,615)+5E-11*DYNX(DYNhelp,149);
DYNX(DYNhelp,151) = 1.0-DYNX(Aux_,29);
DYNX(DYNhelp,152) = DYNX(Aux_,29)*DYNX(DYNhelp,148)+1E-10*DYNX(DYNhelp,151);
DYNX(DYNhelp,153) = DYNX(DYNhelp,150)+DYNX(DYNhelp,152);
DYNX(DYNhelp,154) = divmacro(1.0,"1.0",DYNX(DYNhelp,153),"stream_alpha1*coo.port_a2.m_flow+5E-11*(1.0-stream_alpha1)+stream_alpha2*max( -der(exp.m), 0.0)+1E-10*(1.0-stream_alpha2)");
DYNX(Aux_,13) = DYNX(DYNhelp,154)*(DYNX(DYNhelp,150)*DYNX(W_,618)+
  DYNX(DYNhelp,152)*DYNX(W_,1246));
DYNX(Aux_,14) = DYNX(Aux_,13);
DYNX(Aux_,23) = DYNX(Aux_,14);
DYNX(W_,1075) = 0.0010044335697769957*DYNX(W_,615);
DYNX(W_,1295) = (PushModelContext(1,"Buildings.Fluid.BaseClasses.FlowModels.basicFlowFunction_m_flow(coo.port_a2.m_flow, 0.35355339059327373, 0.05)")
  Buildings_Fluid_BaseClasses_FlowModels_basicFlowFunctionx_0mx_0flow(
  DYNX(W_,615), 0.35355339059327373, 0.05));
PopModelContext();
DYNX(W_,771) = (PushModelContext(1,"Buildings.Fluid.BaseClasses.FlowModels.basicFlowFunction_m_flow(coo.port_a2.m_flow, 0.022360679774997897, 0.05)")
  Buildings_Fluid_BaseClasses_FlowModels_basicFlowFunctionx_0mx_0flow(
  DYNX(W_,615), 0.022360679774997897, 0.05));
PopModelContext();
DYNX(W_,616) = DYNX(W_,771)+DYNX(DP_,345);
DYNX(W_,1047) = DYNX(W_,1295)+DYNX(W_,616);
DYNX(W_,1165) = DYNX(W_,1047)-DYNX(DP_,345);
DYNX(W_,1194) = DYNX(W_,1165)*DYNX(W_,1075);
DYNX(W_,1078) = (PushModelContext(1,"Buildings.Fluid.Movers.BaseClasses.Characteristics.efficiency(\npumpBuiding.eff.per.hydraulicEfficiency, \npumpBuiding.VMachine_flow, \npumpBuiding.eff.hydDer, \n1, \n0.05)")
  Buildings_Fluid_Movers_BaseClasses_Characteristics_efficiency(DymStruc1_construct(
  RealTemporaryDense( &DYNX(W_,1171), 1, 1), RealTemporaryDense( &DYNX(W_,1172),
   1, 1)), DYNX(W_,1075), RealTemporaryDense( &DYNX(W_,1200), 1, 1), 1, 0.05));
PopAllMarks();
DYNX(W_,1079) = (PushModelContext(1,"Buildings.Fluid.Movers.BaseClasses.Characteristics.efficiency(\npumpBuiding.eff.per.motorEfficiency, \npumpBuiding.VMachine_flow, \npumpBuiding.eff.motDer, \n1, \n0.05)")
  Buildings_Fluid_Movers_BaseClasses_Characteristics_efficiency(DymStruc1_construct(
  RealTemporaryDense( &DYNX(W_,1173), 1, 1), RealTemporaryDense( &DYNX(W_,1174),
   1, 1)), DYNX(W_,1075), RealTemporaryDense( &DYNX(W_,1199), 1, 1), 1, 0.05));
PopAllMarks();
DYNX(W_,1077) = DYNX(W_,1078)*DYNX(W_,1079);
DYNX(W_,1072) = divmacro(DYNX(W_,1194),"pumpBuiding.eff.WFlo",IF DYNX(W_,1077)-
  1E-05 > 1E-06 THEN DYNX(W_,1077) ELSE IF DYNX(W_,1077)-1E-05 < -1E-06 THEN 
  1E-05 ELSE 5E-06+250000.0*(DYNX(W_,1077)-1E-05)*(sqr(1000000.0*(DYNX(W_,1077)-
  1E-05))-3)*(1E-05-DYNX(W_,1077))+0.5*DYNX(W_,1077),"smooth(1, smooth(1, (if noEvent(pumpBuiding.eta-1E-05 > 1E-06) then pumpBuiding.eta else (if noEvent(pumpBuiding.eta-1E-05 < -1E-06) then 1E-05 else 5E-06+250000.0*((pumpBuiding.eta-1E-05)*((1000000.0*(pumpBuiding.eta-1E-05))^2-3)*(1E-05-pumpBuiding.eta))+0.5*pumpBuiding.eta))))");
 /* Linear system of equations to solve. */
DYNX(W_,1152) = RememberSimple_(DYNX(W_,1152), 3);
SolveScalarLinear(DYNX(W_,1078),"pumpBuiding.etaHyd", DYNX(W_,1194),
  "pumpBuiding.eff.WFlo", DYNX(W_,1152),"pumpBuiding.heaDis.WHyd");
 /* End of Equation Block */ 

DYNX(W_,1153) = (IF DYNX(W_,1149) THEN DYNX(W_,1072) ELSE DYNX(W_,1152))-
  DYNX(W_,1194);
DYNX(W_,1151) = IF fabs(DYNX(W_,1075))-1.0044335697769956E-06 > 5.022167848884978E-07
   THEN DYNX(W_,1153) ELSE IF fabs(DYNX(W_,1075))-1.0044335697769956E-06 < 
  -5.022167848884978E-07 THEN 0 ELSE 0.5*DYNX(W_,1153)-497793.00000000006*(fabs(
  DYNX(W_,1075))-1.0044335697769956E-06)*(sqr(1991172.0000000002*(fabs(
  DYNX(W_,1075))-1.0044335697769956E-06))-3)*DYNX(W_,1153);
DYNX(W_,1118) = DYNX(W_,1151)+DYNX(W_,1194);
AssertModelica(fabs(DYNX(W_,1118)) < 836800.0*RealBmax(5.0000000000000004E-08, 
  fabs(DYNX(W_,615))),"noEvent(abs(pumpBuiding.vol.heatPort.Q_flow) < 836800.0*max(5.0000000000000004E-08, abs(coo.port_a2.m_flow)))",
   StringAdd(StringAdd(StringAdd(StringAdd(StringAdd(StringAdd(StringAdd(
  StringAdd("In CouplingETS_RC_Yanfei_Cooling.pumpBuiding.vol.steBal:\n   The heat flow rate equals ",
  Real2String2(DYNX(W_,1118), true, 0))," W and the mass flow rate equals "),
  Real2String2(DYNX(W_,615), true, 0))," kg/s,\n   which results in a temperature difference "),
  Real2String2(divmacro(fabs(DYNX(W_,1118)),"abs(pumpBuiding.vol.heatPort.Q_flow)",
  4184.0*RealBmax(5.0000000000000004E-08, fabs(DYNX(W_,615))),"4184.0*max(5.0000000000000004E-08, abs(coo.port_a2.m_flow))"),
   true, 0))," K > dTMax="),"200")," K.\n   This may indicate that energy is not conserved for small mass flow rates.\n   The implementation may require prescribedHeatFlowRate = false."));
PopAllMarks();
DYNX(W_,1462) = IF DYNX(W_,615) > 5.0000000000000004E-08 OR DYNX(W_,615) < 
  -5.0000000000000004E-08 THEN divmacro(1,"1",DYNX(W_,615),"coo.port_a2.m_flow")
   ELSE IF DYNX(W_,615) < 2.5000000000000002E-08 AND DYNX(W_,615) > 
  -2.5000000000000002E-08 THEN 399999999999999.94*DYNX(W_,615) ELSE 
  (PushModelContext(1,"Buildings.Utilities.Math.Functions.BaseClasses.smoothTransition(coo.port_a2.m_flow, 5.0000000000000004E-08, 20000000.0, -300000000.0, 4.76E+16, -2.888E+24, 8.544E+31, -1.216E+39, 6.656E+45)")
  Buildings_Utilities_Math_Functions_BaseClasses_smoothTransition(DYNX(W_,615), 
  5.0000000000000004E-08, 20000000.0, -300000000.0, 4.76E+16, -2.888E+24, 
  8.544E+31, -1.216E+39, 6.656E+45));
PopModelContext();
DYNX(W_,1107) = DYNX(Aux_,23)+DYNX(W_,1118)*DYNX(W_,1462);
DYNX(W_,1048) = DYNX(W_,1107);
DYNX(W_,1504) = DYNX(W_,1048)*DYNX(W_,615);
DYNX(W_,617) = DYNX(W_,1246)+DYNX(W_,656)*DYNX(W_,753);
DYNX(W_,1505) =  -DYNX(W_,1251)*DYNX(W_,615);
DYNX(W_,1501) = DYNX(W_,1504)+DYNX(W_,1505);
DYNX(W_,1314) = DYNX(DP_,361)*DYNX(W_,189);
DYNX(W_,1315) = DYNX(DP_,359)*DYNX(W_,1314);
DYNX(F_,20) = DYNX(W_,1501)+DYNX(W_,1315);
DYNX(F_,11) = DYNX(F_,10)*(IF DYNX(F_,10) > 0.0 THEN DYNX(W_,618) ELSE 
  DYNX(W_,1246));
DYNX(W_,891) = 273.15+0.0002390057361376673*DYNX(W_,988);
DYNX(W_,689) = IF DYNX(W_,612) > 5.0000000000000004E-08 OR DYNX(W_,612) < 
  -5.0000000000000004E-08 THEN divmacro(1,"1",DYNX(W_,612),"coo.port_a1.m_flow")
   ELSE IF DYNX(W_,612) < 2.5000000000000002E-08 AND DYNX(W_,612) > 
  -2.5000000000000002E-08 THEN 399999999999999.94*DYNX(W_,612) ELSE 
  (PushModelContext(1,"Buildings.Utilities.Math.Functions.BaseClasses.smoothTransition(coo.port_a1.m_flow, 5.0000000000000004E-08, 20000000.0, -300000000.0, 4.76E+16, -2.888E+24, 8.544E+31, -1.216E+39, 6.656E+45)")
  Buildings_Utilities_Math_Functions_BaseClasses_smoothTransition(DYNX(W_,612), 
  5.0000000000000004E-08, 20000000.0, -300000000.0, 4.76E+16, -2.888E+24, 
  8.544E+31, -1.216E+39, 6.656E+45));
PopModelContext();
DYNX(W_,613) = DYNX(Aux_,4)-DYNX(W_,656)*DYNX(W_,689);
DYNX(W_,892) = 273.15+0.0002390057361376673*DYNX(W_,613);
DYNX(W_,890) = IF DYNX(W_,612) > 5E-05 THEN DYNX(W_,891) ELSE IF DYNX(W_,612) < 
  -5E-05 THEN DYNX(W_,892) ELSE 5000.0*DYNX(W_,612)*(sqr(20000.0*DYNX(W_,612))-3)
  *(DYNX(W_,892)-DYNX(W_,891))+0.5*(DYNX(W_,891)+DYNX(W_,892));
DYNX(W_,885) = 2.0*DYNX(W_,612);
DYNX(W_,883) = IF DYNX(W_,612) > 5E-05 THEN DYNX(W_,885) ELSE IF DYNX(W_,612) < 
  -5E-05 THEN  -DYNX(W_,885) ELSE (-10000.0)*DYNX(W_,612)*(sqr(20000.0*
  DYNX(W_,612))-3)*DYNX(W_,885);
DYNX(F_,0) = (DYNX(W_,890)-DYNX(X_,0))*DYNX(W_,883);
DYNX(W_,614) = DYNX(W_,988)+DYNX(W_,656)*DYNX(W_,689);
DYNX(W_,906) = 273.15+0.0002390057361376673*DYNX(W_,614);
DYNX(W_,905) = IF DYNX(W_,612) > 5E-05 THEN DYNX(W_,906) ELSE IF DYNX(W_,612) < 
  -5E-05 THEN DYNX(W_,907) ELSE 5000.0*DYNX(W_,612)*(sqr(20000.0*DYNX(W_,612))-3)
  *(DYNX(W_,907)-DYNX(W_,906))+0.5*(DYNX(W_,906)+DYNX(W_,907));
DYNX(W_,900) = 2.0*DYNX(W_,612);
DYNX(W_,898) = IF DYNX(W_,612) > 5E-05 THEN DYNX(W_,900) ELSE IF DYNX(W_,612) < 
  -5E-05 THEN  -DYNX(W_,900) ELSE (-10000.0)*DYNX(W_,612)*(sqr(20000.0*
  DYNX(W_,612))-3)*DYNX(W_,900);
DYNX(F_,1) = (DYNX(W_,905)-DYNX(X_,1))*DYNX(W_,898);
DYNX(W_,976) = DYNX(DP_,295)*DYNX(X_,0)+DYNX(DP_,296)*DYNX(X_,1);
DYNX(W_,975) = DYNX(W_,976)*DYNX(W_,612);
DYNX(W_,628) = 4184.0*DYNX(W_,975);
DYNX(F_,2) = DYNX(DP_,274)*DYNX(W_,628);
DYNX(W_,1011) = 273.15+0.0002390057361376673*DYNX(W_,988);
DYNX(W_,1012) = 273.15+0.0002390057361376673*DYNX(W_,613);
DYNX(W_,1010) = IF DYNX(W_,612) > DYNX(W_,1000) THEN DYNX(W_,1011) ELSE IF 
  DYNX(W_,612) <  -DYNX(W_,1000) THEN DYNX(W_,1012) ELSE IF DYNX(W_,1000) > 0
   THEN divmacro(0.25*DYNX(W_,612)*(sqr(divmacro(DYNX(W_,612),"coo.port_a1.m_flow",
  DYNX(W_,1000),"TDisSup.m_flow_small"))-3)*(DYNX(W_,1012)-DYNX(W_,1011)),
  "0.25*(coo.port_a1.m_flow*((coo.port_a1.m_flow/TDisSup.m_flow_small)^2-3)*(TDisSup.T_b_inflow-TDisSup.T_a_inflow))",
  DYNX(W_,1000),"TDisSup.m_flow_small")+0.5*(DYNX(W_,1011)+DYNX(W_,1012)) ELSE 
  0.5*(DYNX(W_,1011)+DYNX(W_,1012));
DYNX(W_,1005) = divmacro(DYNX(W_,612),"coo.port_a1.m_flow",DYNX(W_,999),
  "TDisSup.m_flow_nominal");
DYNX(W_,1003) = IF DYNX(W_,612) > DYNX(W_,1000) THEN DYNX(W_,1005) ELSE IF 
  DYNX(W_,612) <  -DYNX(W_,1000) THEN  -DYNX(W_,1005) ELSE IF DYNX(W_,1000) > 0
   THEN divmacro((-0.5)*DYNX(W_,612)*(sqr(divmacro(DYNX(W_,612),"coo.port_a1.m_flow",
  DYNX(W_,1000),"TDisSup.m_flow_small"))-3)*DYNX(W_,1005),"(-0.5)*(coo.port_a1.m_flow*((coo.port_a1.m_flow/TDisSup.m_flow_small)^2-3)*TDisSup.mNor_flow)",
  DYNX(W_,1000),"TDisSup.m_flow_small") ELSE 0.0;
DYNX(F_,6) = (DYNX(W_,1010)-DYNX(X_,6))*DYNX(W_,1003);
DYNX(W_,1027) = 273.15+0.0002390057361376673*DYNX(W_,614);
DYNX(W_,1026) = IF DYNX(W_,612) > DYNX(W_,1016) THEN DYNX(W_,1027) ELSE IF 
  DYNX(W_,612) <  -DYNX(W_,1016) THEN DYNX(W_,1028) ELSE IF DYNX(W_,1016) > 0
   THEN divmacro(0.25*DYNX(W_,612)*(sqr(divmacro(DYNX(W_,612),"coo.port_a1.m_flow",
  DYNX(W_,1016),"TDisRet.m_flow_small"))-3)*(DYNX(W_,1028)-DYNX(W_,1027)),
  "0.25*(coo.port_a1.m_flow*((coo.port_a1.m_flow/TDisRet.m_flow_small)^2-3)*(TDisRet.T_b_inflow-TDisRet.T_a_inflow))",
  DYNX(W_,1016),"TDisRet.m_flow_small")+0.5*(DYNX(W_,1027)+DYNX(W_,1028)) ELSE 
  0.5*(DYNX(W_,1027)+DYNX(W_,1028));
DYNX(W_,1021) = divmacro(DYNX(W_,612),"coo.port_a1.m_flow",DYNX(W_,1015),
  "TDisRet.m_flow_nominal");
DYNX(W_,1019) = IF DYNX(W_,612) > DYNX(W_,1016) THEN DYNX(W_,1021) ELSE IF 
  DYNX(W_,612) <  -DYNX(W_,1016) THEN  -DYNX(W_,1021) ELSE IF DYNX(W_,1016) > 0
   THEN divmacro((-0.5)*DYNX(W_,612)*(sqr(divmacro(DYNX(W_,612),"coo.port_a1.m_flow",
  DYNX(W_,1016),"TDisRet.m_flow_small"))-3)*DYNX(W_,1021),"(-0.5)*(coo.port_a1.m_flow*((coo.port_a1.m_flow/TDisRet.m_flow_small)^2-3)*TDisRet.mNor_flow)",
  DYNX(W_,1016),"TDisRet.m_flow_small") ELSE 0.0;
DYNX(F_,7) = (DYNX(W_,1026)-DYNX(X_,7))*DYNX(W_,1019);
DYNX(W_,194) = DYNX(DP_,240)+(IF LessTime(DYNX(DP_,241), 5) THEN 0 ELSE 
  DYNX(DP_,237)*sin(6.283185307179586*DYNX(DP_,238)*(DYNTime-DYNX(DP_,241))+
  DYNX(DP_,239)));
 /* Linear system of equations to solve. */
/* Introducing 1 common subexpressions used in 1 expressions */
/* Of the common subexpressions 1 are reals, 0 are integers, and 0
   are booleans. */
DYNX(DYNhelp,155) = divmacro(1.0,"1.0",DYNX(W_,1340),"building.heaLoaO[1].G");
DYNX(F_,12) = RememberSimple_(DYNX(F_,12), 4);
SolveScalarLinearParametric(DYNX(DP_,389),"building.heaLoaO[1].tau",  -(
  DYNX(DYNhelp,155)*DYNX(W_,194)-DYNX(W_,526)+DYNX(X_,12))," -(building.Q_flowHeaReq[2]/building.heaLoaO[1].G-building.from_degC1.y+building.heaLoaO[1].TInd)",
   DYNX(F_,12),"der(building.heaLoaO[1].TInd)");
 /* End of Equation Block */ 

DYNX(F_,14) = 0.0;
DYNX(W_,524) = DYNTime;
beginwhenBlock
whenModelica(GreaterEqualTimeMinor(PRE(DYNX(W_,520), 8), 6), 2) 
  DYNX(W_,521) = (PushModelContext(1,"Modelica.Blocks.Sources.CombiTimeTable.getNextTimeEvent(\nbuilding.intGai.tableID, \nbuilding.intGai.timeScaled, \nbuilding.intGai.tableOnFileRead)")
    Modelica_Blocks_Sources_CombiTimeTable_getNextTimeEvent_M(DymStruc0_construct(
    (Integer)(DYNX(W_,519))), DYNX(W_,524), DYNX(W_,522)));
  PopModelContext();
endwhenModelica()
endwhenBlock


DYNX(DYNhelp,156) = (PushModelContext(1,"Modelica.Blocks.Sources.CombiTimeTable.getTableValue(\nbuilding.intGai.tableID, \n3, \nbuilding.intGai.timeScaled, \nbuilding.intGai.nextTimeEventScaled, \npre(building.intGai.nextTimeEventScaled), \nbuilding.intGai.tableOnFileRead)")
  Modelica_Blocks_Sources_CombiTimeTable_getTableValue_M(DymStruc0_construct(
  (Integer)(DYNX(W_,519))), 3, DYNX(W_,524), DYNX(W_,521), PRE(DYNX(W_,521), 0),
   DYNX(W_,522)));
PopModelContext();
DYNX(W_,508) = DYNX(W_,518)+DYNX(DYNhelp,156);
 /* Linear system of equations to solve. */
DYNX(W_,1366) = RememberSimple_(DYNX(W_,1366), 5);
SolveScalarLinear( -DYNX(X_,14)," -building.thermalZoneOneElement.volAir.dynBal.m",
    -DYNX(X_,13)," -building.thermalZoneOneElement.volAir.dynBal.U", 
  DYNX(W_,1366),"building.thermalZoneOneElement.volAir.dynBal.medium.u");
 /* End of Equation Block */ 


 /* Linear system of equations to solve. */
/* Tag: simulation.linear[1] */
DYNX(W_,1364) = (-0.001391983740000293)*((-299774.9175)-DYNX(W_,1366));

DYNX(W_,446) = 1005.45*(DYNX(W_,1364)-298.15);
 /* End of Equation Block */ 

AssertModelica(GreaterEqual(DYNX(W_,1364),"building.thermalZoneOneElement.volAir.dynBal.medium.T",
   273.15,"273.15", 8) AND LessEqual(DYNX(W_,1364),"building.thermalZoneOneElement.volAir.dynBal.medium.T",
   373.15,"373.15", 9),"building.thermalZoneOneElement.volAir.dynBal.medium.T >= 273.15 and building.thermalZoneOneElement.volAir.dynBal.medium.T <= 373.15",
   StringAdd(StringAdd(StringAdd(StringAdd(StringAdd(StringAdd(StringAdd(
  StringAdd("\nTemperature T (= ",Real2String2(DYNX(W_,1364), true, 0)),
  " K) is not\nin the allowed range ("),"273.15")," K <= T <= "),"373.15"),
  " K)\nrequired from medium model \""),"SimpleAir"),"\".\n"));
PopAllMarks();
DYNX(W_,188) = 298.15+0.0009945795414988312*DYNX(W_,446);
DYNX(W_,525) =  -DYNX(W_,508)*(1+DYNX(DP_,203)*(DYNX(W_,188)-DYNX(DP_,202)));
DYNX(DYNhelp,157) = (PushModelContext(1,"Modelica.Blocks.Sources.CombiTimeTable.getTableValue(\nbuilding.intGai.tableID, \n2, \nbuilding.intGai.timeScaled, \nbuilding.intGai.nextTimeEventScaled, \npre(building.intGai.nextTimeEventScaled), \nbuilding.intGai.tableOnFileRead)")
  Modelica_Blocks_Sources_CombiTimeTable_getTableValue_M(DymStruc0_construct(
  (Integer)(DYNX(W_,519))), 2, DYNX(W_,524), DYNX(W_,521), PRE(DYNX(W_,521), 0),
   DYNX(W_,522)));
PopModelContext();
DYNX(W_,505) = DYNX(W_,517)+DYNX(DYNhelp,157);
DYNX(W_,506) =  -DYNX(W_,505)*(1+DYNX(DP_,88)*(DYNX(W_,188)-DYNX(DP_,87)));
DYNX(W_,1348) =  -(DYNX(W_,525)-DYNX(W_,189)+DYNX(W_,506));
DYNX(W_,106) = DYNTime;
beginwhenBlock
whenModelica(DYNX(W_,134) AND GreaterMinor(DYNX(W_,106),"weaDat.modTim.y", PRE(
  DYNX(W_,135), 6),"pre(weaDat.conTim.tNext)", 18), 3) 
  DYNX(W_,135) = IF DYNX(W_,134) THEN real2integer(divmacro(DYNX(W_,106),
    "weaDat.modTim.y",DYNX(W_,133),"weaDat.conTim.lenWea"))*DYNX(W_,133)+
    DYNX(W_,133) ELSE DYNTime;
endwhenModelica()
endwhenBlock


DYNX(W_,22) = IF DYNX(W_,134) THEN DYNX(W_,106)-DYNX(W_,135)+DYNX(W_,133) ELSE 
  DYNX(W_,106);
DYNX(W_,23) = (PushModelContext(1,"Modelica.Blocks.Tables.CombiTable1Ds.getTableValue(\nweaDat.datRea.tableID, \n1, \nweaDat.datRea.u, \nweaDat.datRea.tableOnFileRead)")
  Modelica_Blocks_Tables_CombiTable1Ds_getTableValue_M(DymStruc0_construct(
  (Integer)(DYNX(W_,74))), 1, DYNX(W_,22), DYNX(W_,75)));
PopModelContext();
DYNX(W_,142) = 273.15+DYNX(W_,23);
DYNX(W_,151) = (PushModelContext(1,"Modelica.Blocks.Tables.CombiTable1Ds.getTableValue(\nweaDat.datRea.tableID, \n26, \nweaDat.datRea.u, \nweaDat.datRea.tableOnFileRead)")
  Modelica_Blocks_Tables_CombiTable1Ds_getTableValue_M(DymStruc0_construct(
  (Integer)(DYNX(W_,74))), 26, DYNX(W_,22), DYNX(W_,75)));
PopModelContext();
DYNX(W_,96) = IF DYNX(W_,151)-0.0001 > 1E-05 THEN DYNX(W_,151) ELSE IF 
  DYNX(W_,151)-0.0001 < -1E-05 THEN 0.0001 ELSE 5E-05+24999.999999999996*(
  DYNX(W_,151)-0.0001)*(sqr(99999.99999999999*(DYNX(W_,151)-0.0001))-3)*(0.0001-
  DYNX(W_,151))+0.5*DYNX(W_,151);
DYNX(W_,144) = powmacro(17635542.814071823*DYNX(W_,96),"17635542.814071823*weaDat.cheHorRad.HOut",
  0.25,"0.25");
DYNX(W_,489) = divmacro((DYNX(W_,144)-DYNX(W_,142))*DYNX(DP_,79),
  "(weaDat.TBlaSky_in_internal-weaDat.TDryBul_in_internal)*building.eqAirTemp.hRad",
  DYNX(DP_,79)+DYNX(DP_,80),"building.eqAirTemp.hRad+building.eqAirTemp.hConWinOut");
DYNX(W_,486) = DYNX(W_,142)+DYNX(W_,489)*(1-DYNX(DP_,200));
DYNX(W_,487) = DYNX(W_,142)+DYNX(W_,489)*(1-DYNX(DP_,201));
DYNX(W_,495) = DYNX(W_,486)*DYNX(DP_,74)+DYNX(W_,487)*DYNX(DP_,75);
DYNX(DYNhelp,158) = (PushModelContext(1,"Modelica.Blocks.Sources.CombiTimeTable.getTableValue(\nbuilding.intGai.tableID, \n1, \nbuilding.intGai.timeScaled, \nbuilding.intGai.nextTimeEventScaled, \npre(building.intGai.nextTimeEventScaled), \nbuilding.intGai.tableOnFileRead)")
  Modelica_Blocks_Sources_CombiTimeTable_getTableValue_M(DymStruc0_construct(
  (Integer)(DYNX(W_,519))), 1, DYNX(W_,524), DYNX(W_,521), PRE(DYNX(W_,521), 0),
   DYNX(W_,522)));
PopModelContext();
DYNX(W_,502) = DYNX(W_,516)+DYNX(DYNhelp,158);
DYNX(DYNhelp,159) = cos(0.17202423838958483+1.9910212776572317E-07*DYNX(W_,106));
DYNX(W_,325) = asinGuarded((-0.3979486313076103)*DYNX(DYNhelp,159),
  "(-0.3979486313076103)*cos(0.17202423838958483+1.9910212776572317E-07*weaDat.modTim.y)");
DYNX(W_,332) = cos(DYNX(W_,325));
DYNX(W_,113) = DYNX(W_,106)-576.0;
DYNX(W_,137) = 0.017261498096647215*(1.1574074074074073E-05*DYNX(W_,106)-80.0);
DYNX(DYNhelp,160) = sin(2*DYNX(W_,137));
DYNX(DYNhelp,161) = cos(DYNX(W_,137));
DYNX(DYNhelp,162) = sin(DYNX(W_,137));
DYNX(W_,136) = 60*(9.87*DYNX(DYNhelp,160)-7.53*DYNX(DYNhelp,161)-1.5*
  DYNX(DYNhelp,162));
DYNX(W_,138) = DYNX(W_,113)+DYNX(W_,136);
DYNX(W_,328) = 0.2617993877991494*(0.0002777777777777778*DYNX(W_,138)-12);
DYNX(W_,334) = cos(DYNX(W_,328));
DYNX(W_,333) = sin(DYNX(W_,325));
DYNX(W_,335) = sin(DYNX(W_,328));
if (NewParameters_) {
DYNX(DYNhelp,163) = cos(DYNX(W_,331));
}
DYNX(DYNhelp,164) = DYNX(W_,332)*DYNX(W_,334);
if (NewParameters_) {
DYNX(DYNhelp,165) = sin(DYNX(W_,331));
}
if (NewParameters_) {
DYNX(DYNhelp,166) = sin(DYNX(W_,330));
}
if (NewParameters_) {
DYNX(DYNhelp,167) = cos(DYNX(W_,330));
}
DYNX(DYNhelp,168) = DYNX(DYNhelp,164)*DYNX(W_,337);
DYNX(DYNhelp,169) = DYNX(W_,333)*DYNX(W_,336);
DYNX(W_,361) = acosGuarded(DYNX(DYNhelp,163)*(DYNX(DYNhelp,164)*DYNX(W_,336)+
  DYNX(W_,333)*DYNX(W_,337))+DYNX(DYNhelp,165)*(DYNX(DYNhelp,166)*DYNX(W_,332)*
  DYNX(W_,335)+DYNX(DYNhelp,167)*(DYNX(DYNhelp,168)-DYNX(DYNhelp,169))),
  "cos(building.HDirTil[1].incAng.incAng.til)*(building.HDirTil[1].incAng.incAng.dec_c*building.HDirTil[1].incAng.incAng.sol_c*building.HDirTil[1].incAng.incAng.lat_c+building.HDirTil[1].incAng.incAng.dec_s*building.HDirTil[1].incAng.incAng.lat_s)+sin(building.HDirTil[1].incAng.incAng.til)*(sin(building.HDirTil[1].incAng.incAng.azi)*building.HDirTil[1].incAng.incAng.dec_c*building.HDirTil[1].incAn...");
DYNX(W_,108) = 1800.0*DYNX(DP_,20)+DYNX(DP_,21)*DYNX(W_,106);
beginwhenBlock
whenModelica(DYNX(W_,128) AND GreaterMinor(DYNX(W_,108),"weaDat.add.y", PRE(
  DYNX(W_,129), 5),"pre(weaDat.conTim1.tNext)", 19), 4) 
  DYNX(W_,129) = IF DYNX(W_,128) THEN real2integer(divmacro(DYNX(W_,108),
    "weaDat.add.y",DYNX(W_,127),"weaDat.conTim1.lenWea"))*DYNX(W_,127)+
    DYNX(W_,127) ELSE DYNTime;
endwhenModelica()
endwhenBlock


DYNX(W_,116) = IF DYNX(W_,128) THEN DYNX(W_,108)-DYNX(W_,129)+DYNX(W_,127) ELSE 
  DYNX(W_,108);
DYNX(W_,150) = (PushModelContext(1,"Modelica.Blocks.Tables.CombiTable1Ds.getTableValue(\nweaDat.datRea1.tableID, \n2, \nweaDat.datRea1.u, \nweaDat.datRea1.tableOnFileRead)")
  Modelica_Blocks_Tables_CombiTable1Ds_getTableValue_M(DymStruc0_construct(
  (Integer)(DYNX(W_,122))), 2, DYNX(W_,116), DYNX(W_,123)));
PopModelContext();
DYNX(W_,90) = IF DYNX(W_,150)-0.0001 > 1E-05 THEN DYNX(W_,150) ELSE IF 
  DYNX(W_,150)-0.0001 < -1E-05 THEN 0.0001 ELSE 5E-05+24999.999999999996*(
  DYNX(W_,150)-0.0001)*(sqr(99999.99999999999*(DYNX(W_,150)-0.0001))-3)*(0.0001-
  DYNX(W_,150))+0.5*DYNX(W_,150);
DYNX(DYNhelp,170) = cos(DYNX(W_,361));
DYNX(W_,357) = RealBmax(0, DYNX(DYNhelp,170)*DYNX(W_,90));
DYNX(W_,377) = 57.29577951308232*(57.29577951308232*(57.29577951308232*(
  57.29577951308232*(57.29577951308232*(57.29577951308232*DYNX(DP_,54)*
  DYNX(W_,361)+DYNX(DP_,53))*DYNX(W_,361)+DYNX(DP_,52))*DYNX(W_,361)+
  DYNX(DP_,51))*DYNX(W_,361)+DYNX(DP_,50))*DYNX(W_,361)+DYNX(DP_,49))*
  DYNX(W_,361)+DYNX(DP_,48);
DYNX(DYNhelp,171) = sin(DYNX(W_,361));
DYNX(DYNhelp,172) = sqrtGuarded(1-sqr(0.6600660066006601*DYNX(DYNhelp,171)),
  "1-(0.6600660066006601*sin(building.corGDouPan.inc[1]))^2");
DYNX(DYNhelp,173) = divmacro(1,"1",DYNX(DYNhelp,172),"sqrt(1-(0.6600660066006601*sin(building.corGDouPan.inc[1]))^2)");
BreakSectionFunctionEnd()
BreakSectionFunctionStart(8);
DYNX(DYNhelp,174) = divmacro(1.0,"1.0",DYNX(DYNhelp,172),"sqrt(1-(0.6600660066006601*sin(building.corGDouPan.inc[1]))^2)");
DYNX(W_,379) = powmacro(0.907,"0.907",DYNX(DYNhelp,173),"1/sqrt(1-(0.6600660066006601*sin(building.corGDouPan.inc[1]))^2)");
DYNX(W_,381) = DYNX(W_,377)*DYNX(W_,379);
DYNX(W_,383) = 1-DYNX(W_,377);
DYNX(W_,385) = divmacro(DYNX(W_,383),"building.corGDouPan.rho_T1_dir[1]",2-
  DYNX(W_,383),"2-building.corGDouPan.rho_T1_dir[1]");
DYNX(W_,387) = DYNX(W_,385)+divmacro(sqr((1-DYNX(W_,385))*DYNX(W_,379))*
  DYNX(W_,385),"((1-building.corGDouPan.rho_11_dir[1])*building.corGDouPan.Tai_dir[1])^2*building.corGDouPan.rho_11_dir[1]",1
  -sqr(DYNX(W_,385)*DYNX(W_,379)),"1-(building.corGDouPan.rho_11_dir[1]*building.corGDouPan.Tai_dir[1])^2");
DYNX(W_,389) = 1.0-sqr(DYNX(W_,387));
DYNX(W_,391) = divmacro(sqr(DYNX(W_,381)),"building.corGDouPan.Ta1_dir[1]^2",
  DYNX(W_,389),"building.corGDouPan.XN2_dir[1]");
DYNX(W_,393) = 1-(DYNX(W_,381)+DYNX(W_,387));
DYNX(W_,395) = 0.04*DYNX(W_,393)*(1+divmacro(DYNX(W_,381)*DYNX(W_,387),
  "building.corGDouPan.Ta1_dir[1]*building.corGDouPan.rho_1_dir[1]",DYNX(W_,389),
  "building.corGDouPan.XN2_dir[1]"))*DYNX(DP_,47);
DYNX(W_,397) = divmacro(DYNX(W_,393)*DYNX(W_,381)*(1-DYNX(DP_,47)/(double)(7.7)),
  "building.corGDouPan.a1_dir[1]*building.corGDouPan.Ta1_dir[1]*(1-building.corGDouPan.UWin/7.7)",
  DYNX(W_,389),"building.corGDouPan.XN2_dir[1]");
DYNX(W_,399) = DYNX(W_,395)+DYNX(W_,397);
DYNX(W_,401) = divmacro(DYNX(W_,391)+DYNX(W_,399),"building.corGDouPan.Ta2_dir[1]+building.corGDouPan.Qsek2_dir[1]",
  DYNX(DP_,55),"building.corGDouPan.g_dir0");
DYNX(W_,149) = (PushModelContext(1,"Modelica.Blocks.Tables.CombiTable1Ds.getTableValue(\nweaDat.datRea1.tableID, \n3, \nweaDat.datRea1.u, \nweaDat.datRea1.tableOnFileRead)")
  Modelica_Blocks_Tables_CombiTable1Ds_getTableValue_M(DymStruc0_construct(
  (Integer)(DYNX(W_,122))), 3, DYNX(W_,116), DYNX(W_,123)));
PopModelContext();
DYNX(W_,88) = IF DYNX(W_,149)-0.0001 > 1E-05 THEN DYNX(W_,149) ELSE IF 
  DYNX(W_,149)-0.0001 < -1E-05 THEN 0.0001 ELSE 5E-05+24999.999999999996*(
  DYNX(W_,149)-0.0001)*(sqr(99999.99999999999*(DYNX(W_,149)-0.0001))-3)*(0.0001-
  DYNX(W_,149))+0.5*DYNX(W_,149);
DYNX(W_,148) = (PushModelContext(1,"Modelica.Blocks.Tables.CombiTable1Ds.getTableValue(\nweaDat.datRea1.tableID, \n1, \nweaDat.datRea1.u, \nweaDat.datRea1.tableOnFileRead)")
  Modelica_Blocks_Tables_CombiTable1Ds_getTableValue_M(DymStruc0_construct(
  (Integer)(DYNX(W_,122))), 1, DYNX(W_,116), DYNX(W_,123)));
PopModelContext();
DYNX(W_,86) = IF DYNX(W_,148)-0.0001 > 1E-05 THEN DYNX(W_,148) ELSE IF 
  DYNX(W_,148)-0.0001 < -1E-05 THEN 0.0001 ELSE 5E-05+24999.999999999996*(
  DYNX(W_,148)-0.0001)*(sqr(99999.99999999999*(DYNX(W_,148)-0.0001))-3)*(0.0001-
  DYNX(W_,148))+0.5*DYNX(W_,148);
DYNX(W_,222) = IF DYNX(W_,88)-5E-05 > 2.5E-05 THEN DYNX(W_,88) ELSE IF 
  DYNX(W_,88)-5E-05 < -2.5E-05 THEN 5E-05 ELSE 2.5E-05+10000.0*(DYNX(W_,88)-
  5E-05)*(sqr(40000.0*(DYNX(W_,88)-5E-05))-3)*(5E-05-DYNX(W_,88))+0.5*
  DYNX(W_,88);
DYNX(W_,164) = DYNX(W_,325);
DYNX(W_,163) = 0.2617993877991494*(0.0002777777777777778*DYNX(W_,138)-12);
DYNX(DYNhelp,175) = cos(DYNX(W_,164));
DYNX(DYNhelp,176) = cos(DYNX(W_,163));
DYNX(DYNhelp,177) = sin(DYNX(W_,164));
DYNX(W_,160) = acosGuarded(0.7920766142499671*DYNX(DYNhelp,175)*DYNX(DYNhelp,176)
  +0.6104216879816025*DYNX(DYNhelp,177),"0.7920766142499671*(cos(weaDat.zenAng.decAng)*cos(weaDat.zenAng.solHouAng))+0.6104216879816025*sin(weaDat.zenAng.decAng)");
DYNX(W_,221) = 1.040895310738997*powmacro2(DYNX(W_,160),"weaDat.altAng.zen",3,
  "3");
DYNX(DYNhelp,178) = divmacro(1.0,"1.0",DYNX(W_,222),"building.HDifTil[1].skyCle.HDifHorBou");
DYNX(DYNhelp,179) = 1+DYNX(W_,221);
DYNX(DYNhelp,180) = divmacro(1.0,"1.0",DYNX(DYNhelp,179),"1+building.HDifTil[1].skyCle.tmp1");
DYNX(W_,217) = (PushModelContext(1,"Buildings.Utilities.Math.Functions.smoothLimit((weaDat.cheGloHorRad.HOut/building.HDifTil[1].skyCle.HDifHorBou+building.HDifTil[1].skyCle.tmp1)/(1+building.HDifTil[1].skyCle.tmp1), 1, 8, 0.01)")
  Buildings_Utilities_Math_Functions_smoothLimit(DYNX(DYNhelp,180)*(
  DYNX(DYNhelp,178)*DYNX(W_,86)+DYNX(W_,221)), 1, 8, 0.01));
PopModelContext();
DYNX(W_,239) = IF 1.23-DYNX(W_,217) > 0.01 THEN 1 ELSE IF 1.23-DYNX(W_,217) < 
  -0.01 THEN 0 ELSE 0.5-25.0*(1.23-DYNX(W_,217))*(sqr(100.0*(1.23-DYNX(W_,217)))
  -3);
DYNX(W_,231) = IF 1.065-DYNX(W_,217) > 0.01 THEN 1 ELSE IF 1.065-DYNX(W_,217) < 
  -0.01 THEN 0 ELSE 0.5-25.0*(1.065-DYNX(W_,217))*(sqr(100.0*(1.065-DYNX(W_,217)))
  -3);
DYNX(W_,232) = DYNX(W_,239)-DYNX(W_,231);
DYNX(W_,240) = IF 1.5-DYNX(W_,217) > 0.01 THEN 1 ELSE IF 1.5-DYNX(W_,217) < 
  -0.01 THEN 0 ELSE 0.5-25.0*(1.5-DYNX(W_,217))*(sqr(100.0*(1.5-DYNX(W_,217)))-3);
DYNX(W_,233) = DYNX(W_,240)-DYNX(W_,239);
DYNX(W_,241) = IF 1.95-DYNX(W_,217) > 0.01 THEN 1 ELSE IF 1.95-DYNX(W_,217) < 
  -0.01 THEN 0 ELSE 0.5-25.0*(1.95-DYNX(W_,217))*(sqr(100.0*(1.95-DYNX(W_,217)))
  -3);
DYNX(W_,234) = DYNX(W_,241)-DYNX(W_,240);
DYNX(W_,242) = IF 2.8-DYNX(W_,217) > 0.01 THEN 1 ELSE IF 2.8-DYNX(W_,217) < 
  -0.01 THEN 0 ELSE 0.5-25.0*(2.8-DYNX(W_,217))*(sqr(100.0*(2.8-DYNX(W_,217)))-3);
DYNX(W_,235) = DYNX(W_,242)-DYNX(W_,241);
DYNX(W_,243) = IF 4.5-DYNX(W_,217) > 0.01 THEN 1 ELSE IF 4.5-DYNX(W_,217) < 
  -0.01 THEN 0 ELSE 0.5-25.0*(4.5-DYNX(W_,217))*(sqr(100.0*(4.5-DYNX(W_,217)))-3);
DYNX(W_,236) = DYNX(W_,243)-DYNX(W_,242);
DYNX(W_,244) = IF 6.2-DYNX(W_,217) > 0.01 THEN 1 ELSE IF 6.2-DYNX(W_,217) < 
  -0.01 THEN 0 ELSE 0.5-25.0*(6.2-DYNX(W_,217))*(sqr(100.0*(6.2-DYNX(W_,217)))-3);
DYNX(W_,237) = DYNX(W_,244)-DYNX(W_,243);
DYNX(W_,238) = IF DYNX(W_,217)-6.2 > 0.01 THEN 1 ELSE IF DYNX(W_,217)-6.2 < 
  -0.01 THEN 0 ELSE 0.5-25.0*(DYNX(W_,217)-6.2)*(sqr(100.0*(DYNX(W_,217)-6.2))-3);
DYNX(W_,224) = 0.1299457*DYNX(W_,232)-0.0083117*DYNX(W_,231)+0.3296958*
  DYNX(W_,233)+0.5682053*DYNX(W_,234)+0.873028*DYNX(W_,235)+1.1326077*
  DYNX(W_,236)+1.0601591*DYNX(W_,237)+0.677747*DYNX(W_,238);
DYNX(W_,225) = 0.5877285*DYNX(W_,231)+0.6825954*DYNX(W_,232)+0.4868735*
  DYNX(W_,233)+0.1874525*DYNX(W_,234)-0.3920403*DYNX(W_,235)-1.2367284*
  DYNX(W_,236)-1.5999137*DYNX(W_,237)-0.3272588*DYNX(W_,238);
DYNX(W_,246) = IF 1.5707963267948966-DYNX(W_,160) > 0.01 THEN DYNX(W_,160) ELSE 
  IF 1.5707963267948966-DYNX(W_,160) < -0.01 THEN 1.5707963267948966 ELSE 
  0.7853981633974483+25.0*(1.5707963267948966-DYNX(W_,160))*(sqr(100.0*(
  1.5707963267948966-DYNX(W_,160)))-3)*(1.5707963267948966-DYNX(W_,160))+0.5*
  DYNX(W_,160);
DYNX(W_,247) = 0.3183098861837907*DYNX(W_,246)*180;
DYNX(DYNhelp,181) = cos(DYNX(W_,246));
DYNX(DYNhelp,182) = DYNX(DYNhelp,181)+0.15*powmacro(93.9-DYNX(W_,247),
  "93.9-building.HDifTil[1].relAirMas.zenDeg",-1.253,"-1.253");
DYNX(DYNhelp,183) = divmacro(1.0,"1.0",DYNX(DYNhelp,182),"cos(building.HDifTil[1].relAirMas.zenLim)+0.15*(93.9-building.HDifTil[1].relAirMas.zenDeg)^(-1.253)");
DYNX(W_,245) = DYNX(DYNhelp,183);
DYNX(W_,223) = IF 1-0.000731528895391368*DYNX(W_,88)*DYNX(W_,245) > 0.025 THEN 
  0.000731528895391368*DYNX(W_,88)*DYNX(W_,245) ELSE IF 1-0.000731528895391368*
  DYNX(W_,88)*DYNX(W_,245) < -0.025 THEN 1 ELSE 0.5+10.0*(1-0.000731528895391368
  *DYNX(W_,88)*DYNX(W_,245))*(sqr(40.0*(1-0.000731528895391368*DYNX(W_,88)*
  DYNX(W_,245)))-3)*(1-0.000731528895391368*DYNX(W_,88)*DYNX(W_,245))+
  0.000365764447695684*DYNX(W_,88)*DYNX(W_,245);
DYNX(W_,226) = (-0.0620636)*DYNX(W_,231)-0.1513725*DYNX(W_,232)-0.2210958*
  DYNX(W_,233)-0.295129*DYNX(W_,234)-0.3616149*DYNX(W_,235)-0.4118494*
  DYNX(W_,236)-0.3589221*DYNX(W_,237)-0.2504286*DYNX(W_,238);
DYNX(W_,211) = IF  -(DYNX(W_,224)+DYNX(W_,225)*DYNX(W_,223)+DYNX(W_,226)*
  DYNX(W_,160)) > 0.01 THEN 0 ELSE IF  -(DYNX(W_,224)+DYNX(W_,225)*DYNX(W_,223)+
  DYNX(W_,226)*DYNX(W_,160)) < -0.01 THEN DYNX(W_,224)+DYNX(W_,225)*DYNX(W_,223)
  +DYNX(W_,226)*DYNX(W_,160) ELSE 0.5*(DYNX(W_,224)+DYNX(W_,225)*DYNX(W_,223)+
  DYNX(W_,226)*DYNX(W_,160))-25.0*(DYNX(W_,224)+DYNX(W_,225)*DYNX(W_,223)+
  DYNX(W_,226)*DYNX(W_,160))*(sqr((-100.0)*(DYNX(W_,224)+DYNX(W_,225)*
  DYNX(W_,223)+DYNX(W_,226)*DYNX(W_,160)))-3)*(DYNX(W_,224)+DYNX(W_,225)*
  DYNX(W_,223)+DYNX(W_,226)*DYNX(W_,160));
DYNX(W_,251) = DYNX(W_,325);
DYNX(W_,258) = cos(DYNX(W_,251));
DYNX(W_,254) = 0.2617993877991494*(0.0002777777777777778*DYNX(W_,138)-12);
DYNX(W_,260) = cos(DYNX(W_,254));
DYNX(W_,259) = sin(DYNX(W_,251));
DYNX(W_,261) = sin(DYNX(W_,254));
if (NewParameters_) {
DYNX(DYNhelp,184) = cos(DYNX(W_,257));
}
DYNX(DYNhelp,185) = DYNX(W_,258)*DYNX(W_,260);
if (NewParameters_) {
DYNX(DYNhelp,186) = sin(DYNX(W_,257));
}
if (NewParameters_) {
DYNX(DYNhelp,187) = sin(DYNX(W_,256));
}
if (NewParameters_) {
DYNX(DYNhelp,188) = cos(DYNX(W_,256));
}
DYNX(DYNhelp,189) = DYNX(DYNhelp,185)*DYNX(W_,263);
DYNX(DYNhelp,190) = DYNX(W_,259)*DYNX(W_,262);
DYNX(W_,213) = acosGuarded(DYNX(DYNhelp,184)*(DYNX(DYNhelp,185)*DYNX(W_,262)+
  DYNX(W_,259)*DYNX(W_,263))+DYNX(DYNhelp,186)*(DYNX(DYNhelp,187)*DYNX(W_,258)*
  DYNX(W_,261)+DYNX(DYNhelp,188)*(DYNX(DYNhelp,189)-DYNX(DYNhelp,190))),
  "cos(building.HDifTil[1].incAng.incAng.til)*(building.HDifTil[1].incAng.incAng.dec_c*building.HDifTil[1].incAng.incAng.sol_c*building.HDifTil[1].incAng.incAng.lat_c+building.HDifTil[1].incAng.incAng.dec_s*building.HDifTil[1].incAng.incAng.lat_s)+sin(building.HDifTil[1].incAng.incAng.til)*(sin(building.HDifTil[1].incAng.incAng.azi)*building.HDifTil[1].incAng.incAng.dec_c*building.HDifTil[1].incAn...");
DYNX(W_,214) = IF  -cos(DYNX(W_,213)) > 0.01 THEN 0 ELSE IF  -cos(DYNX(W_,213))
   < -0.01 THEN cos(DYNX(W_,213)) ELSE 0.5*cos(DYNX(W_,213))-25.0*cos(
  DYNX(W_,213))*(sqr((-100.0)*cos(DYNX(W_,213)))-3)*cos(DYNX(W_,213));
DYNX(W_,215) = IF 0.08715574274765814-cos(DYNX(W_,160)) > 0.01 THEN 
  0.08715574274765814 ELSE IF 0.08715574274765814-cos(DYNX(W_,160)) < -0.01
   THEN cos(DYNX(W_,160)) ELSE 0.04357787137382907+25.0*(0.08715574274765814-cos
  (DYNX(W_,160)))*(sqr(100.0*(0.08715574274765814-cos(DYNX(W_,160))))-3)*(cos(
  DYNX(W_,160))-0.08715574274765814)+0.5*cos(DYNX(W_,160));
DYNX(W_,227) = (-0.0596012)*DYNX(W_,231)-0.0189325*DYNX(W_,232)+0.055414*
  DYNX(W_,233)+0.1088631*DYNX(W_,234)+0.2255647*DYNX(W_,235)+0.2877813*
  DYNX(W_,236)+0.2642124*DYNX(W_,237)+0.1561313*DYNX(W_,238);
DYNX(W_,228) = 0.0721249*DYNX(W_,231)+0.065965*DYNX(W_,232)-0.0639588*
  DYNX(W_,233)-0.1519229*DYNX(W_,234)-0.4620442*DYNX(W_,235)-0.8230357*
  DYNX(W_,236)-1.127234*DYNX(W_,237)-1.3765031*DYNX(W_,238);
DYNX(W_,229) = (-0.0220216)*DYNX(W_,231)-0.0288748*DYNX(W_,232)-0.0260542*
  DYNX(W_,233)-0.0139754*DYNX(W_,234)+0.0012448*DYNX(W_,235)+0.0558651*
  DYNX(W_,236)+0.1310694*DYNX(W_,237)+0.2506212*DYNX(W_,238);
DYNX(W_,212) = DYNX(W_,227)+DYNX(W_,228)*DYNX(W_,223)+DYNX(W_,229)*DYNX(W_,160);
DYNX(DYNhelp,191) = 1-DYNX(W_,211);
if (NewParameters_) {
DYNX(DYNhelp,192) = cos(DYNX(W_,210));
}
DYNX(DYNhelp,193) = 1+DYNX(DYNhelp,192);
DYNX(DYNhelp,194) = divmacro(1.0,"1.0",DYNX(W_,215),"building.HDifTil[1].HDifTil.b");
if (NewParameters_) {
DYNX(DYNhelp,195) = sin(DYNX(W_,210));
}
DYNX(W_,355) = DYNX(W_,88)*(0.5*DYNX(DYNhelp,191)*DYNX(DYNhelp,193)+
  DYNX(DYNhelp,194)*DYNX(W_,211)*DYNX(W_,214)+DYNX(W_,212)*DYNX(DYNhelp,195));
DYNX(W_,359) = 0.5*DYNX(W_,86)*DYNX(W_,209)*(1-DYNX(DYNhelp,192));
DYNX(W_,363) = DYNX(W_,357)*DYNX(W_,401)+DYNX(W_,355)*DYNX(W_,375)+DYNX(W_,359)*
  DYNX(W_,376);
DYNX(W_,1404) = DYNX(W_,469)*DYNX(W_,363);
DYNX(W_,341) = DYNX(W_,325);
DYNX(W_,348) = cos(DYNX(W_,341));
DYNX(W_,344) = 0.2617993877991494*(0.0002777777777777778*DYNX(W_,138)-12);
DYNX(W_,350) = cos(DYNX(W_,344));
DYNX(W_,349) = sin(DYNX(W_,341));
DYNX(W_,351) = sin(DYNX(W_,344));
if (NewParameters_) {
DYNX(DYNhelp,196) = cos(DYNX(W_,347));
}
DYNX(DYNhelp,197) = DYNX(W_,348)*DYNX(W_,350);
if (NewParameters_) {
DYNX(DYNhelp,198) = sin(DYNX(W_,347));
}
if (NewParameters_) {
DYNX(DYNhelp,199) = sin(DYNX(W_,346));
}
if (NewParameters_) {
DYNX(DYNhelp,200) = cos(DYNX(W_,346));
}
DYNX(DYNhelp,201) = DYNX(DYNhelp,197)*DYNX(W_,353);
DYNX(DYNhelp,202) = DYNX(W_,349)*DYNX(W_,352);
DYNX(W_,362) = acosGuarded(DYNX(DYNhelp,196)*(DYNX(DYNhelp,197)*DYNX(W_,352)+
  DYNX(W_,349)*DYNX(W_,353))+DYNX(DYNhelp,198)*(DYNX(DYNhelp,199)*DYNX(W_,348)*
  DYNX(W_,351)+DYNX(DYNhelp,200)*(DYNX(DYNhelp,201)-DYNX(DYNhelp,202))),
  "cos(building.HDirTil[2].incAng.incAng.til)*(building.HDirTil[2].incAng.incAng.dec_c*building.HDirTil[2].incAng.incAng.sol_c*building.HDirTil[2].incAng.incAng.lat_c+building.HDirTil[2].incAng.incAng.dec_s*building.HDirTil[2].incAng.incAng.lat_s)+sin(building.HDirTil[2].incAng.incAng.til)*(sin(building.HDirTil[2].incAng.incAng.azi)*building.HDirTil[2].incAng.incAng.dec_c*building.HDirTil[2].incAn...");
DYNX(DYNhelp,203) = cos(DYNX(W_,362));
DYNX(W_,358) = RealBmax(0, DYNX(DYNhelp,203)*DYNX(W_,90));
DYNX(W_,378) = 57.29577951308232*(57.29577951308232*(57.29577951308232*(
  57.29577951308232*(57.29577951308232*(57.29577951308232*DYNX(DP_,54)*
  DYNX(W_,362)+DYNX(DP_,53))*DYNX(W_,362)+DYNX(DP_,52))*DYNX(W_,362)+
  DYNX(DP_,51))*DYNX(W_,362)+DYNX(DP_,50))*DYNX(W_,362)+DYNX(DP_,49))*
  DYNX(W_,362)+DYNX(DP_,48);
DYNX(DYNhelp,204) = sin(DYNX(W_,362));
DYNX(DYNhelp,205) = sqrtGuarded(1-sqr(0.6600660066006601*DYNX(DYNhelp,204)),
  "1-(0.6600660066006601*sin(building.corGDouPan.inc[2]))^2");
DYNX(DYNhelp,206) = divmacro(1,"1",DYNX(DYNhelp,205),"sqrt(1-(0.6600660066006601*sin(building.corGDouPan.inc[2]))^2)");
DYNX(DYNhelp,207) = divmacro(1.0,"1.0",DYNX(DYNhelp,205),"sqrt(1-(0.6600660066006601*sin(building.corGDouPan.inc[2]))^2)");
DYNX(W_,380) = powmacro(0.907,"0.907",DYNX(DYNhelp,206),"1/sqrt(1-(0.6600660066006601*sin(building.corGDouPan.inc[2]))^2)");
DYNX(W_,382) = DYNX(W_,378)*DYNX(W_,380);
DYNX(W_,384) = 1-DYNX(W_,378);
DYNX(W_,386) = divmacro(DYNX(W_,384),"building.corGDouPan.rho_T1_dir[2]",2-
  DYNX(W_,384),"2-building.corGDouPan.rho_T1_dir[2]");
DYNX(W_,388) = DYNX(W_,386)+divmacro(sqr((1-DYNX(W_,386))*DYNX(W_,380))*
  DYNX(W_,386),"((1-building.corGDouPan.rho_11_dir[2])*building.corGDouPan.Tai_dir[2])^2*building.corGDouPan.rho_11_dir[2]",1
  -sqr(DYNX(W_,386)*DYNX(W_,380)),"1-(building.corGDouPan.rho_11_dir[2]*building.corGDouPan.Tai_dir[2])^2");
DYNX(W_,390) = 1.0-sqr(DYNX(W_,388));
DYNX(W_,392) = divmacro(sqr(DYNX(W_,382)),"building.corGDouPan.Ta1_dir[2]^2",
  DYNX(W_,390),"building.corGDouPan.XN2_dir[2]");
DYNX(W_,394) = 1-(DYNX(W_,382)+DYNX(W_,388));
DYNX(W_,396) = 0.04*DYNX(W_,394)*(1+divmacro(DYNX(W_,382)*DYNX(W_,388),
  "building.corGDouPan.Ta1_dir[2]*building.corGDouPan.rho_1_dir[2]",DYNX(W_,390),
  "building.corGDouPan.XN2_dir[2]"))*DYNX(DP_,47);
DYNX(W_,398) = divmacro(DYNX(W_,394)*DYNX(W_,382)*(1-DYNX(DP_,47)/(double)(7.7)),
  "building.corGDouPan.a1_dir[2]*building.corGDouPan.Ta1_dir[2]*(1-building.corGDouPan.UWin/7.7)",
  DYNX(W_,390),"building.corGDouPan.XN2_dir[2]");
DYNX(W_,400) = DYNX(W_,396)+DYNX(W_,398);
DYNX(W_,402) = divmacro(DYNX(W_,392)+DYNX(W_,400),"building.corGDouPan.Ta2_dir[2]+building.corGDouPan.Qsek2_dir[2]",
  DYNX(DP_,55),"building.corGDouPan.g_dir0");
DYNX(W_,280) = IF DYNX(W_,88)-5E-05 > 2.5E-05 THEN DYNX(W_,88) ELSE IF 
  DYNX(W_,88)-5E-05 < -2.5E-05 THEN 5E-05 ELSE 2.5E-05+10000.0*(DYNX(W_,88)-
  5E-05)*(sqr(40000.0*(DYNX(W_,88)-5E-05))-3)*(5E-05-DYNX(W_,88))+0.5*
  DYNX(W_,88);
DYNX(W_,279) = 1.040895310738997*powmacro2(DYNX(W_,160),"weaDat.altAng.zen",3,
  "3");
DYNX(DYNhelp,208) = divmacro(1.0,"1.0",DYNX(W_,280),"building.HDifTil[2].skyCle.HDifHorBou");
DYNX(DYNhelp,209) = 1+DYNX(W_,279);
DYNX(DYNhelp,210) = divmacro(1.0,"1.0",DYNX(DYNhelp,209),"1+building.HDifTil[2].skyCle.tmp1");
DYNX(W_,275) = (PushModelContext(1,"Buildings.Utilities.Math.Functions.smoothLimit((weaDat.cheGloHorRad.HOut/building.HDifTil[2].skyCle.HDifHorBou+building.HDifTil[2].skyCle.tmp1)/(1+building.HDifTil[2].skyCle.tmp1), 1, 8, 0.01)")
  Buildings_Utilities_Math_Functions_smoothLimit(DYNX(DYNhelp,210)*(
  DYNX(DYNhelp,208)*DYNX(W_,86)+DYNX(W_,279)), 1, 8, 0.01));
PopModelContext();
DYNX(W_,297) = IF 1.23-DYNX(W_,275) > 0.01 THEN 1 ELSE IF 1.23-DYNX(W_,275) < 
  -0.01 THEN 0 ELSE 0.5-25.0*(1.23-DYNX(W_,275))*(sqr(100.0*(1.23-DYNX(W_,275)))
  -3);
DYNX(W_,289) = IF 1.065-DYNX(W_,275) > 0.01 THEN 1 ELSE IF 1.065-DYNX(W_,275) < 
  -0.01 THEN 0 ELSE 0.5-25.0*(1.065-DYNX(W_,275))*(sqr(100.0*(1.065-DYNX(W_,275)))
  -3);
DYNX(W_,290) = DYNX(W_,297)-DYNX(W_,289);
DYNX(W_,298) = IF 1.5-DYNX(W_,275) > 0.01 THEN 1 ELSE IF 1.5-DYNX(W_,275) < 
  -0.01 THEN 0 ELSE 0.5-25.0*(1.5-DYNX(W_,275))*(sqr(100.0*(1.5-DYNX(W_,275)))-3);
DYNX(W_,291) = DYNX(W_,298)-DYNX(W_,297);
DYNX(W_,299) = IF 1.95-DYNX(W_,275) > 0.01 THEN 1 ELSE IF 1.95-DYNX(W_,275) < 
  -0.01 THEN 0 ELSE 0.5-25.0*(1.95-DYNX(W_,275))*(sqr(100.0*(1.95-DYNX(W_,275)))
  -3);
DYNX(W_,292) = DYNX(W_,299)-DYNX(W_,298);
DYNX(W_,300) = IF 2.8-DYNX(W_,275) > 0.01 THEN 1 ELSE IF 2.8-DYNX(W_,275) < 
  -0.01 THEN 0 ELSE 0.5-25.0*(2.8-DYNX(W_,275))*(sqr(100.0*(2.8-DYNX(W_,275)))-3);
DYNX(W_,293) = DYNX(W_,300)-DYNX(W_,299);
DYNX(W_,301) = IF 4.5-DYNX(W_,275) > 0.01 THEN 1 ELSE IF 4.5-DYNX(W_,275) < 
  -0.01 THEN 0 ELSE 0.5-25.0*(4.5-DYNX(W_,275))*(sqr(100.0*(4.5-DYNX(W_,275)))-3);
DYNX(W_,294) = DYNX(W_,301)-DYNX(W_,300);
DYNX(W_,302) = IF 6.2-DYNX(W_,275) > 0.01 THEN 1 ELSE IF 6.2-DYNX(W_,275) < 
  -0.01 THEN 0 ELSE 0.5-25.0*(6.2-DYNX(W_,275))*(sqr(100.0*(6.2-DYNX(W_,275)))-3);
DYNX(W_,295) = DYNX(W_,302)-DYNX(W_,301);
DYNX(W_,296) = IF DYNX(W_,275)-6.2 > 0.01 THEN 1 ELSE IF DYNX(W_,275)-6.2 < 
  -0.01 THEN 0 ELSE 0.5-25.0*(DYNX(W_,275)-6.2)*(sqr(100.0*(DYNX(W_,275)-6.2))-3);
DYNX(W_,282) = 0.1299457*DYNX(W_,290)-0.0083117*DYNX(W_,289)+0.3296958*
  DYNX(W_,291)+0.5682053*DYNX(W_,292)+0.873028*DYNX(W_,293)+1.1326077*
  DYNX(W_,294)+1.0601591*DYNX(W_,295)+0.677747*DYNX(W_,296);
DYNX(W_,283) = 0.5877285*DYNX(W_,289)+0.6825954*DYNX(W_,290)+0.4868735*
  DYNX(W_,291)+0.1874525*DYNX(W_,292)-0.3920403*DYNX(W_,293)-1.2367284*
  DYNX(W_,294)-1.5999137*DYNX(W_,295)-0.3272588*DYNX(W_,296);
DYNX(W_,304) = IF 1.5707963267948966-DYNX(W_,160) > 0.01 THEN DYNX(W_,160) ELSE 
  IF 1.5707963267948966-DYNX(W_,160) < -0.01 THEN 1.5707963267948966 ELSE 
  0.7853981633974483+25.0*(1.5707963267948966-DYNX(W_,160))*(sqr(100.0*(
  1.5707963267948966-DYNX(W_,160)))-3)*(1.5707963267948966-DYNX(W_,160))+0.5*
  DYNX(W_,160);
DYNX(W_,305) = 0.3183098861837907*DYNX(W_,304)*180;
DYNX(DYNhelp,211) = cos(DYNX(W_,304));
DYNX(DYNhelp,212) = DYNX(DYNhelp,211)+0.15*powmacro(93.9-DYNX(W_,305),
  "93.9-building.HDifTil[2].relAirMas.zenDeg",-1.253,"-1.253");
DYNX(DYNhelp,213) = divmacro(1.0,"1.0",DYNX(DYNhelp,212),"cos(building.HDifTil[2].relAirMas.zenLim)+0.15*(93.9-building.HDifTil[2].relAirMas.zenDeg)^(-1.253)");
DYNX(W_,303) = DYNX(DYNhelp,213);
DYNX(W_,281) = IF 1-0.000731528895391368*DYNX(W_,88)*DYNX(W_,303) > 0.025 THEN 
  0.000731528895391368*DYNX(W_,88)*DYNX(W_,303) ELSE IF 1-0.000731528895391368*
  DYNX(W_,88)*DYNX(W_,303) < -0.025 THEN 1 ELSE 0.5+10.0*(1-0.000731528895391368
  *DYNX(W_,88)*DYNX(W_,303))*(sqr(40.0*(1-0.000731528895391368*DYNX(W_,88)*
  DYNX(W_,303)))-3)*(1-0.000731528895391368*DYNX(W_,88)*DYNX(W_,303))+
  0.000365764447695684*DYNX(W_,88)*DYNX(W_,303);
DYNX(W_,284) = (-0.0620636)*DYNX(W_,289)-0.1513725*DYNX(W_,290)-0.2210958*
  DYNX(W_,291)-0.295129*DYNX(W_,292)-0.3616149*DYNX(W_,293)-0.4118494*
  DYNX(W_,294)-0.3589221*DYNX(W_,295)-0.2504286*DYNX(W_,296);
DYNX(W_,269) = IF  -(DYNX(W_,282)+DYNX(W_,283)*DYNX(W_,281)+DYNX(W_,284)*
  DYNX(W_,160)) > 0.01 THEN 0 ELSE IF  -(DYNX(W_,282)+DYNX(W_,283)*DYNX(W_,281)+
  DYNX(W_,284)*DYNX(W_,160)) < -0.01 THEN DYNX(W_,282)+DYNX(W_,283)*DYNX(W_,281)
  +DYNX(W_,284)*DYNX(W_,160) ELSE 0.5*(DYNX(W_,282)+DYNX(W_,283)*DYNX(W_,281)+
  DYNX(W_,284)*DYNX(W_,160))-25.0*(DYNX(W_,282)+DYNX(W_,283)*DYNX(W_,281)+
  DYNX(W_,284)*DYNX(W_,160))*(sqr((-100.0)*(DYNX(W_,282)+DYNX(W_,283)*
  DYNX(W_,281)+DYNX(W_,284)*DYNX(W_,160)))-3)*(DYNX(W_,282)+DYNX(W_,283)*
  DYNX(W_,281)+DYNX(W_,284)*DYNX(W_,160));
DYNX(W_,309) = DYNX(W_,325);
DYNX(W_,316) = cos(DYNX(W_,309));
DYNX(W_,312) = 0.2617993877991494*(0.0002777777777777778*DYNX(W_,138)-12);
DYNX(W_,318) = cos(DYNX(W_,312));
DYNX(W_,317) = sin(DYNX(W_,309));
DYNX(W_,319) = sin(DYNX(W_,312));
if (NewParameters_) {
DYNX(DYNhelp,214) = cos(DYNX(W_,315));
}
DYNX(DYNhelp,215) = DYNX(W_,316)*DYNX(W_,318);
if (NewParameters_) {
DYNX(DYNhelp,216) = sin(DYNX(W_,315));
}
if (NewParameters_) {
DYNX(DYNhelp,217) = sin(DYNX(W_,314));
}
if (NewParameters_) {
DYNX(DYNhelp,218) = cos(DYNX(W_,314));
}
DYNX(DYNhelp,219) = DYNX(DYNhelp,215)*DYNX(W_,321);
DYNX(DYNhelp,220) = DYNX(W_,317)*DYNX(W_,320);
DYNX(W_,271) = acosGuarded(DYNX(DYNhelp,214)*(DYNX(DYNhelp,215)*DYNX(W_,320)+
  DYNX(W_,317)*DYNX(W_,321))+DYNX(DYNhelp,216)*(DYNX(DYNhelp,217)*DYNX(W_,316)*
  DYNX(W_,319)+DYNX(DYNhelp,218)*(DYNX(DYNhelp,219)-DYNX(DYNhelp,220))),
  "cos(building.HDifTil[2].incAng.incAng.til)*(building.HDifTil[2].incAng.incAng.dec_c*building.HDifTil[2].incAng.incAng.sol_c*building.HDifTil[2].incAng.incAng.lat_c+building.HDifTil[2].incAng.incAng.dec_s*building.HDifTil[2].incAng.incAng.lat_s)+sin(building.HDifTil[2].incAng.incAng.til)*(sin(building.HDifTil[2].incAng.incAng.azi)*building.HDifTil[2].incAng.incAng.dec_c*building.HDifTil[2].incAn...");
DYNX(W_,272) = IF  -cos(DYNX(W_,271)) > 0.01 THEN 0 ELSE IF  -cos(DYNX(W_,271))
   < -0.01 THEN cos(DYNX(W_,271)) ELSE 0.5*cos(DYNX(W_,271))-25.0*cos(
  DYNX(W_,271))*(sqr((-100.0)*cos(DYNX(W_,271)))-3)*cos(DYNX(W_,271));
DYNX(W_,273) = IF 0.08715574274765814-cos(DYNX(W_,160)) > 0.01 THEN 
  0.08715574274765814 ELSE IF 0.08715574274765814-cos(DYNX(W_,160)) < -0.01
   THEN cos(DYNX(W_,160)) ELSE 0.04357787137382907+25.0*(0.08715574274765814-cos
  (DYNX(W_,160)))*(sqr(100.0*(0.08715574274765814-cos(DYNX(W_,160))))-3)*(cos(
  DYNX(W_,160))-0.08715574274765814)+0.5*cos(DYNX(W_,160));
DYNX(W_,285) = (-0.0596012)*DYNX(W_,289)-0.0189325*DYNX(W_,290)+0.055414*
  DYNX(W_,291)+0.1088631*DYNX(W_,292)+0.2255647*DYNX(W_,293)+0.2877813*
  DYNX(W_,294)+0.2642124*DYNX(W_,295)+0.1561313*DYNX(W_,296);
DYNX(W_,286) = 0.0721249*DYNX(W_,289)+0.065965*DYNX(W_,290)-0.0639588*
  DYNX(W_,291)-0.1519229*DYNX(W_,292)-0.4620442*DYNX(W_,293)-0.8230357*
  DYNX(W_,294)-1.127234*DYNX(W_,295)-1.3765031*DYNX(W_,296);
DYNX(W_,287) = (-0.0220216)*DYNX(W_,289)-0.0288748*DYNX(W_,290)-0.0260542*
  DYNX(W_,291)-0.0139754*DYNX(W_,292)+0.0012448*DYNX(W_,293)+0.0558651*
  DYNX(W_,294)+0.1310694*DYNX(W_,295)+0.2506212*DYNX(W_,296);
DYNX(W_,270) = DYNX(W_,285)+DYNX(W_,286)*DYNX(W_,281)+DYNX(W_,287)*DYNX(W_,160);
DYNX(DYNhelp,221) = 1-DYNX(W_,269);
if (NewParameters_) {
DYNX(DYNhelp,222) = cos(DYNX(W_,268));
}
DYNX(DYNhelp,223) = 1+DYNX(DYNhelp,222);
DYNX(DYNhelp,224) = divmacro(1.0,"1.0",DYNX(W_,273),"building.HDifTil[2].HDifTil.b");
if (NewParameters_) {
DYNX(DYNhelp,225) = sin(DYNX(W_,268));
}
DYNX(W_,356) = DYNX(W_,88)*(0.5*DYNX(DYNhelp,221)*DYNX(DYNhelp,223)+
  DYNX(DYNhelp,224)*DYNX(W_,269)*DYNX(W_,272)+DYNX(W_,270)*DYNX(DYNhelp,225));
DYNX(W_,360) = 0.5*DYNX(W_,86)*DYNX(W_,267)*(1-DYNX(DYNhelp,222));
DYNX(W_,364) = DYNX(W_,358)*DYNX(W_,402)+DYNX(W_,356)*DYNX(W_,375)+DYNX(W_,360)*
  DYNX(W_,376);
DYNX(W_,1406) = DYNX(W_,470)*DYNX(W_,364);
DYNX(W_,1408) =  -(DYNX(W_,1404)*DYNX(W_,1401)+DYNX(W_,1406)*DYNX(W_,1402));
DYNX(W_,1407) =  -(DYNX(W_,1404)*DYNX(W_,1399)+DYNX(W_,1406)*DYNX(W_,1400));

 /* Linear system of equations to solve. */
/* Tag: simulation.linear[2] */
/* Introducing 11 common subexpressions used in 10 expressions */
/* Of the common subexpressions 11 are reals, 0 are integers, and 0
   are booleans. */
DYNX(DYNhelp,226) = DYNX(W_,502)*(1-DYNX(DP_,86)*DYNX(DP_,85));
DYNX(DYNhelp,227) = DYNX(W_,1419)*DYNX(DYNhelp,226);
DYNX(DYNhelp,228) = DYNX(W_,502)*DYNX(DP_,86);
DYNX(DYNhelp,229) = DYNX(DYNhelp,228)*DYNX(W_,1419);
DYNX(DYNhelp,230) = DYNX(W_,475)*DYNX(W_,1419);
DYNX(DYNhelp,231) = 0.24759707804690506*DYNX(DYNhelp,229)+DYNX(DYNhelp,230);
DYNX(DYNhelp,232) = DYNX(DP_,242)*DYNX(W_,1387)*DYNX(DYNhelp,231);
DYNX(DYNhelp,233) = DYNX(W_,464)*DYNX(W_,1419);
DYNX(DYNhelp,234) = DYNX(W_,468)-0.3014225297962323*DYNX(DYNhelp,228)+
  DYNX(W_,475);
DYNX(DYNhelp,235) = 1.0+DYNX(W_,1387)*DYNX(DYNhelp,234);
DYNX(DYNhelp,236) = DYNX(DP_,242)*DYNX(DYNhelp,235);
/* Automatic tearing of linear system of 18 simultaneous equations
gave a linear system of 2 equations for numerical solution.*/
{
  const char*const varnames_[]={"building.theConWin.solid.T", "building.thermalZoneOneElement.convExtWall.solid.T"};
  const double nominal_[]={300.0, 300.0};
  DidLinearSystemOfEquations(J, b, y, 2, DYNX(DYNhelp,237), 24, DYNX(did_->helpvari_vec,61), 8);
  /* Jacobian depending on continuous variables */
  SetNeedFactor(J);
  if (NeedFactor(J)) {
    MatrixZeros(J);
    SetMatrixLeading(J, 1, 1, 2, DYNX(DYNhelp,232)+DYNX(DYNhelp,231));
    SetMatrixLeading(J, 1, 2, 2, 0.20338331410995772*DYNX(DYNhelp,229)-
      DYNX(DYNhelp,230)-DYNX(DYNhelp,233)-1.0);
    SetMatrixLeading(J, 2, 1, 2, DYNX(DYNhelp,236)+DYNX(DYNhelp,234));
    SetMatrixLeading(J, 2, 2, 2, (-0.24759707804690506)*DYNX(DYNhelp,228)-
      DYNX(W_,475));
  }
  SetVector(b, 1,  -(DYNX(X_,15)+0.45098039215686275*DYNX(DYNhelp,227)-
    DYNX(DYNhelp,232)*DYNX(W_,495)+DYNX(DYNhelp,233)*DYNX(W_,188)-DYNX(W_,1419)*
    DYNX(W_,1407)));
  SetVector(b, 2,  -(DYNX(W_,1408)+(-0.5490196078431373)*DYNX(DYNhelp,226)-
    DYNX(DYNhelp,236)*DYNX(W_,495)-DYNX(W_,468)*DYNX(W_,188)));
  SetVector(y, 1, RememberSimple_(DYNX(W_,499), 6));
  SetVector(y, 2, RememberSimple_(DYNX(W_,463), 7));
  SolveLinearSystemOfEquations(J, b, y, 2);
  DYNX(W_,499) = GetVector(y, 1);
  DYNX(W_,463) = GetVector(y, 2);
  EndStaticLinearSystemOfEquations(J);
}
DYNX(W_,498) = DYNX(W_,499)-DYNX(W_,495);
DYNX(W_,497) = DYNX(DP_,242)*DYNX(W_,498);
DYNX(W_,1386) =  -DYNX(W_,1387)*DYNX(W_,497);
DYNX(W_,467) = DYNX(W_,499)-DYNX(W_,1386);
DYNX(W_,503) = 0.45098039215686275*DYNX(W_,463)+0.5490196078431373*DYNX(W_,467);
DYNX(W_,504) =  -DYNX(W_,502)*(1+DYNX(DP_,86)*(DYNX(W_,503)-DYNX(DP_,85)));
DYNX(W_,1395) = 0.45098039215686275*DYNX(W_,504);
DYNX(W_,1396) = 0.5490196078431373*DYNX(W_,504);
DYNX(W_,466) = DYNX(W_,467)-DYNX(W_,188);
DYNX(W_,465) = DYNX(W_,468)*DYNX(W_,466);
DYNX(W_,474) = DYNX(W_,467)-DYNX(W_,463);
DYNX(W_,473) = DYNX(W_,475)*DYNX(W_,474);
DYNX(W_,462) = DYNX(W_,463)-DYNX(W_,188);
DYNX(W_,461) = DYNX(W_,464)*DYNX(W_,462);
DYNX(W_,1414) =  -(DYNX(W_,461)-DYNX(W_,473)+DYNX(W_,1395)+DYNX(W_,1407));
DYNX(W_,1418) = DYNX(W_,1419)*DYNX(W_,1414);
 /* End of Equation Block */ 

DYNX(W_,479) = DYNX(W_,471)*DYNX(W_,363);
DYNX(W_,480) = DYNX(W_,472)*DYNX(W_,364);
DYNX(W_,481) = DYNX(DP_,69)*DYNX(W_,479)+DYNX(DP_,70)*DYNX(W_,480);
DYNX(F_,13) = DYNX(W_,1348)+DYNX(W_,461)+DYNX(W_,481)+DYNX(W_,465);
DYNX(W_,488) = divmacro((DYNX(W_,144)-DYNX(W_,142))*DYNX(DP_,79),
  "(weaDat.TBlaSky_in_internal-weaDat.TDryBul_in_internal)*building.eqAirTemp.hRad",
  DYNX(DP_,79)+DYNX(DP_,78),"building.eqAirTemp.hRad+building.eqAirTemp.hConWallOut");
DYNX(W_,206) = DYNX(DP_,33)*DYNX(W_,355)+DYNX(DP_,34)*DYNX(W_,359);
DYNX(W_,492) = DYNX(DP_,81)*DYNX(W_,357)+DYNX(DP_,82)*DYNX(W_,206);
DYNX(W_,490) = divmacro(DYNX(DP_,71)*DYNX(W_,492),"building.eqAirTemp.aExt*building.eqAirTemp.HSol[1]",
  DYNX(DP_,79)+DYNX(DP_,78),"building.eqAirTemp.hRad+building.eqAirTemp.hConWallOut");
DYNX(W_,484) = DYNX(W_,142)+DYNX(W_,488)+DYNX(W_,490);
DYNX(W_,264) = DYNX(DP_,39)*DYNX(W_,356)+DYNX(DP_,40)*DYNX(W_,360);
DYNX(W_,493) = DYNX(DP_,83)*DYNX(W_,358)+DYNX(DP_,84)*DYNX(W_,264);
DYNX(W_,491) = divmacro(DYNX(DP_,71)*DYNX(W_,493),"building.eqAirTemp.aExt*building.eqAirTemp.HSol[2]",
  DYNX(DP_,79)+DYNX(DP_,78),"building.eqAirTemp.hRad+building.eqAirTemp.hConWallOut");
DYNX(W_,485) = DYNX(W_,142)+DYNX(W_,488)+DYNX(W_,491);
DYNX(W_,494) = DYNX(W_,484)*DYNX(DP_,72)+DYNX(W_,485)*DYNX(DP_,73)+DYNX(DP_,77)*
  DYNX(DP_,76);

 /* Linear system of equations to solve. */
/* Tag: simulation.linear[3] */
DYNX(W_,500) = RememberSimple_(DYNX(W_,500), 8);
SolveScalarLinearParametric(1.0+DYNX(W_,1421)*DYNX(DP_,204),"1.0+building.thermalZoneOneElement.extWallRC.thermResExtRem.R*building.alphaWall.k",
   DYNX(X_,15)-DYNX(W_,494),"building.thermalZoneOneElement.extWallRC.thermCapExt[1].T-building.eqAirTemp.TEqAir",
   DYNX(W_,500),"building.theConWall.dT");
DYNX(W_,496) = DYNX(DP_,204)*DYNX(W_,500);
DYNX(W_,1420) = DYNX(W_,1421)*DYNX(W_,496);
DYNX(W_,501) = DYNX(X_,15)-DYNX(W_,1420);
 /* End of Equation Block */ 

DYNX(W_,1417) = DYNX(W_,1414)-DYNX(W_,496);
 /* Linear system of equations to solve. */
DYNX(W_,1416) = RememberSimple_(DYNX(W_,1416), 9);
SolveScalarLinearParametric(DYNX(W_,1415),"building.thermalZoneOneElement.extWallRC.thermCapExt[1].C",
   DYNX(W_,1417),"building.thermalZoneOneElement.extWallRC.thermCapExt[1].port.Q_flow",
   DYNX(W_,1416),"building.thermalZoneOneElement.extWallRC.thermCapExt[1].der_T");
 /* End of Equation Block */ 

DYNX(F_,15) = DYNX(W_,1416);
DYNX(W_,545) = DYNX(W_,543)*DYNX(W_,526)+DYNX(W_,544)*DYNX(W_,188);
DYNX(W_,546) = DYNX(DP_,220)*DYNX(W_,545);
DYNX(W_,551) = DYNX(W_,546)+DYNX(X_,16);
DYNX(W_,566) = DYNX(W_,565)*DYNX(W_,551);
DYNX(W_,542) = IF DYNX(W_,566) > DYNX(W_,568) THEN DYNX(W_,568) ELSE IF 
  DYNX(W_,566) < DYNX(W_,569) THEN DYNX(W_,569) ELSE DYNX(W_,566);
DYNX(W_,564) = DYNX(W_,542)-DYNX(W_,566);
DYNX(W_,560) = DYNX(W_,567)*DYNX(W_,564);
DYNX(W_,561) = DYNX(W_,558)*DYNX(W_,526)+DYNX(W_,559)*DYNX(W_,188)+DYNX(DP_,221)
  *DYNX(W_,560);
DYNX(F_,16) = DYNX(W_,1422)*DYNX(W_,561);
BreakSectionFunctionEnd()
BreakSectionFunctionStart(9);
DYNX(W_,581) = DYNX(W_,579)*DYNX(W_,531)+DYNX(W_,580)*DYNX(W_,188);
DYNX(W_,582) = DYNX(DP_,235)*DYNX(W_,581);
DYNX(W_,587) = DYNX(W_,582)+DYNX(X_,17);
DYNX(W_,602) = DYNX(W_,601)*DYNX(W_,587);
DYNX(W_,578) = IF DYNX(W_,602) > DYNX(W_,604) THEN DYNX(W_,604) ELSE IF 
  DYNX(W_,602) < DYNX(W_,605) THEN DYNX(W_,605) ELSE DYNX(W_,602);
DYNX(W_,600) = DYNX(W_,578)-DYNX(W_,602);
DYNX(W_,596) = DYNX(W_,603)*DYNX(W_,600);
DYNX(W_,597) = DYNX(W_,594)*DYNX(W_,531)+DYNX(W_,595)*DYNX(W_,188)+DYNX(DP_,236)
  *DYNX(W_,596);
DYNX(F_,17) = DYNX(W_,1428)*DYNX(W_,597);
AssertModelica(Greater(DYNX(W_,142),"weaDat.TDryBul_in_internal", DYNX(DP_,16),
  "weaDat.cheTemDryBul.TMin", 10),"weaDat.TDryBul_in_internal > weaDat.cheTemDryBul.TMin",
   StringAdd("Temperature out of bounds.\n   TOut = ",Real2String2(DYNX(W_,142),
   true, 0)));
PopAllMarks();
AssertModelica(Less(DYNX(W_,142),"weaDat.TDryBul_in_internal", DYNX(DP_,17),
  "weaDat.cheTemDryBul.TMax", 11),"weaDat.TDryBul_in_internal < weaDat.cheTemDryBul.TMax",
   StringAdd("Temperature out of bounds.\n   TOut = ",Real2String2(DYNX(W_,142),
   true, 0)));
PopAllMarks();
AssertModelica(Greater(DYNX(W_,144),"weaDat.TBlaSky_in_internal", DYNX(DP_,23),
  "weaDat.cheTemBlaSky.TMin", 12),"weaDat.TBlaSky_in_internal > weaDat.cheTemBlaSky.TMin",
   StringAdd("Temperature out of bounds.\n   TOut = ",Real2String2(DYNX(W_,144),
   true, 0)));
PopAllMarks();
AssertModelica(Less(DYNX(W_,144),"weaDat.TBlaSky_in_internal", DYNX(DP_,24),
  "weaDat.cheTemBlaSky.TMax", 13),"weaDat.TBlaSky_in_internal < weaDat.cheTemBlaSky.TMax",
   StringAdd("Temperature out of bounds.\n   TOut = ",Real2String2(DYNX(W_,144),
   true, 0)));
PopAllMarks();

AcceptedSection1
DYNX(W_,24) = (PushModelContext(1,"Modelica.Blocks.Tables.CombiTable1Ds.getTableValue(\nweaDat.datRea.tableID, \n2, \nweaDat.datRea.u, \nweaDat.datRea.tableOnFileRead)")
  Modelica_Blocks_Tables_CombiTable1Ds_getTableValue_M(DymStruc0_construct(
  (Integer)(DYNX(W_,74))), 2, DYNX(W_,22), DYNX(W_,75)));
PopModelContext();
DYNX(W_,143) = 273.15+DYNX(W_,24);
DYNX(W_,1363) = 0.01904761904761905*DYNX(X_,14);
 /* Linear system of equations to solve. */
/* Introducing 1 common subexpressions used in 1 expressions */
/* Of the common subexpressions 1 are reals, 0 are integers, and 0
   are booleans. */
DYNX(DYNhelp,261) = divmacro(1.0,"1.0",287.0508037566665*DYNX(W_,1364),
  "287.0508037566665*building.thermalZoneOneElement.volAir.dynBal.medium.T");
DYNX(W_,1362) = RememberSimple_(DYNX(W_,1362), 10);
SolveScalarLinear( -DYNX(DYNhelp,261)," -1.0/(287.0508037566665*building.thermalZoneOneElement.volAir.dynBal.medium.T)",
    -DYNX(W_,1363)," -building.thermalZoneOneElement.volAir.dynBal.medium.d", 
  DYNX(W_,1362),"building.thermalZoneOneElement.volAir.dynBal.medium.p");
 /* End of Equation Block */ 

AssertModelica(GreaterEqual(DYNX(W_,1362),"building.thermalZoneOneElement.volAir.dynBal.medium.p",
   0.0,"0.0", 7),"building.thermalZoneOneElement.volAir.dynBal.medium.p >= 0.0",
   StringAdd(StringAdd(StringAdd(StringAdd(StringAdd(StringAdd("Pressure (= ",
  Real2String2(DYNX(W_,1362), true, 0))," Pa) of medium \""),"SimpleAir"),
  "\" is negative\n(Temperature = "),Real2String2(DYNX(W_,1364), true, 0))," K)"));
PopAllMarks();
DYNX(W_,1489) = (-0.0002390057361376673)*((-1142859.5999999999)-DYNX(W_,1251));
AssertModelica(GreaterEqual(DYNX(W_,1489),"CoolingUnit.vol.dynBal.medium.T", 
  272.15,"272.15", 20),"CoolingUnit.vol.dynBal.medium.T >= 272.15", 
  "\nIn CouplingETS_RC_Yanfei_Cooling.CoolingUnit.vol.dynBal.medium: Temperature T exceeded its minimum allowed value of -1 degC (272.15 Kelvin)\nas required from medium model \"SimpleLiquidWater\".");
AssertModelica(LessEqual(DYNX(W_,1489),"CoolingUnit.vol.dynBal.medium.T", 403.15,
  "403.15", 21),"CoolingUnit.vol.dynBal.medium.T <= 403.15", "\nIn CouplingETS_RC_Yanfei_Cooling.CoolingUnit.vol.dynBal.medium: Temperature T exceeded its maximum allowed value of 130 degC (403.15 Kelvin)\nas required from medium model \"SimpleLiquidWater\".");
beginwhenBlock
whenModelica(GreaterEqualTimeMinor(PRE(DYNX(W_,1330), 7), 0), 5) 
  DYNX(W_,1330) = IF DYNX(W_,1331) < 1.7976931348623157E+308 THEN 3600*
    DYNX(W_,1331) ELSE 1.7976931348623157E+308;
endwhenModelica()
endwhenBlock


beginwhenBlock
whenModelica(GreaterEqualTimeMinor(PRE(DYNX(W_,520), 8), 6), 6) 
  DYNX(W_,520) = IF DYNX(W_,521) < 1.7976931348623157E+308 THEN DYNX(W_,521)
     ELSE 1.7976931348623157E+308;
endwhenModelica()
endwhenBlock



AssertModelica(Greater(DYNX(W_,143),"weaDat.TDewPoi_in_internal", DYNX(DP_,18),
  "weaDat.cheTemDewPoi.TMin", 22),"weaDat.TDewPoi_in_internal > weaDat.cheTemDewPoi.TMin",
   StringAdd("Temperature out of bounds.\n   TOut = ",Real2String2(DYNX(W_,143),
   true, 0)));
PopAllMarks();
AssertModelica(Less(DYNX(W_,143),"weaDat.TDewPoi_in_internal", DYNX(DP_,19),
  "weaDat.cheTemDewPoi.TMax", 23),"weaDat.TDewPoi_in_internal < weaDat.cheTemDewPoi.TMax",
   StringAdd("Temperature out of bounds.\n   TOut = ",Real2String2(DYNX(W_,143),
   true, 0)));
PopAllMarks();
AcceptedSection2
DYNX(Aux_,8) = DYNX(W_,1246);
DYNX(Aux_,26) = DYNX(W_,617);
DYNX(Aux_,20) = DYNX(W_,618);
DYNX(Aux_,25) = DYNX(W_,1048);
DYNX(Aux_,1) = DYNX(W_,1251);
DYNX(Aux_,0) = DYNX(W_,1246);
DYNX(Aux_,2) = DYNX(W_,988);
DYNX(Aux_,5) = DYNX(W_,988);
DYNX(Aux_,6) = DYNX(W_,1251);
DYNX(Aux_,7) = DYNX(W_,1246);
DYNX(Aux_,9) = DYNX(W_,1251);
DYNX(Aux_,10) = DYNX(W_,988);
DYNX(Aux_,12) = DYNX(W_,1246);
DYNX(Aux_,15) = DYNX(W_,1107);
DYNX(Aux_,16) = DYNX(W_,1251);
DYNX(Aux_,17) = DYNX(W_,1107);
DYNX(Aux_,30) = DYNX(W_,615);
DYNX(Aux_,31) = IF DYNX(Aux_,30) > 5E-11 THEN 1.0 ELSE IF DYNX(Aux_,30) > 0.0
   THEN sqr(20000000000.0*DYNX(Aux_,30))*(3.0-40000000000.0*DYNX(Aux_,30)) ELSE 
  0.0;
DYNX(Aux_,18) = divmacro(5E-11*(1.0-DYNX(Aux_,31))*DYNX(W_,1251)+(DYNX(Aux_,31)*
  DYNX(W_,615)+5E-11*(1.0-DYNX(Aux_,31)))*DYNX(W_,1107),"5E-11*((1.0-stream_alpha4)*CoolingUnit.port_a.h_outflow)+(stream_alpha4*coo.port_a2.m_flow+5E-11*(1.0-stream_alpha4))*pumpBuiding.vol.ports[2].h_outflow",
  5E-11*(1.0-DYNX(Aux_,31))+DYNX(Aux_,31)*DYNX(W_,615)+5E-11*(1.0-DYNX(Aux_,31)),
  "5E-11*(1.0-stream_alpha4)+stream_alpha4*coo.port_a2.m_flow+5E-11*(1.0-stream_alpha4)");
DYNX(Aux_,19) = DYNX(W_,1107);
DYNX(Aux_,21) = DYNX(W_,617);
DYNX(Aux_,22) = DYNX(W_,1048);
DYNX(Aux_,24) = DYNX(W_,1107);
DYNX(W_,25) = (PushModelContext(1,"Modelica.Blocks.Tables.CombiTable1Ds.getTableValue(\nweaDat.datRea.tableID, \n3, \nweaDat.datRea.u, \nweaDat.datRea.tableOnFileRead)")
  Modelica_Blocks_Tables_CombiTable1Ds_getTableValue_M(DymStruc0_construct(
  (Integer)(DYNX(W_,74))), 3, DYNX(W_,22), DYNX(W_,75)));
PopModelContext();
DYNX(W_,26) = (PushModelContext(1,"Modelica.Blocks.Tables.CombiTable1Ds.getTableValue(\nweaDat.datRea.tableID, \n4, \nweaDat.datRea.u, \nweaDat.datRea.tableOnFileRead)")
  Modelica_Blocks_Tables_CombiTable1Ds_getTableValue_M(DymStruc0_construct(
  (Integer)(DYNX(W_,74))), 4, DYNX(W_,22), DYNX(W_,75)));
PopModelContext();
DYNX(W_,27) = (PushModelContext(1,"Modelica.Blocks.Tables.CombiTable1Ds.getTableValue(\nweaDat.datRea.tableID, \n5, \nweaDat.datRea.u, \nweaDat.datRea.tableOnFileRead)")
  Modelica_Blocks_Tables_CombiTable1Ds_getTableValue_M(DymStruc0_construct(
  (Integer)(DYNX(W_,74))), 5, DYNX(W_,22), DYNX(W_,75)));
PopModelContext();
DYNX(W_,28) = (PushModelContext(1,"Modelica.Blocks.Tables.CombiTable1Ds.getTableValue(\nweaDat.datRea.tableID, \n6, \nweaDat.datRea.u, \nweaDat.datRea.tableOnFileRead)")
  Modelica_Blocks_Tables_CombiTable1Ds_getTableValue_M(DymStruc0_construct(
  (Integer)(DYNX(W_,74))), 6, DYNX(W_,22), DYNX(W_,75)));
PopModelContext();
DYNX(W_,29) = (PushModelContext(1,"Modelica.Blocks.Tables.CombiTable1Ds.getTableValue(\nweaDat.datRea.tableID, \n7, \nweaDat.datRea.u, \nweaDat.datRea.tableOnFileRead)")
  Modelica_Blocks_Tables_CombiTable1Ds_getTableValue_M(DymStruc0_construct(
  (Integer)(DYNX(W_,74))), 7, DYNX(W_,22), DYNX(W_,75)));
PopModelContext();
DYNX(W_,30) = (PushModelContext(1,"Modelica.Blocks.Tables.CombiTable1Ds.getTableValue(\nweaDat.datRea.tableID, \n8, \nweaDat.datRea.u, \nweaDat.datRea.tableOnFileRead)")
  Modelica_Blocks_Tables_CombiTable1Ds_getTableValue_M(DymStruc0_construct(
  (Integer)(DYNX(W_,74))), 8, DYNX(W_,22), DYNX(W_,75)));
PopModelContext();
DYNX(W_,31) = (PushModelContext(1,"Modelica.Blocks.Tables.CombiTable1Ds.getTableValue(\nweaDat.datRea.tableID, \n9, \nweaDat.datRea.u, \nweaDat.datRea.tableOnFileRead)")
  Modelica_Blocks_Tables_CombiTable1Ds_getTableValue_M(DymStruc0_construct(
  (Integer)(DYNX(W_,74))), 9, DYNX(W_,22), DYNX(W_,75)));
PopModelContext();
DYNX(W_,32) = (PushModelContext(1,"Modelica.Blocks.Tables.CombiTable1Ds.getTableValue(\nweaDat.datRea.tableID, \n10, \nweaDat.datRea.u, \nweaDat.datRea.tableOnFileRead)")
  Modelica_Blocks_Tables_CombiTable1Ds_getTableValue_M(DymStruc0_construct(
  (Integer)(DYNX(W_,74))), 10, DYNX(W_,22), DYNX(W_,75)));
PopModelContext();
DYNX(W_,33) = (PushModelContext(1,"Modelica.Blocks.Tables.CombiTable1Ds.getTableValue(\nweaDat.datRea.tableID, \n11, \nweaDat.datRea.u, \nweaDat.datRea.tableOnFileRead)")
  Modelica_Blocks_Tables_CombiTable1Ds_getTableValue_M(DymStruc0_construct(
  (Integer)(DYNX(W_,74))), 11, DYNX(W_,22), DYNX(W_,75)));
PopModelContext();
DYNX(W_,34) = (PushModelContext(1,"Modelica.Blocks.Tables.CombiTable1Ds.getTableValue(\nweaDat.datRea.tableID, \n13, \nweaDat.datRea.u, \nweaDat.datRea.tableOnFileRead)")
  Modelica_Blocks_Tables_CombiTable1Ds_getTableValue_M(DymStruc0_construct(
  (Integer)(DYNX(W_,74))), 13, DYNX(W_,22), DYNX(W_,75)));
PopModelContext();
DYNX(W_,35) = (PushModelContext(1,"Modelica.Blocks.Tables.CombiTable1Ds.getTableValue(\nweaDat.datRea.tableID, \n14, \nweaDat.datRea.u, \nweaDat.datRea.tableOnFileRead)")
  Modelica_Blocks_Tables_CombiTable1Ds_getTableValue_M(DymStruc0_construct(
  (Integer)(DYNX(W_,74))), 14, DYNX(W_,22), DYNX(W_,75)));
PopModelContext();
DYNX(W_,36) = (PushModelContext(1,"Modelica.Blocks.Tables.CombiTable1Ds.getTableValue(\nweaDat.datRea.tableID, \n15, \nweaDat.datRea.u, \nweaDat.datRea.tableOnFileRead)")
  Modelica_Blocks_Tables_CombiTable1Ds_getTableValue_M(DymStruc0_construct(
  (Integer)(DYNX(W_,74))), 15, DYNX(W_,22), DYNX(W_,75)));
PopModelContext();
DYNX(W_,37) = (PushModelContext(1,"Modelica.Blocks.Tables.CombiTable1Ds.getTableValue(\nweaDat.datRea.tableID, \n17, \nweaDat.datRea.u, \nweaDat.datRea.tableOnFileRead)")
  Modelica_Blocks_Tables_CombiTable1Ds_getTableValue_M(DymStruc0_construct(
  (Integer)(DYNX(W_,74))), 17, DYNX(W_,22), DYNX(W_,75)));
PopModelContext();
DYNX(W_,38) = (PushModelContext(1,"Modelica.Blocks.Tables.CombiTable1Ds.getTableValue(\nweaDat.datRea.tableID, \n18, \nweaDat.datRea.u, \nweaDat.datRea.tableOnFileRead)")
  Modelica_Blocks_Tables_CombiTable1Ds_getTableValue_M(DymStruc0_construct(
  (Integer)(DYNX(W_,74))), 18, DYNX(W_,22), DYNX(W_,75)));
PopModelContext();
DYNX(W_,39) = (PushModelContext(1,"Modelica.Blocks.Tables.CombiTable1Ds.getTableValue(\nweaDat.datRea.tableID, \n19, \nweaDat.datRea.u, \nweaDat.datRea.tableOnFileRead)")
  Modelica_Blocks_Tables_CombiTable1Ds_getTableValue_M(DymStruc0_construct(
  (Integer)(DYNX(W_,74))), 19, DYNX(W_,22), DYNX(W_,75)));
PopModelContext();
DYNX(W_,40) = (PushModelContext(1,"Modelica.Blocks.Tables.CombiTable1Ds.getTableValue(\nweaDat.datRea.tableID, \n20, \nweaDat.datRea.u, \nweaDat.datRea.tableOnFileRead)")
  Modelica_Blocks_Tables_CombiTable1Ds_getTableValue_M(DymStruc0_construct(
  (Integer)(DYNX(W_,74))), 20, DYNX(W_,22), DYNX(W_,75)));
PopModelContext();
DYNX(W_,41) = (PushModelContext(1,"Modelica.Blocks.Tables.CombiTable1Ds.getTableValue(\nweaDat.datRea.tableID, \n21, \nweaDat.datRea.u, \nweaDat.datRea.tableOnFileRead)")
  Modelica_Blocks_Tables_CombiTable1Ds_getTableValue_M(DymStruc0_construct(
  (Integer)(DYNX(W_,74))), 21, DYNX(W_,22), DYNX(W_,75)));
PopModelContext();
DYNX(W_,42) = (PushModelContext(1,"Modelica.Blocks.Tables.CombiTable1Ds.getTableValue(\nweaDat.datRea.tableID, \n22, \nweaDat.datRea.u, \nweaDat.datRea.tableOnFileRead)")
  Modelica_Blocks_Tables_CombiTable1Ds_getTableValue_M(DymStruc0_construct(
  (Integer)(DYNX(W_,74))), 22, DYNX(W_,22), DYNX(W_,75)));
PopModelContext();
DYNX(W_,43) = (PushModelContext(1,"Modelica.Blocks.Tables.CombiTable1Ds.getTableValue(\nweaDat.datRea.tableID, \n23, \nweaDat.datRea.u, \nweaDat.datRea.tableOnFileRead)")
  Modelica_Blocks_Tables_CombiTable1Ds_getTableValue_M(DymStruc0_construct(
  (Integer)(DYNX(W_,74))), 23, DYNX(W_,22), DYNX(W_,75)));
PopModelContext();
DYNX(W_,44) = (PushModelContext(1,"Modelica.Blocks.Tables.CombiTable1Ds.getTableValue(\nweaDat.datRea.tableID, \n24, \nweaDat.datRea.u, \nweaDat.datRea.tableOnFileRead)")
  Modelica_Blocks_Tables_CombiTable1Ds_getTableValue_M(DymStruc0_construct(
  (Integer)(DYNX(W_,74))), 24, DYNX(W_,22), DYNX(W_,75)));
PopModelContext();
DYNX(W_,45) = (PushModelContext(1,"Modelica.Blocks.Tables.CombiTable1Ds.getTableValue(\nweaDat.datRea.tableID, \n25, \nweaDat.datRea.u, \nweaDat.datRea.tableOnFileRead)")
  Modelica_Blocks_Tables_CombiTable1Ds_getTableValue_M(DymStruc0_construct(
  (Integer)(DYNX(W_,74))), 25, DYNX(W_,22), DYNX(W_,75)));
PopModelContext();
DYNX(W_,140) = 0.1*DYNX(W_,34);
DYNX(W_,78) = (PushModelContext(1,"Buildings.Utilities.Math.Functions.smoothLimit(weaDat.totSkyCov_in_internal, 0.01, 9.99, 0.001)")
  Buildings_Utilities_Math_Functions_smoothLimit(DYNX(W_,140), 0.01, 9.99, 0.001));
PopModelContext();
DYNX(W_,141) = 0.1*DYNX(W_,35);
DYNX(W_,82) = (PushModelContext(1,"Buildings.Utilities.Math.Functions.smoothLimit(weaDat.opaSkyCov_in_internal, 0.01, 9.99, 0.001)")
  Buildings_Utilities_Math_Functions_smoothLimit(DYNX(W_,141), 0.01, 9.99, 0.001));
PopModelContext();
DYNX(W_,139) = (PushModelContext(1,"Modelica.Blocks.Tables.CombiTable1Ds.getTableValue(\nweaDat.datRea.tableID, \n16, \nweaDat.datRea.u, \nweaDat.datRea.tableOnFileRead)")
  Modelica_Blocks_Tables_CombiTable1Ds_getTableValue_M(DymStruc0_construct(
  (Integer)(DYNX(W_,74))), 16, DYNX(W_,22), DYNX(W_,75)));
PopModelContext();
DYNX(W_,92) = IF DYNX(W_,139) > 0.1 THEN DYNX(W_,139) ELSE IF DYNX(W_,139) < 
  -0.1 THEN 0 ELSE 0.5*DYNX(W_,139)-2.5*DYNX(W_,139)*(sqr(10.0*DYNX(W_,139))-3)*
  DYNX(W_,139);
DYNX(W_,146) = (PushModelContext(1,"Modelica.Blocks.Tables.CombiTable1Ds.getTableValue(\nweaDat.datRea.tableID, \n12, \nweaDat.datRea.u, \nweaDat.datRea.tableOnFileRead)")
  Modelica_Blocks_Tables_CombiTable1Ds_getTableValue_M(DymStruc0_construct(
  (Integer)(DYNX(W_,74))), 12, DYNX(W_,22), DYNX(W_,75)));
PopModelContext();
DYNX(W_,94) = IF DYNX(W_,146)-1E-06 > 1E-07 THEN DYNX(W_,146) ELSE IF 
  DYNX(W_,146)-1E-06 < -1E-07 THEN 1E-06 ELSE 5E-07+2500000.0*(DYNX(W_,146)-
  1E-06)*(sqr(10000000.0*(DYNX(W_,146)-1E-06))-3)*(1E-06-DYNX(W_,146))+0.5*
  DYNX(W_,146);
DYNX(W_,147) = 0.017453292519943295*DYNX(W_,33);
DYNX(W_,98) = (PushModelContext(1,"Buildings.Utilities.Math.Functions.smoothLimit(weaDat.winDir_in_internal, 0, 6.283185307179586, 0.001)")
  Buildings_Utilities_Math_Functions_smoothLimit(DYNX(W_,147), 0, 
  6.283185307179586, 0.001));
PopModelContext();
DYNX(W_,145) = 0.01*DYNX(W_,25);
DYNX(W_,156) = (PushModelContext(1,"Buildings.Utilities.Math.Functions.smoothLimit(weaDat.relHum_in_internal, 0.01, 0.99, 0.001)")
  Buildings_Utilities_Math_Functions_smoothLimit(DYNX(W_,145), 0.01, 0.99, 0.001));
PopModelContext();
DYNX(W_,161) = 1.5707963267948966-DYNX(W_,160);
DYNX(W_,192) = DYNX(W_,609)*DYNX(W_,578);
DYNX(W_,193) = DYNX(W_,608)*DYNX(W_,542);
DYNX(W_,536) = DYNX(W_,526)-DYNX(W_,188);
DYNX(W_,572) = DYNX(W_,531)-DYNX(W_,188);
DYNX(W_,637) = DYNX(W_,631)-DYNX(DP_,316);
DYNX(W_,638) = DYNX(W_,616)-DYNX(DP_,345);
DYNX(W_,665) = DYNX(W_,631)-DYNX(DP_,316);
DYNX(W_,723) = IF DYNX(W_,612) > 5.0000000000000004E-08 THEN DYNX(W_,614) ELSE 
  IF DYNX(W_,612) < -5.0000000000000004E-08 THEN DYNX(W_,613) ELSE 5000000.0*
  DYNX(W_,612)*(sqr(20000000.0*DYNX(W_,612))-3)*(DYNX(W_,613)-DYNX(W_,614))+0.5*
  (DYNX(W_,614)+DYNX(W_,613));
DYNX(W_,729) = DYNX(W_,616)-DYNX(DP_,345);
DYNX(W_,786) = IF DYNX(W_,615) > 5.0000000000000004E-08 THEN DYNX(W_,618) ELSE 
  IF DYNX(W_,615) < -5.0000000000000004E-08 THEN DYNX(W_,617) ELSE 5000000.0*
  DYNX(W_,615)*(sqr(20000000.0*DYNX(W_,615))-3)*(DYNX(W_,617)-DYNX(W_,618))+0.5*
  (DYNX(W_,618)+DYNX(W_,617));
DYNX(W_,831) = DYNX(DP_,297)-DYNX(X_,3);
DYNX(W_,1052) = DYNX(DP_,345)-DYNX(W_,1047);
DYNX(W_,1073) = 273.15+0.0002390057361376673*DYNX(W_,1107);
DYNX(W_,1076) = DYNX(W_,1047)-DYNX(DP_,345);
DYNX(W_,1144) = 0.0010044335697769957*DYNX(W_,615);
DYNX(W_,1196) = 1991.172*DYNX(W_,1075);
DYNX(W_,1255) = DYNX(W_,1047)-DYNX(W_,616);
DYNX(W_,1282) = 273.15+0.0002390057361376673*DYNX(W_,1251);
DYNX(W_,1371) = DYNX(W_,1364)-273.15;
DYNX(W_,1372) = 1E-05*DYNX(W_,1362);
DYNX(W_,1403) = DYNX(W_,463)*DYNX(W_,1399)+DYNX(W_,467)*DYNX(W_,1401);
DYNX(W_,1405) = DYNX(W_,463)*DYNX(W_,1400)+DYNX(W_,467)*DYNX(W_,1402);
DYNX(W_,1496) = DYNX(W_,1489)-273.15;
DYNX(W_,1497) = 1E-05*DYNX(W_,616);

DefaultSection
InitializeData(1)
EndTranslatedEquations

#include <dsblock6.c>

PreNonAliasNew(0)
StartNonAlias(0)
DeclareParameter("mDis_flow_nominal", "Nominal mass flow rate on district-side (primary) [kg/s]",\
 0, 0.5, 0.0,0.0,0.0,0,560)
DeclareParameter("mBui_flow_nominal", "Nominal mass flow rate on building-side (secondary) [kg/s]",\
 1, 0.5, 0.0,0.0,0.0,0,560)
DeclareParameter("m1_flow_nominal", "kg/s [kg/s]", 2, 0.5, 0.0,0.0,0.0,0,560)
DeclareParameter("cp", "J/kg-k", 3, 4.2, 0.0,0.0,0.0,0,560)
DeclareVariable("weaDat.computeWetBulbTemperature", "If true, then this model computes the wet bulb temperature [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,515)
DeclareVariable("weaDat.pAtmSou", "Atmospheric pressure [:#(type=Buildings.BoundaryConditions.Types.DataSource)]",\
 2, 1.0,3.0,0.0,0,517)
DeclareParameter("weaDat.pAtm", "Atmospheric pressure (used if pAtmSou=Parameter) [Pa|bar]",\
 4, 101325, 0.0,0.0,0.0,0,560)
DeclareVariable("weaDat.ceiHeiSou", "Ceiling height [:#(type=Buildings.BoundaryConditions.Types.DataSource)]",\
 1, 1.0,3.0,0.0,0,517)
DeclareParameter("weaDat.ceiHei", "Ceiling height (used if ceiHei=Parameter) [m|m]",\
 5, 20000, 0.0,0.0,0.0,0,560)
DeclareVariable("weaDat.totSkyCovSou", "Total sky cover [:#(type=Buildings.BoundaryConditions.Types.DataSource)]",\
 1, 1.0,3.0,0.0,0,517)
DeclareParameter("weaDat.totSkyCov", "Total sky cover (used if totSkyCov=Parameter). Use 0 <= totSkyCov <= 1 [1]",\
 6, 0.5, 0.0,1.0,0.0,0,560)
DeclareVariable("weaDat.opaSkyCovSou", "Opaque sky cover [:#(type=Buildings.BoundaryConditions.Types.DataSource)]",\
 1, 1.0,3.0,0.0,0,517)
DeclareParameter("weaDat.opaSkyCov", "Opaque sky cover (used if opaSkyCov=Parameter). Use 0 <= opaSkyCov <= 1 [1]",\
 7, 0.5, 0.0,1.0,0.0,0,560)
DeclareVariable("weaDat.TDryBulSou", "Dry bulb temperature [:#(type=Buildings.BoundaryConditions.Types.DataSource)]",\
 1, 1.0,3.0,0.0,0,517)
DeclareParameter("weaDat.TDryBul", "Dry bulb temperature (used if TDryBul=Parameter) [K|degC]",\
 8, 293.15, 0.0,1E+100,300.0,0,560)
DeclareVariable("weaDat.TDewPoiSou", "Dew point temperature [:#(type=Buildings.BoundaryConditions.Types.DataSource)]",\
 1, 1.0,3.0,0.0,0,517)
DeclareParameter("weaDat.TDewPoi", "Dew point temperature (used if TDewPoi=Parameter) [K|degC]",\
 9, 283.15, 0.0,1E+100,300.0,0,560)
DeclareVariable("weaDat.TBlaSkySou", "Black-body sky temperature [:#(type=Buildings.BoundaryConditions.Types.DataSource)]",\
 1, 1.0,3.0,0.0,0,517)
DeclareParameter("weaDat.TBlaSky", "Black-body sky temperature (used if TBlaSkySou=Parameter) [K|degC]",\
 10, 273.15, 0.0,1E+100,300.0,0,560)
DeclareVariable("weaDat.relHumSou", "Relative humidity [:#(type=Buildings.BoundaryConditions.Types.DataSource)]",\
 1, 1.0,3.0,0.0,0,517)
DeclareParameter("weaDat.relHum", "Relative humidity (used if relHum=Parameter) [1]",\
 11, 0.5, 0.0,1.0,0.0,0,560)
DeclareVariable("weaDat.winSpeSou", "Wind speed [:#(type=Buildings.BoundaryConditions.Types.DataSource)]",\
 1, 1.0,3.0,0.0,0,517)
DeclareParameter("weaDat.winSpe", "Wind speed (used if winSpe=Parameter) [m/s]",\
 12, 1, 0.0,1E+100,0.0,0,560)
DeclareVariable("weaDat.winDirSou", "Wind direction [:#(type=Buildings.BoundaryConditions.Types.DataSource)]",\
 1, 1.0,3.0,0.0,0,517)
DeclareParameter("weaDat.winDir", "Wind direction (used if winDir=Parameter) [rad|deg]",\
 13, 1.0, 0.0,0.0,0.0,0,560)
DeclareVariable("weaDat.HInfHorSou", "Infrared horizontal radiation [:#(type=Buildings.BoundaryConditions.Types.DataSource)]",\
 1, 1.0,3.0,0.0,0,517)
DeclareParameter("weaDat.HInfHor", "Infrared horizontal radiation (used if HInfHorSou=Parameter) [W/m2]",\
 14, 0.0, 0.0,0.0,0.0,0,560)
DeclareVariable("weaDat.HSou", "Global, diffuse, and direct normal radiation [:#(type=Buildings.BoundaryConditions.Types.RadiationDataSource)]",\
 1, 1.0,4.0,0.0,0,517)
DeclareVariable("weaDat.lon", "Longitude [rad|deg]", -2.1362830044410592, \
0.0,0.0,0.0,0,513)
DeclareVariable("weaDat.lat", "Latitude [rad|deg]", 0.6565928646002667, 0.0,0.0,\
0.0,0,513)
DeclareVariable("weaDat.timZon", "Time zone [s|h]", -28800.0, 0.0,0.0,0.0,0,513)
DeclareVariable("weaDat.calTSky", "Computation of black-body sky temperature [:#(type=Buildings.BoundaryConditions.Types.SkyTemperatureCalculation)]",\
 1, 1.0,2.0,0.0,0,517)
DeclareVariable("weaDat.epsCos", "Small value to avoid division by 0", 1E-06, \
0.0,0.0,0.0,0,513)
DeclareVariable("weaDat.solCon", "Solar constant [W/m2]", 1367.7, 0.0,0.0,0.0,0,513)
DeclareVariable("weaDat.timeSpan[1]", "Start time, end time of weather data [s]",\
 0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("weaDat.timeSpan[2]", "Start time, end time of weather data [s]",\
 0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("weaDat.datRea.nout", "Number of outputs [:#(type=Integer)]", 26,\
 0.0,0.0,0.0,0,2565)
DeclareVariable("weaDat.datRea.u", "Connector of Real input signal", 0.0, \
0.0,0.0,0.0,0,2560)
DeclareVariable("weaDat.datRea.y[1]", "Connector of Real output signals", 0.0, \
0.0,0.0,0.0,0,2560)
DeclareVariable("weaDat.datRea.y[2]", "Connector of Real output signals", 0.0, \
0.0,0.0,0.0,0,2560)
DeclareVariable("weaDat.datRea.y[3]", "Connector of Real output signals", 0.0, \
0.0,0.0,0.0,0,2560)
DeclareVariable("weaDat.datRea.y[4]", "Connector of Real output signals", 0.0, \
0.0,0.0,0.0,0,2560)
DeclareVariable("weaDat.datRea.y[5]", "Connector of Real output signals", 0.0, \
0.0,0.0,0.0,0,2560)
DeclareVariable("weaDat.datRea.y[6]", "Connector of Real output signals", 0.0, \
0.0,0.0,0.0,0,2560)
DeclareVariable("weaDat.datRea.y[7]", "Connector of Real output signals", 0.0, \
0.0,0.0,0.0,0,2560)
DeclareVariable("weaDat.datRea.y[8]", "Connector of Real output signals", 0.0, \
0.0,0.0,0.0,0,2560)
DeclareVariable("weaDat.datRea.y[9]", "Connector of Real output signals", 0.0, \
0.0,0.0,0.0,0,2560)
DeclareVariable("weaDat.datRea.y[10]", "Connector of Real output signals", 0.0, \
0.0,0.0,0.0,0,2560)
DeclareVariable("weaDat.datRea.y[11]", "Connector of Real output signals", 0.0, \
0.0,0.0,0.0,0,2560)
DeclareAlias2("weaDat.datRea.y[12]", "Connector of Real output signals", \
"weaDat.winSpe_in_internal", 1, 5, 146, 1024)
DeclareVariable("weaDat.datRea.y[13]", "Connector of Real output signals", 0.0, \
0.0,0.0,0.0,0,2560)
DeclareVariable("weaDat.datRea.y[14]", "Connector of Real output signals", 0.0, \
0.0,0.0,0.0,0,2560)
DeclareVariable("weaDat.datRea.y[15]", "Connector of Real output signals", 0.0, \
0.0,0.0,0.0,0,2560)
DeclareAlias2("weaDat.datRea.y[16]", "Connector of Real output signals", \
"weaDat.ceiHei_in_internal", 1, 5, 139, 1024)
DeclareVariable("weaDat.datRea.y[17]", "Connector of Real output signals", 0.0, \
0.0,0.0,0.0,0,2560)
DeclareVariable("weaDat.datRea.y[18]", "Connector of Real output signals", 0.0, \
0.0,0.0,0.0,0,2560)
DeclareVariable("weaDat.datRea.y[19]", "Connector of Real output signals", 0.0, \
0.0,0.0,0.0,0,2560)
DeclareVariable("weaDat.datRea.y[20]", "Connector of Real output signals", 0.0, \
0.0,0.0,0.0,0,2560)
DeclareVariable("weaDat.datRea.y[21]", "Connector of Real output signals", 0.0, \
0.0,0.0,0.0,0,2560)
DeclareVariable("weaDat.datRea.y[22]", "Connector of Real output signals", 0.0, \
0.0,0.0,0.0,0,2560)
DeclareVariable("weaDat.datRea.y[23]", "Connector of Real output signals", 0.0, \
0.0,0.0,0.0,0,2560)
DeclareVariable("weaDat.datRea.y[24]", "Connector of Real output signals", 0.0, \
0.0,0.0,0.0,0,2560)
DeclareVariable("weaDat.datRea.y[25]", "Connector of Real output signals", 0.0, \
0.0,0.0,0.0,0,2560)
DeclareAlias2("weaDat.datRea.y[26]", "Connector of Real output signals", \
"weaDat.HInfHor_in_internal", 1, 5, 151, 1024)
DeclareVariable("weaDat.datRea.tableOnFile", "= true, if table is defined on file or in function usertab [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,2563)
DeclareParameter("weaDat.datRea.verboseRead", "= true, if info message that file is loading is to be printed [:#(type=Boolean)]",\
 15, true, 0.0,0.0,0.0,0,2610)
DeclareVariable("weaDat.datRea.columns[1]", "Columns of table to be interpolated [:#(type=Integer)]",\
 2, 0.0,0.0,0.0,0,2565)
DeclareVariable("weaDat.datRea.columns[2]", "Columns of table to be interpolated [:#(type=Integer)]",\
 3, 0.0,0.0,0.0,0,2565)
DeclareVariable("weaDat.datRea.columns[3]", "Columns of table to be interpolated [:#(type=Integer)]",\
 4, 0.0,0.0,0.0,0,2565)
DeclareVariable("weaDat.datRea.columns[4]", "Columns of table to be interpolated [:#(type=Integer)]",\
 5, 0.0,0.0,0.0,0,2565)
DeclareVariable("weaDat.datRea.columns[5]", "Columns of table to be interpolated [:#(type=Integer)]",\
 6, 0.0,0.0,0.0,0,2565)
DeclareVariable("weaDat.datRea.columns[6]", "Columns of table to be interpolated [:#(type=Integer)]",\
 11, 0.0,0.0,0.0,0,2565)
DeclareVariable("weaDat.datRea.columns[7]", "Columns of table to be interpolated [:#(type=Integer)]",\
 12, 0.0,0.0,0.0,0,2565)
DeclareVariable("weaDat.datRea.columns[8]", "Columns of table to be interpolated [:#(type=Integer)]",\
 13, 0.0,0.0,0.0,0,2565)
DeclareVariable("weaDat.datRea.columns[9]", "Columns of table to be interpolated [:#(type=Integer)]",\
 14, 0.0,0.0,0.0,0,2565)
DeclareVariable("weaDat.datRea.columns[10]", "Columns of table to be interpolated [:#(type=Integer)]",\
 15, 0.0,0.0,0.0,0,2565)
DeclareVariable("weaDat.datRea.columns[11]", "Columns of table to be interpolated [:#(type=Integer)]",\
 16, 0.0,0.0,0.0,0,2565)
DeclareVariable("weaDat.datRea.columns[12]", "Columns of table to be interpolated [:#(type=Integer)]",\
 17, 0.0,0.0,0.0,0,2565)
DeclareVariable("weaDat.datRea.columns[13]", "Columns of table to be interpolated [:#(type=Integer)]",\
 18, 0.0,0.0,0.0,0,2565)
DeclareVariable("weaDat.datRea.columns[14]", "Columns of table to be interpolated [:#(type=Integer)]",\
 19, 0.0,0.0,0.0,0,2565)
DeclareVariable("weaDat.datRea.columns[15]", "Columns of table to be interpolated [:#(type=Integer)]",\
 20, 0.0,0.0,0.0,0,2565)
DeclareVariable("weaDat.datRea.columns[16]", "Columns of table to be interpolated [:#(type=Integer)]",\
 21, 0.0,0.0,0.0,0,2565)
DeclareVariable("weaDat.datRea.columns[17]", "Columns of table to be interpolated [:#(type=Integer)]",\
 22, 0.0,0.0,0.0,0,2565)
DeclareVariable("weaDat.datRea.columns[18]", "Columns of table to be interpolated [:#(type=Integer)]",\
 23, 0.0,0.0,0.0,0,2565)
DeclareVariable("weaDat.datRea.columns[19]", "Columns of table to be interpolated [:#(type=Integer)]",\
 24, 0.0,0.0,0.0,0,2565)
DeclareVariable("weaDat.datRea.columns[20]", "Columns of table to be interpolated [:#(type=Integer)]",\
 25, 0.0,0.0,0.0,0,2565)
DeclareVariable("weaDat.datRea.columns[21]", "Columns of table to be interpolated [:#(type=Integer)]",\
 26, 0.0,0.0,0.0,0,2565)
DeclareVariable("weaDat.datRea.columns[22]", "Columns of table to be interpolated [:#(type=Integer)]",\
 27, 0.0,0.0,0.0,0,2565)
DeclareVariable("weaDat.datRea.columns[23]", "Columns of table to be interpolated [:#(type=Integer)]",\
 28, 0.0,0.0,0.0,0,2565)
DeclareVariable("weaDat.datRea.columns[24]", "Columns of table to be interpolated [:#(type=Integer)]",\
 29, 0.0,0.0,0.0,0,2565)
DeclareVariable("weaDat.datRea.columns[25]", "Columns of table to be interpolated [:#(type=Integer)]",\
 30, 0.0,0.0,0.0,0,2565)
DeclareVariable("weaDat.datRea.columns[26]", "Columns of table to be interpolated [:#(type=Integer)]",\
 8, 0.0,0.0,0.0,0,2565)
DeclareVariable("weaDat.datRea.smoothness", "Smoothness of table interpolation [:#(type=Modelica.Blocks.Types.Smoothness)]",\
 2, 1.0,5.0,0.0,0,2565)
DeclareVariable("weaDat.datRea.tableID.id", "[:#(type=Integer)]", 0, 0.0,0.0,0.0,\
0,2565)
DeclareVariable("weaDat.datRea.tableOnFileRead", "= 1, if table was successfully read from file",\
 0.0, 0.0,0.0,0.0,0,2561)
DeclareAlias2("weaDat.cheTemDryBul.TIn", "Input Temperature [K|degC]", \
"weaDat.TDryBul_in_internal", 1, 5, 142, 1024)
DeclareAlias2("weaDat.cheTemDryBul.TOut", "Output temperature [K|degC]", \
"weaDat.TDryBul_in_internal", 1, 5, 142, 1024)
DeclareParameter("weaDat.cheTemDryBul.TMin", "Minimum allowed temperature [K|degC]",\
 16, 203.15, 0.0,1E+100,300.0,0,2608)
DeclareParameter("weaDat.cheTemDryBul.TMax", "Maximum allowed temperature [K|degC]",\
 17, 343.15, 0.0,1E+100,300.0,0,2608)
DeclareAlias2("weaDat.cheTemDewPoi.TIn", "Input Temperature [K|degC]", \
"weaDat.TDewPoi_in_internal", 1, 5, 143, 1024)
DeclareAlias2("weaDat.cheTemDewPoi.TOut", "Output temperature [K|degC]", \
"weaDat.TDewPoi_in_internal", 1, 5, 143, 1024)
DeclareParameter("weaDat.cheTemDewPoi.TMin", "Minimum allowed temperature [K|degC]",\
 18, 203.15, 0.0,1E+100,300.0,0,2608)
DeclareParameter("weaDat.cheTemDewPoi.TMax", "Maximum allowed temperature [K|degC]",\
 19, 343.15, 0.0,1E+100,300.0,0,2608)
DeclareAlias2("weaDat.conRelHum.relHumIn", "Value of relative humidity in percentage [1]",\
 "weaDat.datRea.y[3]", 1, 5, 25, 1024)
DeclareAlias2("weaDat.conRelHum.relHumOut", "Relative humidity between 0 and 1 [1]",\
 "weaDat.relHum_in_internal", 1, 5, 145, 1024)
DeclareAlias2("weaDat.chePre.PIn", "Input pressure [Pa]", "weaDat.pAtm", 1, 7, 4,\
 1024)
DeclareAlias2("weaDat.chePre.POut", "Atmospheric pressure [Pa]", "weaDat.pAtm", 1,\
 7, 4, 1024)
DeclareVariable("weaDat.chePre.PMin", "Minimum allowed pressure [Pa|bar]", 3100,\
 0.0,0.0,0.0,0,2561)
DeclareVariable("weaDat.chePre.PMax", "Maximum allowed pressure [Pa|bar]", 120000,\
 0.0,0.0,0.0,0,2561)
DeclareAlias2("weaDat.cheTotSkyCov.nIn", "Input sky cover [0, 10] []", \
"weaDat.totSkyCov_in_internal", 1, 5, 140, 1024)
DeclareVariable("weaDat.cheTotSkyCov.nOut", "Sky cover [0, 1] [1]", 0.0, 0.0,1.0,\
0.0,0,2560)
DeclareVariable("weaDat.cheTotSkyCov.delta", "Smoothing parameter", 0.01, \
0.0,0.0,0.0,0,2561)
DeclareVariable("weaDat.cheTotSkyCov.nMin", "Lower bound", 0.01, 0.0,0.0,0.0,0,2561)
DeclareVariable("weaDat.cheTotSkyCov.nMax", "Upper bound", 9.99, 0.0,0.0,0.0,0,2561)
DeclareAlias2("weaDat.cheOpaSkyCov.nIn", "Input sky cover [0, 10] []", \
"weaDat.opaSkyCov_in_internal", 1, 5, 141, 1024)
DeclareVariable("weaDat.cheOpaSkyCov.nOut", "Sky cover [0, 1] [1]", 0.0, 0.0,1.0,\
0.0,0,2560)
DeclareVariable("weaDat.cheOpaSkyCov.delta", "Smoothing parameter", 0.01, \
0.0,0.0,0.0,0,2561)
DeclareVariable("weaDat.cheOpaSkyCov.nMin", "Lower bound", 0.01, 0.0,0.0,0.0,0,2561)
DeclareVariable("weaDat.cheOpaSkyCov.nMax", "Upper bound", 9.99, 0.0,0.0,0.0,0,2561)
DeclareAlias2("weaDat.cheGloHorRad.HIn", "Input radiation [W/m2]", \
"weaDat.HGloHor_in_internal", 1, 5, 148, 1024)
DeclareVariable("weaDat.cheGloHorRad.HOut", "Radiation [W/m2]", 0.0, 0.0,0.0,0.0,\
0,2560)
DeclareVariable("weaDat.cheGloHorRad.HMin", "Minimum value for radiation [W/m2]",\
 0.0001, 0.0,0.0,0.0,0,2561)
DeclareAlias2("weaDat.cheDifHorRad.HIn", "Input radiation [W/m2]", \
"weaDat.HDifHor_in_internal", 1, 5, 149, 1024)
DeclareVariable("weaDat.cheDifHorRad.HOut", "Radiation [W/m2]", 0.0, 0.0,0.0,0.0,\
0,2560)
DeclareVariable("weaDat.cheDifHorRad.HMin", "Minimum value for radiation [W/m2]",\
 0.0001, 0.0,0.0,0.0,0,2561)
DeclareAlias2("weaDat.cheDirNorRad.HIn", "Input radiation [W/m2]", \
"weaDat.HDirNor_in_internal", 1, 5, 150, 1024)
DeclareVariable("weaDat.cheDirNorRad.HOut", "Radiation [W/m2]", 0.0, 0.0,0.0,0.0,\
0,2560)
DeclareVariable("weaDat.cheDirNorRad.HMin", "Minimum value for radiation [W/m2]",\
 0.0001, 0.0,0.0,0.0,0,2561)
DeclareAlias2("weaDat.cheCeiHei.ceiHeiIn", "Input ceiling height [m]", \
"weaDat.ceiHei_in_internal", 1, 5, 139, 1024)
DeclareVariable("weaDat.cheCeiHei.ceiHeiOut", "Ceiling height [m]", 0.0, \
0.0,0.0,0.0,0,2560)
DeclareVariable("weaDat.cheCeiHei.ceiHeiMin", "Minimum allowed ceiling height [m]",\
 0, 0.0,1E+100,0.0,0,2561)
DeclareAlias2("weaDat.cheWinSpe.winSpeIn", "Input wind speed [m/s]", \
"weaDat.winSpe_in_internal", 1, 5, 146, 1024)
DeclareVariable("weaDat.cheWinSpe.winSpeOut", "Wind speed [m/s]", 0.0, 0.0,0.0,\
0.0,0,2560)
DeclareVariable("weaDat.cheWinSpe.winSpeMin", "Minimum allowed wind speed [m/s]",\
 1E-06, 0.0,0.0,0.0,0,2561)
DeclareAlias2("weaDat.cheHorRad.HIn", "Input horizontal infrared irradiation [W/m2]",\
 "weaDat.HInfHor_in_internal", 1, 5, 151, 1024)
DeclareVariable("weaDat.cheHorRad.HOut", "Horizontal infrared irradiation [W/m2]",\
 0.0, 0.0,1E+100,100.0,0,2560)
DeclareVariable("weaDat.cheHorRad.HMin", "Minimum value for radiation [W/m2]", \
0.0001, 0.0,0.0,0.0,0,2561)
DeclareAlias2("weaDat.cheWinDir.nIn", "Input wind direction [rad|deg]", \
"weaDat.winDir_in_internal", 1, 5, 147, 1024)
DeclareVariable("weaDat.cheWinDir.nOut", "Wind direction [rad|deg]", 0.0, \
0.0,0.0,0.0,0,2560)
DeclareVariable("weaDat.cheWinDir.delta", "Smoothing parameter", 0.01, 0.0,0.0,\
0.0,0,2561)
DeclareVariable("weaDat.cheWinDir.nMin", "Lower bound", 0, 0.0,0.0,0.0,0,2561)
DeclareVariable("weaDat.cheWinDir.nMax", "Upper bound", 6.283185307179586, \
0.0,0.0,0.0,0,2561)
DeclareVariable("weaDat.TBlaSkyCom.calTSky", "Computation of black-body sky temperature [:#(type=Buildings.BoundaryConditions.Types.SkyTemperatureCalculation)]",\
 1, 1.0,2.0,0.0,0,2565)
DeclareAlias2("weaDat.TBlaSkyCom.TDryBul", "Dry bulb temperature at ground level [K|degC]",\
 "weaDat.TDryBul_in_internal", 1, 5, 142, 1024)
DeclareAlias2("weaDat.TBlaSkyCom.TDewPoi", "Dew point temperature [K|degC]", \
"weaDat.TDewPoi_in_internal", 1, 5, 143, 1024)
DeclareAlias2("weaDat.TBlaSkyCom.nOpa", "Opaque sky cover [0, 1] [1]", \
"weaDat.cheOpaSkyCov.nOut", 1, 5, 82, 1024)
DeclareAlias2("weaDat.TBlaSkyCom.TBlaSky", "Black-body sky temperature [K|degC]",\
 "weaDat.TBlaSky_in_internal", 1, 5, 144, 1024)
DeclareAlias2("weaDat.TBlaSkyCom.HHorIR", "Horizontal infrared irradiation [W/m2]",\
 "weaDat.cheHorRad.HOut", 1, 5, 96, 1024)
DeclareVariable("weaDat.TBlaSkyCom.TDewPoiK", "Dewpoint temperature [K|degC]", \
273.15, 0.0,1E+100,300.0,0,2561)
DeclareVariable("weaDat.TBlaSkyCom.epsSky", "Black-body absorptivity of sky [1]",\
 0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("weaDat.TBlaSkyCom.nOpa10", "Opaque sky cover in [0, 10] []", \
0.0, 0.0,10.0,0.0,0,2561)
DeclareVariable("weaDat.modTim.y", "Connector of Real output signal", 0.0, \
0.0,0.0,0.0,0,2560)
DeclareVariable("weaDat.add.u1", "Connector of Real input signal 1", 1800, \
0.0,0.0,0.0,0,2561)
DeclareAlias2("weaDat.add.u2", "Connector of Real input signal 2", \
"weaDat.modTim.y", 1, 5, 106, 1024)
DeclareVariable("weaDat.add.y", "Connector of Real output signal", 0.0, 0.0,0.0,\
0.0,0,2560)
DeclareParameter("weaDat.add.k1", "Gain of upper input", 20, 1, 0.0,0.0,0.0,0,2608)
DeclareParameter("weaDat.add.k2", "Gain of lower input", 21, 1, 0.0,0.0,0.0,0,2608)
DeclareVariable("weaDat.con30mins.k", "Constant output value", 1800, 0.0,0.0,0.0,\
0,2561)
DeclareVariable("weaDat.con30mins.y", "Connector of Real output signal", 1800.0,\
 0.0,0.0,0.0,0,2561)
DeclareAlias2("weaDat.locTim.cloTim", "Clock time [s]", "weaDat.modTim.y", 1, 5,\
 106, 1024)
DeclareVariable("weaDat.locTim.timZon", "Time zone [s|h]", -28800.0, 0.0,0.0,0.0,\
0,2561)
DeclareVariable("weaDat.locTim.lon", "Longitude [rad|deg]", -2.1362830044410592,\
 0.0,0.0,0.0,0,2561)
DeclareVariable("weaDat.locTim.locTim", "Local civil time [s]", 0.0, 0.0,0.0,0.0,\
0,2560)
DeclareVariable("weaDat.locTim.diff", "Difference between local and clock time [s]",\
 -576.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("weaDat.datRea1.nout", "Number of outputs [:#(type=Integer)]", 3,\
 0.0,0.0,0.0,0,2565)
DeclareVariable("weaDat.datRea1.u", "Connector of Real input signal", 0.0, \
0.0,0.0,0.0,0,2560)
DeclareAlias2("weaDat.datRea1.y[1]", "Connector of Real output signals", \
"weaDat.HGloHor_in_internal", 1, 5, 148, 1024)
DeclareAlias2("weaDat.datRea1.y[2]", "Connector of Real output signals", \
"weaDat.HDirNor_in_internal", 1, 5, 150, 1024)
DeclareAlias2("weaDat.datRea1.y[3]", "Connector of Real output signals", \
"weaDat.HDifHor_in_internal", 1, 5, 149, 1024)
DeclareVariable("weaDat.datRea1.tableOnFile", "= true, if table is defined on file or in function usertab [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,2563)
DeclareParameter("weaDat.datRea1.verboseRead", "= true, if info message that file is loading is to be printed [:#(type=Boolean)]",\
 22, true, 0.0,0.0,0.0,0,2610)
DeclareVariable("weaDat.datRea1.columns[1]", "Columns of table to be interpolated [:#(type=Integer)]",\
 9, 0.0,0.0,0.0,0,2565)
DeclareVariable("weaDat.datRea1.columns[2]", "Columns of table to be interpolated [:#(type=Integer)]",\
 10, 0.0,0.0,0.0,0,2565)
DeclareVariable("weaDat.datRea1.columns[3]", "Columns of table to be interpolated [:#(type=Integer)]",\
 11, 0.0,0.0,0.0,0,2565)
DeclareVariable("weaDat.datRea1.smoothness", "Smoothness of table interpolation [:#(type=Modelica.Blocks.Types.Smoothness)]",\
 2, 1.0,5.0,0.0,0,2565)
DeclareVariable("weaDat.datRea1.tableID.id", "[:#(type=Integer)]", 0, 0.0,0.0,\
0.0,0,2565)
DeclareVariable("weaDat.datRea1.tableOnFileRead", "= 1, if table was successfully read from file",\
 0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("weaDat.conTim1.weaDatStaTim", "Start time of weather data [s|d]",\
 0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("weaDat.conTim1.weaDatEndTim", "End time of weather data [s|d]",\
 0.0, 0.0,0.0,0.0,0,2561)
DeclareAlias2("weaDat.conTim1.modTim", "Simulation time [s]", "weaDat.add.y", 1,\
 5, 108, 1024)
DeclareAlias2("weaDat.conTim1.calTim", "Calendar time [s]", "weaDat.datRea1.u", 1,\
 5, 116, 1024)
DeclareVariable("weaDat.conTim1.shiftSolarRad", "Number of seconds for the shift for solar radiation calculation [s]",\
 1800, 0.0,0.0,0.0,0,2561)
DeclareVariable("weaDat.conTim1.lenWea", "Length of weather data [s]", 0.0, \
0.0,0.0,0.0,0,2561)
DeclareVariable("weaDat.conTim1.canRepeatWeatherFile", "=true, if the weather file can be repeated, since it has the length of a year or a multiple of it [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,2563)
DeclareVariable("weaDat.conTim1.tNext", "Start time of next period [s]", 0, \
0.0,0.0,0.0,0,2704)
DeclareVariable("weaDat.conTim.weaDatStaTim", "Start time of weather data [s|d]",\
 0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("weaDat.conTim.weaDatEndTim", "End time of weather data [s|d]", \
0.0, 0.0,0.0,0.0,0,2561)
DeclareAlias2("weaDat.conTim.modTim", "Simulation time [s]", "weaDat.modTim.y", 1,\
 5, 106, 1024)
DeclareAlias2("weaDat.conTim.calTim", "Calendar time [s]", "weaDat.datRea.u", 1,\
 5, 22, 1024)
DeclareVariable("weaDat.conTim.shiftSolarRad", "Number of seconds for the shift for solar radiation calculation [s]",\
 1800, 0.0,0.0,0.0,0,2561)
DeclareVariable("weaDat.conTim.lenWea", "Length of weather data [s]", 0.0, \
0.0,0.0,0.0,0,2561)
DeclareVariable("weaDat.conTim.canRepeatWeatherFile", "=true, if the weather file can be repeated, since it has the length of a year or a multiple of it [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,2563)
DeclareVariable("weaDat.conTim.tNext", "Start time of next period [s]", 0, \
0.0,0.0,0.0,0,2704)
DeclareAlias2("weaDat.eqnTim.nDay", "Zero-based day number in seconds (January 1=0, January 2=86400) [s]",\
 "weaDat.modTim.y", 1, 5, 106, 1024)
DeclareVariable("weaDat.eqnTim.eqnTim", "Equation of time [s|min]", 0.0, \
0.0,0.0,0.0,0,2560)
DeclareVariable("weaDat.eqnTim.Bt", "Intermediate variable", 0.0, 0.0,0.0,0.0,0,2560)
DeclareAlias2("weaDat.solTim.locTim", "Local time [s]", "weaDat.locTim.locTim", 1,\
 5, 113, 1024)
DeclareAlias2("weaDat.solTim.equTim", "Equation of time [s]", "weaDat.eqnTim.eqnTim", 1,\
 5, 136, 1024)
DeclareVariable("weaDat.solTim.solTim", "Solar time [s|s]", 0.0, 0.0,0.0,0.0,0,2560)
DeclareAlias2("weaDat.pAtm_in_internal", "Needed to connect to conditional connector [Pa|bar]",\
 "weaDat.pAtm", 1, 7, 4, 1024)
DeclareVariable("weaDat.ceiHei_in_internal", "Needed to connect to conditional connector [m|m]",\
 0.0, 0.0,0.0,0.0,0,2560)
DeclareVariable("weaDat.totSkyCov_in_internal", "Needed to connect to conditional connector",\
 0.0, 0.0,1.0,0.0,0,2560)
DeclareVariable("weaDat.opaSkyCov_in_internal", "Needed to connect to conditional connector",\
 0.0, 0.0,1.0,0.0,0,2560)
DeclareVariable("weaDat.TDryBul_in_internal", "Needed to connect to conditional connector [K|degC]",\
 0.0, 0.0,0.0,0.0,0,2560)
DeclareVariable("weaDat.TDewPoi_in_internal", "Needed to connect to conditional connector [K|degC]",\
 0.0, 0.0,0.0,0.0,0,2560)
DeclareVariable("weaDat.TBlaSky_in_internal", "Needed to connect to conditional connector [K|degC]",\
 0.0, 0.0,0.0,0.0,0,2560)
DeclareVariable("weaDat.relHum_in_internal", "Needed to connect to conditional connector",\
 0.0, 0.0,1.0,0.0,0,2560)
DeclareVariable("weaDat.winSpe_in_internal", "Needed to connect to conditional connector [m/s]",\
 0.0, 0.0,0.0,0.0,0,2560)
DeclareVariable("weaDat.winDir_in_internal", "Needed to connect to conditional connector [rad|deg]",\
 0.0, 0.0,0.0,0.0,0,2560)
DeclareVariable("weaDat.HGloHor_in_internal", "Needed to connect to conditional connector [W/m2]",\
 0.0, 0.0,0.0,0.0,0,2560)
DeclareVariable("weaDat.HDifHor_in_internal", "Needed to connect to conditional connector [W/m2]",\
 0.0, 0.0,0.0,0.0,0,2560)
DeclareVariable("weaDat.HDirNor_in_internal", "Needed to connect to conditional connector [W/m2]",\
 0.0, 0.0,0.0,0.0,0,2560)
DeclareVariable("weaDat.HInfHor_in_internal", "Needed to connect to conditional connector [W/m2]",\
 0.0, 0.0,0.0,0.0,0,2560)
DeclareAlias2("weaDat.conWinDir.u", "Connector of Real input signal to be converted [deg]",\
 "weaDat.datRea.y[11]", 1, 5, 33, 1024)
DeclareAlias2("weaDat.conWinDir.y", "Connector of Real output signal containing input signal u in another unit [rad]",\
 "weaDat.winDir_in_internal", 1, 5, 147, 1024)
DeclareAlias2("weaDat.conTDryBul.u", "Connector of Real input signal to be converted [degC]",\
 "weaDat.datRea.y[1]", 1, 5, 23, 1024)
DeclareAlias2("weaDat.conTDryBul.y", "Connector of Real output signal containing input signal u in another unit [K]",\
 "weaDat.TDryBul_in_internal", 1, 5, 142, 1024)
DeclareAlias2("weaDat.conHorRad.HIn", "Input radiation [W.h/m2]", \
"weaDat.HInfHor_in_internal", 1, 5, 151, 1024)
DeclareAlias2("weaDat.conHorRad.HOut", "Radiation [W/m2]", "weaDat.HInfHor_in_internal", 1,\
 5, 151, 1024)
DeclareVariable("weaDat.conHorRad.Hou", "1 hour [s]", 3600, 0.0,0.0,0.0,0,2561)
DeclareAlias2("weaDat.conTDewPoi.u", "Connector of Real input signal to be converted [degC]",\
 "weaDat.datRea.y[2]", 1, 5, 24, 1024)
DeclareAlias2("weaDat.conTDewPoi.y", "Connector of Real output signal containing input signal u in another unit [K]",\
 "weaDat.TDewPoi_in_internal", 1, 5, 143, 1024)
DeclareAlias2("weaDat.conDirNorRad.HIn", "Input radiation [W.h/m2]", \
"weaDat.HDirNor_in_internal", 1, 5, 150, 1024)
DeclareAlias2("weaDat.conDirNorRad.HOut", "Radiation [W/m2]", "weaDat.HDirNor_in_internal", 1,\
 5, 150, 1024)
DeclareVariable("weaDat.conDirNorRad.Hou", "1 hour [s]", 3600, 0.0,0.0,0.0,0,2561)
DeclareAlias2("weaDat.conGloHorRad.HIn", "Input radiation [W.h/m2]", \
"weaDat.HGloHor_in_internal", 1, 5, 148, 1024)
DeclareAlias2("weaDat.conGloHorRad.HOut", "Radiation [W/m2]", "weaDat.HGloHor_in_internal", 1,\
 5, 148, 1024)
DeclareVariable("weaDat.conGloHorRad.Hou", "1 hour [s]", 3600, 0.0,0.0,0.0,0,2561)
DeclareAlias2("weaDat.conDifHorRad.HIn", "Input radiation [W.h/m2]", \
"weaDat.HDifHor_in_internal", 1, 5, 149, 1024)
DeclareAlias2("weaDat.conDifHorRad.HOut", "Radiation [W/m2]", "weaDat.HDifHor_in_internal", 1,\
 5, 149, 1024)
DeclareVariable("weaDat.conDifHorRad.Hou", "1 hour [s]", 3600, 0.0,0.0,0.0,0,2561)
DeclareAlias2("weaDat.cheRelHum.relHumIn", "Input relative humidity [1]", \
"weaDat.relHum_in_internal", 1, 5, 145, 1024)
DeclareVariable("weaDat.cheRelHum.relHumOut", "Relative humidity [1]", 0.0, \
0.0,0.0,0.0,0,2560)
DeclareVariable("weaDat.cheRelHum.delta", "Smoothing parameter", 0.01, 0.0,0.0,\
0.0,0,2561)
DeclareVariable("weaDat.cheRelHum.relHumMin", "Lower bound", 0.01, 0.0,0.0,0.0,0,2561)
DeclareVariable("weaDat.cheRelHum.relHumMax", "Upper bound", 0.99, 0.0,0.0,0.0,0,2561)
DeclareVariable("weaDat.altAng.zen", "Zenith angle [rad]", 0.0, 0.0,0.0,0.0,0,2560)
DeclareVariable("weaDat.altAng.alt", "Solar altitude angle [rad|deg]", 0.0, \
0.0,0.0,0.0,0,2560)
DeclareVariable("weaDat.zenAng.lat", "Latitude [rad|deg]", 0.6565928646002667, \
0.0,0.0,0.0,0,2561)
DeclareVariable("weaDat.zenAng.solHouAng", "Solar hour angle [rad]", 0.0, \
0.0,0.0,0.0,0,2560)
DeclareVariable("weaDat.zenAng.decAng", "Solar declination angle [rad]", 0.0, \
0.0,0.0,0.0,0,2560)
DeclareAlias2("weaDat.zenAng.zen", "Zenith angle [rad|deg]", "weaDat.altAng.zen", 1,\
 5, 160, 1024)
DeclareAlias2("weaDat.decAng.nDay", "Day number with units of seconds [s]", \
"weaDat.modTim.y", 1, 5, 106, 1024)
DeclareAlias2("weaDat.decAng.decAng", "Solar declination angle [rad|deg]", \
"weaDat.zenAng.decAng", 1, 5, 164, 1024)
DeclareVariable("weaDat.decAng.k1", "Constant", 0.3979486313076103, 0.0,0.0,0.0,\
0,2561)
DeclareVariable("weaDat.decAng.k2", "Constant", 0.017202423838958484, 0.0,0.0,\
0.0,0,2561)
DeclareAlias2("weaDat.solHouAng.solTim", "Solar time [s]", "weaDat.solTim.solTim", 1,\
 5, 138, 1024)
DeclareAlias2("weaDat.solHouAng.solHouAng", "Solar hour angle [rad|deg]", \
"weaDat.zenAng.solHouAng", 1, 5, 163, 1024)
DeclareVariable("weaDat.latitude.latitude", "Latitude [rad|deg]", \
0.6565928646002667, 0.0,0.0,0.0,0,2561)
DeclareVariable("weaDat.latitude.y", "Latitude of the location [rad|deg]", \
0.6565928646002667, 0.0,0.0,0.0,0,2561)
DeclareVariable("weaDat.longitude.longitude", "Longitude [rad|deg]", \
-2.1362830044410592, 0.0,0.0,0.0,0,2561)
DeclareVariable("weaDat.longitude.y", "Longitude of the location [rad|deg]", \
-2.1362830044410592, 0.0,0.0,0.0,0,2561)
DeclareVariable("weaDat.conTotSkyCov.k", "Gain value multiplied with input signal [1]",\
 0.1, 0.0,0.0,0.0,0,2561)
DeclareAlias2("weaDat.conTotSkyCov.u", "Input signal connector", \
"weaDat.datRea.y[13]", 1, 5, 34, 1024)
DeclareAlias2("weaDat.conTotSkyCov.y", "Output signal connector", \
"weaDat.totSkyCov_in_internal", 1, 5, 140, 1024)
DeclareVariable("weaDat.conOpaSkyCov.k", "Gain value multiplied with input signal [1]",\
 0.1, 0.0,0.0,0.0,0,2561)
DeclareAlias2("weaDat.conOpaSkyCov.u", "Input signal connector", \
"weaDat.datRea.y[14]", 1, 5, 35, 1024)
DeclareAlias2("weaDat.conOpaSkyCov.y", "Output signal connector", \
"weaDat.opaSkyCov_in_internal", 1, 5, 141, 1024)
DeclareAlias2("weaDat.cheTemBlaSky.TIn", "Black-body sky temperature [K|degC]", \
"weaDat.TBlaSky_in_internal", 1, 5, 144, 1024)
DeclareAlias2("weaDat.cheTemBlaSky.TOut", "Black-body sky temperature [K|degC]",\
 "weaDat.TBlaSky_in_internal", 1, 5, 144, 1024)
DeclareParameter("weaDat.cheTemBlaSky.TMin", "Minimum allowed temperature [K|degC]",\
 23, 0, 0.0,1E+100,300.0,0,2608)
DeclareParameter("weaDat.cheTemBlaSky.TMax", "Maximum allowed temperature [K|degC]",\
 24, 343.15, 0.0,1E+100,300.0,0,2608)
DeclareParameter("building.Q_flowHea_nominal[1]", "Heating power at nominal conditions (always positive) [W]",\
 25, 2000, 0.0,0.0,0.0,0,560)
DeclareParameter("building.Q_flowHea_nominal[2]", "Heating power at nominal conditions (always positive) [W]",\
 26, 1000, 0.0,0.0,0.0,0,560)
DeclareParameter("building.Q_flowCoo_nominal[1]", "Cooling power at nominal conditions (always positive) [W]",\
 27, 1000, 0.0,0.0,0.0,0,560)
DeclareVariable("building.THeaLoa_nominal[1]", "Temperature of heating load at nominal conditions [K;degC]",\
 293.15, 0.0,1E+100,300.0,0,513)
DeclareVariable("building.THeaLoa_nominal[2]", "Temperature of heating load at nominal conditions [K;degC]",\
 293.15, 0.0,1E+100,300.0,0,513)
DeclareVariable("building.TCooLoa_nominal[1]", "Temperature of cooling load at nominal conditions [K;degC]",\
 297.15, 0.0,1E+100,300.0,0,513)
DeclareVariable("building.m_flowHeaLoa_nominal[1]", "Mass flow rate on heating load side at nominal conditions [kg/s]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("building.m_flowHeaLoa_nominal[2]", "Mass flow rate on heating load side at nominal conditions [kg/s]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("building.m_flowCooLoa_nominal[1]", "Mass flow rate on cooling load side at nominal conditions [kg/s]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("building.nHeaLoa", "Number of heating loads [:#(type=Integer)]",\
 2, 0.0,0.0,0.0,0,517)
DeclareVariable("building.nCooLoa", "Number of cooling loads [:#(type=Integer)]",\
 1, 0.0,0.0,0.0,0,517)
DeclareVariable("building.heaLoaTyp[1]", "Type of heating load model [:#(type=Buildings.Applications.DHC.Loads.Types.ModelType)]",\
 1, 1.0,3.0,0.0,0,517)
DeclareVariable("building.heaLoaTyp[2]", "Type of heating load model [:#(type=Buildings.Applications.DHC.Loads.Types.ModelType)]",\
 2, 1.0,3.0,0.0,0,517)
DeclareVariable("building.cooLoaTyp[1]", "Type of cooling load model [:#(type=Buildings.Applications.DHC.Loads.Types.ModelType)]",\
 1, 1.0,3.0,0.0,0,517)
DeclareVariable("building.floRegHeaLoa[1]", "Heat exchanger flow configuration [:#(type=Buildings.Fluid.Types.HeatExchangerFlowRegime)]",\
 6, 1.0,6.0,0.0,0,517)
DeclareVariable("building.floRegHeaLoa[2]", "Heat exchanger flow configuration [:#(type=Buildings.Fluid.Types.HeatExchangerFlowRegime)]",\
 6, 1.0,6.0,0.0,0,517)
DeclareVariable("building.floRegCooLoa[1]", "Heat exchanger flow regime [:#(type=Buildings.Fluid.Types.HeatExchangerFlowRegime)]",\
 6, 1.0,6.0,0.0,0,517)
DeclareVariable("building.hasFraLat[1]", "false if the cooling load is purely sensible [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,515)
DeclareVariable("building.heaPorCoo[1].T", "Port temperature [K|degC]", 300.0, \
273.15,373.15,300.0,0,520)
DeclareVariable("building.heaPorCoo[1].Q_flow", "Heat flow rate (positive if flowing from outside into the component) [W]",\
 0.0, 0.0,0.0,0.0,0,776)
DeclareAlias2("building.heaPorHea[1].T", "Port temperature [K|degC]", \
"building.heaPorCoo[1].T", 1, 5, 188, 4)
DeclareVariable("building.heaPorHea[1].Q_flow", "Heat flow rate (positive if flowing from outside into the component) [W]",\
 0.0, 0.0,0.0,0.0,0,777)
DeclareAlias2("building.heaPorHea[2].T", "Port temperature [K|degC]", \
"building.heaLoaO[1].TInd", 1, 1, 12, 4)
DeclareVariable("building.heaPorHea[2].Q_flow", "Heat flow rate (positive if flowing from outside into the component) [W]",\
 0.0, 0.0,0.0,0.0,0,777)
DeclareVariable("building.Q_flowCooReq[1]", "Cooling heat flow rate required to meet setpoint [W]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("building.Q_flowHeaReq[1]", "Heating heat flow rate required to meet setpoint [W]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("building.Q_flowHeaReq[2]", "Heating heat flow rate required to meet setpoint [W]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("building.Q_flowHeaAct[1]", "Actual heating heat flow rate [W]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("building.Q_flowHeaAct[2]", "Actual heating heat flow rate [W]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareAlias2("building.Q_flowCooAct[1]", "Actual cooling heat flow rate [W]", \
"building.heaPorCoo[1].Q_flow", 1, 5, 189, 0)
DeclareAlias2("building.m_flowHeaLoa[1]", "Medium mass flow rate on the load side",\
 "building.defaults.k", 1, 7, 28, 0)
DeclareAlias2("building.m_flowHeaLoa[2]", "Medium mass flow rate on the load side",\
 "building.defaults.k", 1, 7, 28, 0)
DeclareAlias2("building.m_flowCooLoa[1]", "Medium mass flow rate on the load side",\
 "building.defaults.k", 1, 7, 28, 0)
DeclareAlias2("building.fraLatCooReq[1]", "Fraction of latent to total cooling heat flow rate [1]",\
 "building.defaults.k", 1, 7, 28, 0)
DeclareParameter("building.defaults.k", "Constant output value", 28, 0, 0.0,0.0,\
0.0,0,560)
DeclareAlias2("building.defaults.y", "Connector of Real output signal", \
"building.defaults.k", 1, 7, 28, 0)
DeclareVariable("building.nHeaLoaH", "Number of heating loads represented by a thermal model with heat port [:#(type=Integer)]",\
 1, 0.0,0.0,0.0,0,2565)
DeclareVariable("building.heaLoaH_idx[1]", "Indices of the input heat ports to be connected with models with heat port [:#(type=Integer)]",\
 1, 0.0,0.0,0.0,0,2565)
DeclareVariable("building.nHeaLoaT", "Number of heating loads represented by a prescribed temperature [:#(type=Integer)]",\
 0, 0.0,0.0,0.0,0,2565)
DeclareVariable("building.nHeaLoaO", "Number of heating loads represented by an ODE model [:#(type=Integer)]",\
 1, 0.0,0.0,0.0,0,2565)
DeclareVariable("building.heaLoaO_idx[1]", "Indices of the input heat ports to be connected with models with ODE [:#(type=Integer)]",\
 2, 0.0,0.0,0.0,0,2565)
DeclareVariable("building.nCooLoaH", "Number of cooling loads represented by a thermal model with heat port [:#(type=Integer)]",\
 1, 0.0,0.0,0.0,0,2565)
DeclareVariable("building.cooLoaH_idx[1]", "Indices of the input heat ports to be connected with thermal models with heat port [:#(type=Integer)]",\
 1, 0.0,0.0,0.0,0,2565)
DeclareVariable("building.nCooLoaT", "Number of cooling loads represented by a prescribed temperature [:#(type=Integer)]",\
 0, 0.0,0.0,0.0,0,2565)
DeclareVariable("building.nCooLoaO", "Number of cooling loads represented by an ODE model [:#(type=Integer)]",\
 0, 0.0,0.0,0.0,0,2565)
DeclareParameter("building.HDifTil[1].til", "Surface tilt [rad|deg]", 29, \
1.5707963267949, 0.0,0.0,0.0,0,560)
DeclareVariable("building.HDifTil[1].H", "Radiation per unit area [W/m2]", 0.0, \
0.0,0.0,0.0,0,512)
DeclareParameter("building.HDifTil[1].rho", "Ground reflectance [1]", 30, 0.2, \
0.0,1.0,0.0,0,560)
DeclareParameter("building.HDifTil[1].lat", "Latitude [rad|deg]", 31, \
0.87266462599716, 0.0,0.0,0.0,0,560)
DeclareParameter("building.HDifTil[1].azi", "Surface azimuth [rad|deg]", 32, \
3.1415926535898, 0.0,0.0,0.0,0,560)
DeclareVariable("building.HDifTil[1].outSkyCon", "Output contribution of diffuse irradiation from sky [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,515)
DeclareVariable("building.HDifTil[1].outGroCon", "Output contribution of diffuse irradiation from ground [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,515)
DeclareAlias2("building.HDifTil[1].add.u1", "Connector of Real input signal 1", \
"building.corGDouPan.HSkyDifTil[1]", 1, 5, 355, 0)
DeclareAlias2("building.HDifTil[1].add.u2", "Connector of Real input signal 2", \
"building.corGDouPan.HGroDifTil[1]", 1, 5, 359, 0)
DeclareAlias2("building.HDifTil[1].add.y", "Connector of Real output signal", \
"building.HDifTil[1].H", 1, 5, 206, 0)
DeclareParameter("building.HDifTil[1].add.k1", "Gain of upper input", 33, 1, \
0.0,0.0,0.0,0,560)
DeclareParameter("building.HDifTil[1].add.k2", "Gain of lower input", 34, 1, \
0.0,0.0,0.0,0,560)
DeclareAlias2("building.HDifTil[1].HSkyDifTil", "Hemispherical diffuse solar irradiation on a tilted surface from the sky",\
 "building.corGDouPan.HSkyDifTil[1]", 1, 5, 355, 0)
DeclareAlias2("building.HDifTil[1].HGroDifTil", "Hemispherical diffuse solar irradiation on a tilted surface from the ground",\
 "building.corGDouPan.HGroDifTil[1]", 1, 5, 359, 0)
DeclareVariable("building.HDifTil[1].HDifTil.rho", "Ground reflectance", 0.0, \
0.0,0.0,0.0,0,2561)
DeclareVariable("building.HDifTil[1].HDifTil.til", "Surface tilt angle [rad|deg]",\
 0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("building.HDifTil[1].HDifTil.briCof1", "Brightening Coeffcient F1",\
 0.0, 0.0,0.0,0.0,0,2560)
DeclareVariable("building.HDifTil[1].HDifTil.briCof2", "Brightening Coeffcient F2",\
 0.0, 0.0,0.0,0.0,0,2560)
DeclareAlias2("building.HDifTil[1].HDifTil.HDifHor", "Diffuse horizontal solar radiation [W/m2]",\
 "weaDat.cheDifHorRad.HOut", 1, 5, 88, 1024)
DeclareAlias2("building.HDifTil[1].HDifTil.HGloHor", "Global horizontal radiation [W/m2]",\
 "weaDat.cheGloHorRad.HOut", 1, 5, 86, 1024)
DeclareAlias2("building.HDifTil[1].HDifTil.zen", "Zenith angle of the sun beam [rad|deg]",\
 "weaDat.altAng.zen", 1, 5, 160, 1024)
DeclareVariable("building.HDifTil[1].HDifTil.incAng", "Solar incidence angle on the surface [rad|deg]",\
 0.0, 0.0,0.0,0.0,0,2560)
DeclareAlias2("building.HDifTil[1].HDifTil.HGroDifTil", "Hemispherical diffuse solar irradiation on a tilted surface from the ground [W/m2]",\
 "building.corGDouPan.HGroDifTil[1]", 1, 5, 359, 1024)
DeclareAlias2("building.HDifTil[1].HDifTil.HSkyDifTil", "Hemispherical diffuse solar irradiation on a tilted surface from the sky [W/m2]",\
 "building.corGDouPan.HSkyDifTil[1]", 1, 5, 355, 1024)
DeclareVariable("building.HDifTil[1].HDifTil.a", "", 0.0, 0.0,0.0,0.0,0,2560)
DeclareVariable("building.HDifTil[1].HDifTil.b", "", 0.0, 0.0,0.0,0.0,0,2560)
DeclareVariable("building.HDifTil[1].HDifTil.bMin", "Lower bound for b", \
0.08715574274765814, 0.0,0.0,0.0,0,2561)
DeclareAlias2("building.HDifTil[1].skyCle.zen", "Zenith angle of the sun beam [rad|degreeC]",\
 "weaDat.altAng.zen", 1, 5, 160, 1024)
DeclareAlias2("building.HDifTil[1].skyCle.HDifHor", "Horizontal diffuse solar radiation [W/m2]",\
 "weaDat.cheDifHorRad.HOut", 1, 5, 88, 1024)
DeclareAlias2("building.HDifTil[1].skyCle.HGloHor", "Horizontal global solar radiation [W/m2]",\
 "weaDat.cheGloHorRad.HOut", 1, 5, 86, 1024)
DeclareVariable("building.HDifTil[1].skyCle.skyCle", "Sky clearness. skyCle=1: overast sky; skyCle=8: clear sky",\
 0.0, 0.0,0.0,0.0,0,2560)
DeclareVariable("building.HDifTil[1].skyCle.hSmall", "Small radiation for regularization [W/m2]",\
 5E-05, 0.0,0.0,0.0,0,2561)
DeclareVariable("building.HDifTil[1].skyCle.deltaX", "Small radiation for regularization [W/m2]",\
 2.5E-05, 0.0,0.0,0.0,0,2561)
DeclareVariable("building.HDifTil[1].skyCle.k", "Constant factor", \
1.040895310738997, 0.0,0.0,0.0,0,2561)
DeclareVariable("building.HDifTil[1].skyCle.tmp1", "Intermediate variable", 0.0,\
 0.0,0.0,0.0,0,2560)
DeclareVariable("building.HDifTil[1].skyCle.HDifHorBou", "Diffuse horizontal irradiation, bounded away from zero [W/m2]",\
 0.0, 0.0,0.0,0.0,0,2560)
DeclareAlias2("building.HDifTil[1].briCoe.zen", "Zenith angle of the sun beam [rad|deg]",\
 "weaDat.altAng.zen", 1, 5, 160, 1024)
DeclareAlias2("building.HDifTil[1].briCoe.skyCle", "Sky clearness. skyCle=1: overcast sky; skyCle=8 clear sky",\
 "building.HDifTil[1].skyCle.skyCle", 1, 5, 217, 1024)
DeclareVariable("building.HDifTil[1].briCoe.skyBri", "Sky brightness [0,1] []", \
0.0, 0.0,0.0,0.0,0,2560)
DeclareAlias2("building.HDifTil[1].briCoe.F1", "Circumsolar brightening coefficient",\
 "building.HDifTil[1].HDifTil.briCof1", 1, 5, 211, 1024)
DeclareAlias2("building.HDifTil[1].briCoe.F2", "Horizon brightening coefficient",\
 "building.HDifTil[1].HDifTil.briCof2", 1, 5, 212, 1024)
DeclareVariable("building.HDifTil[1].briCoe.F11", "", 0.0, 0.0,0.0,0.0,0,2560)
DeclareVariable("building.HDifTil[1].briCoe.F12", "", 0.0, 0.0,0.0,0.0,0,2560)
DeclareVariable("building.HDifTil[1].briCoe.F13", "", 0.0, 0.0,0.0,0.0,0,2560)
DeclareVariable("building.HDifTil[1].briCoe.F21", "", 0.0, 0.0,0.0,0.0,0,2560)
DeclareVariable("building.HDifTil[1].briCoe.F22", "", 0.0, 0.0,0.0,0.0,0,2560)
DeclareVariable("building.HDifTil[1].briCoe.F23", "", 0.0, 0.0,0.0,0.0,0,2560)
DeclareVariable("building.HDifTil[1].briCoe.d", "", 0.01, 0.0,0.0,0.0,0,2561)
DeclareVariable("building.HDifTil[1].briCoe.a1", "", 0.0, 0.0,0.0,0.0,0,2560)
DeclareVariable("building.HDifTil[1].briCoe.a2", "", 0.0, 0.0,0.0,0.0,0,2560)
DeclareVariable("building.HDifTil[1].briCoe.a3", "", 0.0, 0.0,0.0,0.0,0,2560)
DeclareVariable("building.HDifTil[1].briCoe.a4", "", 0.0, 0.0,0.0,0.0,0,2560)
DeclareVariable("building.HDifTil[1].briCoe.a5", "", 0.0, 0.0,0.0,0.0,0,2560)
DeclareVariable("building.HDifTil[1].briCoe.a6", "", 0.0, 0.0,0.0,0.0,0,2560)
DeclareVariable("building.HDifTil[1].briCoe.a7", "", 0.0, 0.0,0.0,0.0,0,2560)
DeclareVariable("building.HDifTil[1].briCoe.a8", "", 0.0, 0.0,0.0,0.0,0,2560)
DeclareAlias2("building.HDifTil[1].briCoe.b1", "", "building.HDifTil[1].briCoe.a1", 1,\
 5, 231, 1024)
DeclareVariable("building.HDifTil[1].briCoe.b2", "", 0.0, 0.0,0.0,0.0,0,2560)
DeclareVariable("building.HDifTil[1].briCoe.b3", "", 0.0, 0.0,0.0,0.0,0,2560)
DeclareVariable("building.HDifTil[1].briCoe.b4", "", 0.0, 0.0,0.0,0.0,0,2560)
DeclareVariable("building.HDifTil[1].briCoe.b5", "", 0.0, 0.0,0.0,0.0,0,2560)
DeclareVariable("building.HDifTil[1].briCoe.b6", "", 0.0, 0.0,0.0,0.0,0,2560)
DeclareVariable("building.HDifTil[1].briCoe.b7", "", 0.0, 0.0,0.0,0.0,0,2560)
DeclareAlias2("building.HDifTil[1].briCoe.b8", "", "building.HDifTil[1].briCoe.a8", 1,\
 5, 238, 1024)
DeclareAlias2("building.HDifTil[1].relAirMas.zen", "Zenith angle of the sun beam [rad|deg]",\
 "weaDat.altAng.zen", 1, 5, 160, 1024)
DeclareVariable("building.HDifTil[1].relAirMas.relAirMas", "Relative air mass", \
0.0, 0.0,0.0,0.0,0,2560)
DeclareVariable("building.HDifTil[1].relAirMas.zenLim", "Zenith angle bounded from above by 90 degree",\
 0.0, 0.0,0.0,0.0,0,2560)
DeclareVariable("building.HDifTil[1].relAirMas.zenDeg", "Zenith angle in degree",\
 0.0, 0.0,0.0,0.0,0,2560)
DeclareAlias2("building.HDifTil[1].skyBri.relAirMas", "Relative air mass", \
"building.HDifTil[1].relAirMas.relAirMas", 1, 5, 245, 1024)
DeclareAlias2("building.HDifTil[1].skyBri.HDifHor", "Horizontal diffuse solar radiation [W/m2]",\
 "weaDat.cheDifHorRad.HOut", 1, 5, 88, 1024)
DeclareAlias2("building.HDifTil[1].skyBri.skyBri", "Sky brightness", \
"building.HDifTil[1].briCoe.skyBri", 1, 5, 223, 1024)
DeclareVariable("building.HDifTil[1].incAng.lat", "Latitude [rad|deg]", 0.0, \
0.0,0.0,0.0,0,2561)
DeclareVariable("building.HDifTil[1].incAng.azi", "Surface azimuth [rad|deg]", \
0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("building.HDifTil[1].incAng.til", "Surface tilt [rad|deg]", 0.0,\
 0.0,0.0,0.0,0,2561)
DeclareAlias2("building.HDifTil[1].incAng.y", "Incidence angle [rad|deg]", \
"building.HDifTil[1].HDifTil.incAng", 1, 5, 213, 1024)
DeclareAlias2("building.HDifTil[1].incAng.decAng.nDay", "Day number with units of seconds [s]",\
 "weaDat.modTim.y", 1, 5, 106, 1024)
DeclareVariable("building.HDifTil[1].incAng.decAng.decAng", "Solar declination angle [rad|deg]",\
 0.0, 0.0,0.0,0.0,0,2560)
DeclareVariable("building.HDifTil[1].incAng.decAng.k1", "Constant", \
0.3979486313076103, 0.0,0.0,0.0,0,2561)
DeclareVariable("building.HDifTil[1].incAng.decAng.k2", "Constant", \
0.017202423838958484, 0.0,0.0,0.0,0,2561)
DeclareAlias2("building.HDifTil[1].incAng.solHouAng.solTim", "Solar time [s]", \
"weaDat.solTim.solTim", 1, 5, 138, 1024)
DeclareVariable("building.HDifTil[1].incAng.solHouAng.solHouAng", \
"Solar hour angle [rad|deg]", 0.0, 0.0,0.0,0.0,0,2560)
DeclareVariable("building.HDifTil[1].incAng.incAng.lat", "Latitude [rad|deg]", \
0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("building.HDifTil[1].incAng.incAng.azi", "Surface azimuth. azi=-90 degree if surface outward unit normal points toward east; azi=0 if it points toward south [rad|deg]",\
 0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("building.HDifTil[1].incAng.incAng.til", "Surface tilt. til=90 degree for walls; til=0 for ceilings; til=180 for roof [rad|deg]",\
 0.0, 0.0,0.0,0.0,0,2561)
DeclareAlias2("building.HDifTil[1].incAng.incAng.solHouAng", "Solar hour angle [rad]",\
 "building.HDifTil[1].incAng.solHouAng.solHouAng", 1, 5, 254, 1024)
DeclareAlias2("building.HDifTil[1].incAng.incAng.decAng", "Declination [rad]", \
"building.HDifTil[1].incAng.decAng.decAng", 1, 5, 251, 1024)
DeclareAlias2("building.HDifTil[1].incAng.incAng.incAng", "Incidence angle on a tilted surface [rad|deg]",\
 "building.HDifTil[1].HDifTil.incAng", 1, 5, 213, 1024)
DeclareVariable("building.HDifTil[1].incAng.incAng.dec_c", "Cosine of declination angle",\
 0.0, 0.0,0.0,0.0,0,2560)
DeclareVariable("building.HDifTil[1].incAng.incAng.dec_s", "Sine of declination angle",\
 0.0, 0.0,0.0,0.0,0,2560)
DeclareVariable("building.HDifTil[1].incAng.incAng.sol_c", "Cosine of solar hour angle",\
 0.0, 0.0,0.0,0.0,0,2560)
DeclareVariable("building.HDifTil[1].incAng.incAng.sol_s", "Sine of solar hour angle",\
 0.0, 0.0,0.0,0.0,0,2560)
DeclareVariable("building.HDifTil[1].incAng.incAng.lat_c", "Cosine of latitude",\
 0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("building.HDifTil[1].incAng.incAng.lat_s", "Sine of latitude", \
0.0, 0.0,0.0,0.0,0,2561)
DeclareParameter("building.HDifTil[2].til", "Surface tilt [rad|deg]", 35, \
1.5707963267949, 0.0,0.0,0.0,0,560)
DeclareVariable("building.HDifTil[2].H", "Radiation per unit area [W/m2]", 0.0, \
0.0,0.0,0.0,0,512)
DeclareParameter("building.HDifTil[2].rho", "Ground reflectance [1]", 36, 0.2, \
0.0,1.0,0.0,0,560)
DeclareParameter("building.HDifTil[2].lat", "Latitude [rad|deg]", 37, \
0.87266462599716, 0.0,0.0,0.0,0,560)
DeclareParameter("building.HDifTil[2].azi", "Surface azimuth [rad|deg]", 38, \
4.7123889803847, 0.0,0.0,0.0,0,560)
DeclareVariable("building.HDifTil[2].outSkyCon", "Output contribution of diffuse irradiation from sky [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,515)
DeclareVariable("building.HDifTil[2].outGroCon", "Output contribution of diffuse irradiation from ground [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,515)
DeclareAlias2("building.HDifTil[2].add.u1", "Connector of Real input signal 1", \
"building.corGDouPan.HSkyDifTil[2]", 1, 5, 356, 0)
DeclareAlias2("building.HDifTil[2].add.u2", "Connector of Real input signal 2", \
"building.corGDouPan.HGroDifTil[2]", 1, 5, 360, 0)
DeclareAlias2("building.HDifTil[2].add.y", "Connector of Real output signal", \
"building.HDifTil[2].H", 1, 5, 264, 0)
DeclareParameter("building.HDifTil[2].add.k1", "Gain of upper input", 39, 1, \
0.0,0.0,0.0,0,560)
DeclareParameter("building.HDifTil[2].add.k2", "Gain of lower input", 40, 1, \
0.0,0.0,0.0,0,560)
DeclareAlias2("building.HDifTil[2].HSkyDifTil", "Hemispherical diffuse solar irradiation on a tilted surface from the sky",\
 "building.corGDouPan.HSkyDifTil[2]", 1, 5, 356, 0)
DeclareAlias2("building.HDifTil[2].HGroDifTil", "Hemispherical diffuse solar irradiation on a tilted surface from the ground",\
 "building.corGDouPan.HGroDifTil[2]", 1, 5, 360, 0)
DeclareVariable("building.HDifTil[2].HDifTil.rho", "Ground reflectance", 0.0, \
0.0,0.0,0.0,0,2561)
DeclareVariable("building.HDifTil[2].HDifTil.til", "Surface tilt angle [rad|deg]",\
 0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("building.HDifTil[2].HDifTil.briCof1", "Brightening Coeffcient F1",\
 0.0, 0.0,0.0,0.0,0,2560)
DeclareVariable("building.HDifTil[2].HDifTil.briCof2", "Brightening Coeffcient F2",\
 0.0, 0.0,0.0,0.0,0,2560)
DeclareAlias2("building.HDifTil[2].HDifTil.HDifHor", "Diffuse horizontal solar radiation [W/m2]",\
 "weaDat.cheDifHorRad.HOut", 1, 5, 88, 1024)
DeclareAlias2("building.HDifTil[2].HDifTil.HGloHor", "Global horizontal radiation [W/m2]",\
 "weaDat.cheGloHorRad.HOut", 1, 5, 86, 1024)
DeclareAlias2("building.HDifTil[2].HDifTil.zen", "Zenith angle of the sun beam [rad|deg]",\
 "weaDat.altAng.zen", 1, 5, 160, 1024)
DeclareVariable("building.HDifTil[2].HDifTil.incAng", "Solar incidence angle on the surface [rad|deg]",\
 0.0, 0.0,0.0,0.0,0,2560)
DeclareAlias2("building.HDifTil[2].HDifTil.HGroDifTil", "Hemispherical diffuse solar irradiation on a tilted surface from the ground [W/m2]",\
 "building.corGDouPan.HGroDifTil[2]", 1, 5, 360, 1024)
DeclareAlias2("building.HDifTil[2].HDifTil.HSkyDifTil", "Hemispherical diffuse solar irradiation on a tilted surface from the sky [W/m2]",\
 "building.corGDouPan.HSkyDifTil[2]", 1, 5, 356, 1024)
DeclareVariable("building.HDifTil[2].HDifTil.a", "", 0.0, 0.0,0.0,0.0,0,2560)
DeclareVariable("building.HDifTil[2].HDifTil.b", "", 0.0, 0.0,0.0,0.0,0,2560)
DeclareVariable("building.HDifTil[2].HDifTil.bMin", "Lower bound for b", \
0.08715574274765814, 0.0,0.0,0.0,0,2561)
DeclareAlias2("building.HDifTil[2].skyCle.zen", "Zenith angle of the sun beam [rad|degreeC]",\
 "weaDat.altAng.zen", 1, 5, 160, 1024)
DeclareAlias2("building.HDifTil[2].skyCle.HDifHor", "Horizontal diffuse solar radiation [W/m2]",\
 "weaDat.cheDifHorRad.HOut", 1, 5, 88, 1024)
DeclareAlias2("building.HDifTil[2].skyCle.HGloHor", "Horizontal global solar radiation [W/m2]",\
 "weaDat.cheGloHorRad.HOut", 1, 5, 86, 1024)
DeclareVariable("building.HDifTil[2].skyCle.skyCle", "Sky clearness. skyCle=1: overast sky; skyCle=8: clear sky",\
 0.0, 0.0,0.0,0.0,0,2560)
DeclareVariable("building.HDifTil[2].skyCle.hSmall", "Small radiation for regularization [W/m2]",\
 5E-05, 0.0,0.0,0.0,0,2561)
DeclareVariable("building.HDifTil[2].skyCle.deltaX", "Small radiation for regularization [W/m2]",\
 2.5E-05, 0.0,0.0,0.0,0,2561)
DeclareVariable("building.HDifTil[2].skyCle.k", "Constant factor", \
1.040895310738997, 0.0,0.0,0.0,0,2561)
DeclareVariable("building.HDifTil[2].skyCle.tmp1", "Intermediate variable", 0.0,\
 0.0,0.0,0.0,0,2560)
DeclareVariable("building.HDifTil[2].skyCle.HDifHorBou", "Diffuse horizontal irradiation, bounded away from zero [W/m2]",\
 0.0, 0.0,0.0,0.0,0,2560)
DeclareAlias2("building.HDifTil[2].briCoe.zen", "Zenith angle of the sun beam [rad|deg]",\
 "weaDat.altAng.zen", 1, 5, 160, 1024)
DeclareAlias2("building.HDifTil[2].briCoe.skyCle", "Sky clearness. skyCle=1: overcast sky; skyCle=8 clear sky",\
 "building.HDifTil[2].skyCle.skyCle", 1, 5, 275, 1024)
DeclareVariable("building.HDifTil[2].briCoe.skyBri", "Sky brightness [0,1] []", \
0.0, 0.0,0.0,0.0,0,2560)
DeclareAlias2("building.HDifTil[2].briCoe.F1", "Circumsolar brightening coefficient",\
 "building.HDifTil[2].HDifTil.briCof1", 1, 5, 269, 1024)
DeclareAlias2("building.HDifTil[2].briCoe.F2", "Horizon brightening coefficient",\
 "building.HDifTil[2].HDifTil.briCof2", 1, 5, 270, 1024)
DeclareVariable("building.HDifTil[2].briCoe.F11", "", 0.0, 0.0,0.0,0.0,0,2560)
DeclareVariable("building.HDifTil[2].briCoe.F12", "", 0.0, 0.0,0.0,0.0,0,2560)
DeclareVariable("building.HDifTil[2].briCoe.F13", "", 0.0, 0.0,0.0,0.0,0,2560)
DeclareVariable("building.HDifTil[2].briCoe.F21", "", 0.0, 0.0,0.0,0.0,0,2560)
DeclareVariable("building.HDifTil[2].briCoe.F22", "", 0.0, 0.0,0.0,0.0,0,2560)
DeclareVariable("building.HDifTil[2].briCoe.F23", "", 0.0, 0.0,0.0,0.0,0,2560)
DeclareVariable("building.HDifTil[2].briCoe.d", "", 0.01, 0.0,0.0,0.0,0,2561)
DeclareVariable("building.HDifTil[2].briCoe.a1", "", 0.0, 0.0,0.0,0.0,0,2560)
DeclareVariable("building.HDifTil[2].briCoe.a2", "", 0.0, 0.0,0.0,0.0,0,2560)
DeclareVariable("building.HDifTil[2].briCoe.a3", "", 0.0, 0.0,0.0,0.0,0,2560)
DeclareVariable("building.HDifTil[2].briCoe.a4", "", 0.0, 0.0,0.0,0.0,0,2560)
DeclareVariable("building.HDifTil[2].briCoe.a5", "", 0.0, 0.0,0.0,0.0,0,2560)
DeclareVariable("building.HDifTil[2].briCoe.a6", "", 0.0, 0.0,0.0,0.0,0,2560)
DeclareVariable("building.HDifTil[2].briCoe.a7", "", 0.0, 0.0,0.0,0.0,0,2560)
DeclareVariable("building.HDifTil[2].briCoe.a8", "", 0.0, 0.0,0.0,0.0,0,2560)
DeclareAlias2("building.HDifTil[2].briCoe.b1", "", "building.HDifTil[2].briCoe.a1", 1,\
 5, 289, 1024)
DeclareVariable("building.HDifTil[2].briCoe.b2", "", 0.0, 0.0,0.0,0.0,0,2560)
DeclareVariable("building.HDifTil[2].briCoe.b3", "", 0.0, 0.0,0.0,0.0,0,2560)
DeclareVariable("building.HDifTil[2].briCoe.b4", "", 0.0, 0.0,0.0,0.0,0,2560)
DeclareVariable("building.HDifTil[2].briCoe.b5", "", 0.0, 0.0,0.0,0.0,0,2560)
DeclareVariable("building.HDifTil[2].briCoe.b6", "", 0.0, 0.0,0.0,0.0,0,2560)
DeclareVariable("building.HDifTil[2].briCoe.b7", "", 0.0, 0.0,0.0,0.0,0,2560)
DeclareAlias2("building.HDifTil[2].briCoe.b8", "", "building.HDifTil[2].briCoe.a8", 1,\
 5, 296, 1024)
DeclareAlias2("building.HDifTil[2].relAirMas.zen", "Zenith angle of the sun beam [rad|deg]",\
 "weaDat.altAng.zen", 1, 5, 160, 1024)
DeclareVariable("building.HDifTil[2].relAirMas.relAirMas", "Relative air mass", \
0.0, 0.0,0.0,0.0,0,2560)
DeclareVariable("building.HDifTil[2].relAirMas.zenLim", "Zenith angle bounded from above by 90 degree",\
 0.0, 0.0,0.0,0.0,0,2560)
DeclareVariable("building.HDifTil[2].relAirMas.zenDeg", "Zenith angle in degree",\
 0.0, 0.0,0.0,0.0,0,2560)
DeclareAlias2("building.HDifTil[2].skyBri.relAirMas", "Relative air mass", \
"building.HDifTil[2].relAirMas.relAirMas", 1, 5, 303, 1024)
DeclareAlias2("building.HDifTil[2].skyBri.HDifHor", "Horizontal diffuse solar radiation [W/m2]",\
 "weaDat.cheDifHorRad.HOut", 1, 5, 88, 1024)
DeclareAlias2("building.HDifTil[2].skyBri.skyBri", "Sky brightness", \
"building.HDifTil[2].briCoe.skyBri", 1, 5, 281, 1024)
DeclareVariable("building.HDifTil[2].incAng.lat", "Latitude [rad|deg]", 0.0, \
0.0,0.0,0.0,0,2561)
DeclareVariable("building.HDifTil[2].incAng.azi", "Surface azimuth [rad|deg]", \
0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("building.HDifTil[2].incAng.til", "Surface tilt [rad|deg]", 0.0,\
 0.0,0.0,0.0,0,2561)
DeclareAlias2("building.HDifTil[2].incAng.y", "Incidence angle [rad|deg]", \
"building.HDifTil[2].HDifTil.incAng", 1, 5, 271, 1024)
DeclareAlias2("building.HDifTil[2].incAng.decAng.nDay", "Day number with units of seconds [s]",\
 "weaDat.modTim.y", 1, 5, 106, 1024)
DeclareVariable("building.HDifTil[2].incAng.decAng.decAng", "Solar declination angle [rad|deg]",\
 0.0, 0.0,0.0,0.0,0,2560)
DeclareVariable("building.HDifTil[2].incAng.decAng.k1", "Constant", \
0.3979486313076103, 0.0,0.0,0.0,0,2561)
DeclareVariable("building.HDifTil[2].incAng.decAng.k2", "Constant", \
0.017202423838958484, 0.0,0.0,0.0,0,2561)
DeclareAlias2("building.HDifTil[2].incAng.solHouAng.solTim", "Solar time [s]", \
"weaDat.solTim.solTim", 1, 5, 138, 1024)
DeclareVariable("building.HDifTil[2].incAng.solHouAng.solHouAng", \
"Solar hour angle [rad|deg]", 0.0, 0.0,0.0,0.0,0,2560)
DeclareVariable("building.HDifTil[2].incAng.incAng.lat", "Latitude [rad|deg]", \
0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("building.HDifTil[2].incAng.incAng.azi", "Surface azimuth. azi=-90 degree if surface outward unit normal points toward east; azi=0 if it points toward south [rad|deg]",\
 0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("building.HDifTil[2].incAng.incAng.til", "Surface tilt. til=90 degree for walls; til=0 for ceilings; til=180 for roof [rad|deg]",\
 0.0, 0.0,0.0,0.0,0,2561)
DeclareAlias2("building.HDifTil[2].incAng.incAng.solHouAng", "Solar hour angle [rad]",\
 "building.HDifTil[2].incAng.solHouAng.solHouAng", 1, 5, 312, 1024)
DeclareAlias2("building.HDifTil[2].incAng.incAng.decAng", "Declination [rad]", \
"building.HDifTil[2].incAng.decAng.decAng", 1, 5, 309, 1024)
DeclareAlias2("building.HDifTil[2].incAng.incAng.incAng", "Incidence angle on a tilted surface [rad|deg]",\
 "building.HDifTil[2].HDifTil.incAng", 1, 5, 271, 1024)
DeclareVariable("building.HDifTil[2].incAng.incAng.dec_c", "Cosine of declination angle",\
 0.0, 0.0,0.0,0.0,0,2560)
DeclareVariable("building.HDifTil[2].incAng.incAng.dec_s", "Sine of declination angle",\
 0.0, 0.0,0.0,0.0,0,2560)
DeclareVariable("building.HDifTil[2].incAng.incAng.sol_c", "Cosine of solar hour angle",\
 0.0, 0.0,0.0,0.0,0,2560)
DeclareVariable("building.HDifTil[2].incAng.incAng.sol_s", "Sine of solar hour angle",\
 0.0, 0.0,0.0,0.0,0,2560)
DeclareVariable("building.HDifTil[2].incAng.incAng.lat_c", "Cosine of latitude",\
 0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("building.HDifTil[2].incAng.incAng.lat_s", "Sine of latitude", \
0.0, 0.0,0.0,0.0,0,2561)
DeclareParameter("building.HDirTil[1].til", "Surface tilt [rad|deg]", 41, \
1.5707963267949, 0.0,0.0,0.0,0,560)
DeclareAlias2("building.HDirTil[1].H", "Radiation per unit area [W/m2]", \
"building.corGDouPan.HDirTil[1]", 1, 5, 357, 0)
DeclareParameter("building.HDirTil[1].lat", "Latitude [rad|deg]", 42, \
0.87266462599716, 0.0,0.0,0.0,0,560)
DeclareParameter("building.HDirTil[1].azi", "Surface azimuth [rad|deg]", 43, \
3.1415926535898, 0.0,0.0,0.0,0,560)
DeclareAlias2("building.HDirTil[1].inc", "Incidence angle [rad|deg]", \
"building.corGDouPan.inc[1]", 1, 5, 361, 0)
DeclareVariable("building.HDirTil[1].incAng.lat", "Latitude [rad|deg]", 0.0, \
0.0,0.0,0.0,0,2561)
DeclareVariable("building.HDirTil[1].incAng.azi", "Surface azimuth [rad|deg]", \
0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("building.HDirTil[1].incAng.til", "Surface tilt [rad|deg]", 0.0,\
 0.0,0.0,0.0,0,2561)
DeclareAlias2("building.HDirTil[1].incAng.y", "Incidence angle [rad|deg]", \
"building.corGDouPan.inc[1]", 1, 5, 361, 1024)
DeclareAlias2("building.HDirTil[1].incAng.decAng.nDay", "Day number with units of seconds [s]",\
 "weaDat.modTim.y", 1, 5, 106, 1024)
DeclareVariable("building.HDirTil[1].incAng.decAng.decAng", "Solar declination angle [rad|deg]",\
 0.0, 0.0,0.0,0.0,0,2560)
DeclareVariable("building.HDirTil[1].incAng.decAng.k1", "Constant", \
0.3979486313076103, 0.0,0.0,0.0,0,2561)
DeclareVariable("building.HDirTil[1].incAng.decAng.k2", "Constant", \
0.017202423838958484, 0.0,0.0,0.0,0,2561)
DeclareAlias2("building.HDirTil[1].incAng.solHouAng.solTim", "Solar time [s]", \
"weaDat.solTim.solTim", 1, 5, 138, 1024)
DeclareVariable("building.HDirTil[1].incAng.solHouAng.solHouAng", \
"Solar hour angle [rad|deg]", 0.0, 0.0,0.0,0.0,0,2560)
DeclareVariable("building.HDirTil[1].incAng.incAng.lat", "Latitude [rad|deg]", \
0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("building.HDirTil[1].incAng.incAng.azi", "Surface azimuth. azi=-90 degree if surface outward unit normal points toward east; azi=0 if it points toward south [rad|deg]",\
 0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("building.HDirTil[1].incAng.incAng.til", "Surface tilt. til=90 degree for walls; til=0 for ceilings; til=180 for roof [rad|deg]",\
 0.0, 0.0,0.0,0.0,0,2561)
DeclareAlias2("building.HDirTil[1].incAng.incAng.solHouAng", "Solar hour angle [rad]",\
 "building.HDirTil[1].incAng.solHouAng.solHouAng", 1, 5, 328, 1024)
DeclareAlias2("building.HDirTil[1].incAng.incAng.decAng", "Declination [rad]", \
"building.HDirTil[1].incAng.decAng.decAng", 1, 5, 325, 1024)
DeclareAlias2("building.HDirTil[1].incAng.incAng.incAng", "Incidence angle on a tilted surface [rad|deg]",\
 "building.corGDouPan.inc[1]", 1, 5, 361, 1024)
DeclareVariable("building.HDirTil[1].incAng.incAng.dec_c", "Cosine of declination angle",\
 0.0, 0.0,0.0,0.0,0,2560)
DeclareVariable("building.HDirTil[1].incAng.incAng.dec_s", "Sine of declination angle",\
 0.0, 0.0,0.0,0.0,0,2560)
DeclareVariable("building.HDirTil[1].incAng.incAng.sol_c", "Cosine of solar hour angle",\
 0.0, 0.0,0.0,0.0,0,2560)
DeclareVariable("building.HDirTil[1].incAng.incAng.sol_s", "Sine of solar hour angle",\
 0.0, 0.0,0.0,0.0,0,2560)
DeclareVariable("building.HDirTil[1].incAng.incAng.lat_c", "Cosine of latitude",\
 0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("building.HDirTil[1].incAng.incAng.lat_s", "Sine of latitude", \
0.0, 0.0,0.0,0.0,0,2561)
DeclareAlias2("building.HDirTil[1].HDirTil.incAng", "Incidence angle of the sun beam on a tilted surface [rad|deg]",\
 "building.corGDouPan.inc[1]", 1, 5, 361, 1024)
DeclareAlias2("building.HDirTil[1].HDirTil.HDirNor", "Direct normal radiation [W/m2]",\
 "weaDat.cheDirNorRad.HOut", 1, 5, 90, 1024)
DeclareAlias2("building.HDirTil[1].HDirTil.HDirTil", "Direct solar irradiation on a tilted surface [W/m2]",\
 "building.corGDouPan.HDirTil[1]", 1, 5, 357, 1024)
DeclareParameter("building.HDirTil[2].til", "Surface tilt [rad|deg]", 44, \
1.5707963267949, 0.0,0.0,0.0,0,560)
DeclareAlias2("building.HDirTil[2].H", "Radiation per unit area [W/m2]", \
"building.corGDouPan.HDirTil[2]", 1, 5, 358, 0)
DeclareParameter("building.HDirTil[2].lat", "Latitude [rad|deg]", 45, \
0.87266462599716, 0.0,0.0,0.0,0,560)
DeclareParameter("building.HDirTil[2].azi", "Surface azimuth [rad|deg]", 46, \
4.7123889803847, 0.0,0.0,0.0,0,560)
DeclareAlias2("building.HDirTil[2].inc", "Incidence angle [rad|deg]", \
"building.corGDouPan.inc[2]", 1, 5, 362, 0)
DeclareVariable("building.HDirTil[2].incAng.lat", "Latitude [rad|deg]", 0.0, \
0.0,0.0,0.0,0,2561)
DeclareVariable("building.HDirTil[2].incAng.azi", "Surface azimuth [rad|deg]", \
0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("building.HDirTil[2].incAng.til", "Surface tilt [rad|deg]", 0.0,\
 0.0,0.0,0.0,0,2561)
DeclareAlias2("building.HDirTil[2].incAng.y", "Incidence angle [rad|deg]", \
"building.corGDouPan.inc[2]", 1, 5, 362, 1024)
DeclareAlias2("building.HDirTil[2].incAng.decAng.nDay", "Day number with units of seconds [s]",\
 "weaDat.modTim.y", 1, 5, 106, 1024)
DeclareVariable("building.HDirTil[2].incAng.decAng.decAng", "Solar declination angle [rad|deg]",\
 0.0, 0.0,0.0,0.0,0,2560)
DeclareVariable("building.HDirTil[2].incAng.decAng.k1", "Constant", \
0.3979486313076103, 0.0,0.0,0.0,0,2561)
DeclareVariable("building.HDirTil[2].incAng.decAng.k2", "Constant", \
0.017202423838958484, 0.0,0.0,0.0,0,2561)
DeclareAlias2("building.HDirTil[2].incAng.solHouAng.solTim", "Solar time [s]", \
"weaDat.solTim.solTim", 1, 5, 138, 1024)
DeclareVariable("building.HDirTil[2].incAng.solHouAng.solHouAng", \
"Solar hour angle [rad|deg]", 0.0, 0.0,0.0,0.0,0,2560)
DeclareVariable("building.HDirTil[2].incAng.incAng.lat", "Latitude [rad|deg]", \
0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("building.HDirTil[2].incAng.incAng.azi", "Surface azimuth. azi=-90 degree if surface outward unit normal points toward east; azi=0 if it points toward south [rad|deg]",\
 0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("building.HDirTil[2].incAng.incAng.til", "Surface tilt. til=90 degree for walls; til=0 for ceilings; til=180 for roof [rad|deg]",\
 0.0, 0.0,0.0,0.0,0,2561)
DeclareAlias2("building.HDirTil[2].incAng.incAng.solHouAng", "Solar hour angle [rad]",\
 "building.HDirTil[2].incAng.solHouAng.solHouAng", 1, 5, 344, 1024)
DeclareAlias2("building.HDirTil[2].incAng.incAng.decAng", "Declination [rad]", \
"building.HDirTil[2].incAng.decAng.decAng", 1, 5, 341, 1024)
DeclareAlias2("building.HDirTil[2].incAng.incAng.incAng", "Incidence angle on a tilted surface [rad|deg]",\
 "building.corGDouPan.inc[2]", 1, 5, 362, 1024)
DeclareVariable("building.HDirTil[2].incAng.incAng.dec_c", "Cosine of declination angle",\
 0.0, 0.0,0.0,0.0,0,2560)
DeclareVariable("building.HDirTil[2].incAng.incAng.dec_s", "Sine of declination angle",\
 0.0, 0.0,0.0,0.0,0,2560)
DeclareVariable("building.HDirTil[2].incAng.incAng.sol_c", "Cosine of solar hour angle",\
 0.0, 0.0,0.0,0.0,0,2560)
DeclareVariable("building.HDirTil[2].incAng.incAng.sol_s", "Sine of solar hour angle",\
 0.0, 0.0,0.0,0.0,0,2560)
DeclareVariable("building.HDirTil[2].incAng.incAng.lat_c", "Cosine of latitude",\
 0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("building.HDirTil[2].incAng.incAng.lat_s", "Sine of latitude", \
0.0, 0.0,0.0,0.0,0,2561)
DeclareAlias2("building.HDirTil[2].HDirTil.incAng", "Incidence angle of the sun beam on a tilted surface [rad|deg]",\
 "building.corGDouPan.inc[2]", 1, 5, 362, 1024)
DeclareAlias2("building.HDirTil[2].HDirTil.HDirNor", "Direct normal radiation [W/m2]",\
 "weaDat.cheDirNorRad.HOut", 1, 5, 90, 1024)
DeclareAlias2("building.HDirTil[2].HDirTil.HDirTil", "Direct solar irradiation on a tilted surface [W/m2]",\
 "building.corGDouPan.HDirTil[2]", 1, 5, 358, 1024)
DeclareVariable("building.corGDouPan.n", "Vector size for input and output [:#(type=Integer)]",\
 2, 1.0,1E+100,0.0,0,517)
DeclareParameter("building.corGDouPan.UWin", "Thermal transmission coefficient of whole window [W/(m2.K)]",\
 47, 2.1, 0.0,0.0,0.0,0,560)
DeclareVariable("building.corGDouPan.HSkyDifTil[1]", "Hemispherical diffuse solar irradiation on a tilted surface from the sky [W/m2]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("building.corGDouPan.HSkyDifTil[2]", "Hemispherical diffuse solar irradiation on a tilted surface from the sky [W/m2]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("building.corGDouPan.HDirTil[1]", "Direct solar radiation on a tilted surface per unit area [W/m2]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("building.corGDouPan.HDirTil[2]", "Direct solar radiation on a tilted surface per unit area [W/m2]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("building.corGDouPan.HGroDifTil[1]", "Hemispherical diffuse solar irradiation on a tilted surface from the ground [W/m2]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("building.corGDouPan.HGroDifTil[2]", "Hemispherical diffuse solar irradiation on a tilted surface from the ground [W/m2]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("building.corGDouPan.inc[1]", "Incidence angles [rad|deg]", 0.0,\
 0.0,0.0,0.0,0,512)
DeclareVariable("building.corGDouPan.inc[2]", "Incidence angles [rad|deg]", 0.0,\
 0.0,0.0,0.0,0,512)
DeclareVariable("building.corGDouPan.solarRadWinTrans[1]", "transmitted solar radiation through windows [W/m2]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("building.corGDouPan.solarRadWinTrans[2]", "transmitted solar radiation through windows [W/m2]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareParameter("building.corGDouPan.A0", "Constant 0 to calculate reference transmission",\
 48, 0.918, 0.0,0.0,0.0,0,2608)
DeclareParameter("building.corGDouPan.A1", "Constant 1 to calculate reference transmission",\
 49, 0.000221, 0.0,0.0,0.0,0,2608)
DeclareParameter("building.corGDouPan.A2", "Constant 2 to calculate reference transmission",\
 50, -2.75E-05, 0.0,0.0,0.0,0,2608)
DeclareParameter("building.corGDouPan.A3", "Constant 3 to calculate reference transmission",\
 51, -3.8199999999999995E-07, 0.0,0.0,0.0,0,2608)
DeclareParameter("building.corGDouPan.A4", "Constant 4 to calculate reference transmission",\
 52, 5.83E-08, 0.0,0.0,0.0,0,2608)
DeclareParameter("building.corGDouPan.A5", "Constant 5 to calculate reference transmission",\
 53, -1.15E-09, 0.0,0.0,0.0,0,2608)
DeclareParameter("building.corGDouPan.A6", "Constant 6 to calculate reference transmission",\
 54, 4.74E-12, 0.0,0.0,0.0,0,2608)
DeclareParameter("building.corGDouPan.g_dir0", "Reference vertical parallel transmission coefficient for direct radiation    for double pane window [1]",\
 55, 0.7537, 0.0,0.0,0.0,0,2608)
DeclareParameter("building.corGDouPan.Ta_diff", "Energetic degree of transmission for diffuse radiation for uniformly    overcast sky [1]",\
 56, 0.84, 0.0,0.0,0.0,0,2608)
DeclareParameter("building.corGDouPan.Tai_diff", "Pure degree of transmission for diffuse radiation [1]",\
 57, 0.903, 0.0,0.0,0.0,0,2608)
DeclareVariable("building.corGDouPan.Ta1_diff", "Degreee of transmission for single pane window [1]",\
 0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("building.corGDouPan.rho_T1_diff", "Part of degree of transmission for single pane window related to Ta1_diff [1]",\
 0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("building.corGDouPan.rho_11_diff", "Part of degree of transmission for single pane window    related to rho_T1_diff [1]",\
 0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("building.corGDouPan.rho_1_diff", "Degree of reflection for single pane window [1]",\
 0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("building.corGDouPan.XN2_diff", "Calculation factor to simplify equations [1]",\
 0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("building.corGDouPan.Ta2_diff", "Energetic dregree of transmission for second pane [1]",\
 0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("building.corGDouPan.a1_diff", "Degree of absorption for single pane window [1]",\
 0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("building.corGDouPan.Q21_diff", "Coefficient of heat transfer for exterior pane of double pane window [W/(m2.K)]",\
 0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("building.corGDouPan.Q22_diff", "Coefficient of heat transfer for interior pane of double pane window [W/(m2.K)]",\
 0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("building.corGDouPan.Qsek2_diff", "Overall coefficient of heat transfer for double pane window [W/(m2.K)]",\
 0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("building.corGDouPan.CorG_diff", "Transmission coefficient correction factor for diffuse radiation [1]",\
 0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("building.corGDouPan.CorG_gr", "Transmission coefficient correction factor for irradiations from ground [1]",\
 0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("building.corGDouPan.Ta_dir[1]", "Energetic degree of transmission for direct radiation [1]",\
 0.0, 0.0,0.0,0.0,0,2560)
DeclareVariable("building.corGDouPan.Ta_dir[2]", "Energetic degree of transmission for direct radiation [1]",\
 0.0, 0.0,0.0,0.0,0,2560)
DeclareVariable("building.corGDouPan.Tai_dir[1]", "Pure degree of transmission for direct radiation [1]",\
 0.0, 0.0,0.0,0.0,0,2560)
DeclareVariable("building.corGDouPan.Tai_dir[2]", "Pure degree of transmission for direct radiation [1]",\
 0.0, 0.0,0.0,0.0,0,2560)
DeclareVariable("building.corGDouPan.Ta1_dir[1]", "Pure degree of transmission for single pane window [1]",\
 0.0, 0.0,0.0,0.0,0,2560)
DeclareVariable("building.corGDouPan.Ta1_dir[2]", "Pure degree of transmission for single pane window [1]",\
 0.0, 0.0,0.0,0.0,0,2560)
DeclareVariable("building.corGDouPan.rho_T1_dir[1]", "Part of degree of transmission for single pane window related to Ta1_dir [1]",\
 0.0, 0.0,0.0,0.0,0,2560)
DeclareVariable("building.corGDouPan.rho_T1_dir[2]", "Part of degree of transmission for single pane window related to Ta1_dir [1]",\
 0.0, 0.0,0.0,0.0,0,2560)
DeclareVariable("building.corGDouPan.rho_11_dir[1]", "Part of degree of transmission for single pane window related to T1_dir [1]",\
 0.0, 0.0,0.0,0.0,0,2560)
DeclareVariable("building.corGDouPan.rho_11_dir[2]", "Part of degree of transmission for single pane window related to T1_dir [1]",\
 0.0, 0.0,0.0,0.0,0,2560)
DeclareVariable("building.corGDouPan.rho_1_dir[1]", "Degree of reflection for single pane window [1]",\
 0.0, 0.0,0.0,0.0,0,2560)
DeclareVariable("building.corGDouPan.rho_1_dir[2]", "Degree of reflection for single pane window [1]",\
 0.0, 0.0,0.0,0.0,0,2560)
DeclareVariable("building.corGDouPan.XN2_dir[1]", "Calculation factor to simplify equations [1]",\
 0.0, 0.0,0.0,0.0,0,2560)
DeclareVariable("building.corGDouPan.XN2_dir[2]", "Calculation factor to simplify equations [1]",\
 0.0, 0.0,0.0,0.0,0,2560)
DeclareVariable("building.corGDouPan.Ta2_dir[1]", "Energetic dregree of transmission for second pane [1]",\
 0.0, 0.0,0.0,0.0,0,2560)
DeclareVariable("building.corGDouPan.Ta2_dir[2]", "Energetic dregree of transmission for second pane [1]",\
 0.0, 0.0,0.0,0.0,0,2560)
DeclareVariable("building.corGDouPan.a1_dir[1]", "Degree of absorption for single pane window [1]",\
 0.0, 0.0,0.0,0.0,0,2560)
DeclareVariable("building.corGDouPan.a1_dir[2]", "Degree of absorption for single pane window [1]",\
 0.0, 0.0,0.0,0.0,0,2560)
DeclareVariable("building.corGDouPan.Q21_dir[1]", "Coefficient of heat transfer for exterior pane of double pane window",\
 0.0, 0.0,0.0,0.0,0,2560)
DeclareVariable("building.corGDouPan.Q21_dir[2]", "Coefficient of heat transfer for exterior pane of double pane window",\
 0.0, 0.0,0.0,0.0,0,2560)
DeclareVariable("building.corGDouPan.Q22_dir[1]", "Coefficient of heat transfer for interior pane of double pane window",\
 0.0, 0.0,0.0,0.0,0,2560)
DeclareVariable("building.corGDouPan.Q22_dir[2]", "Coefficient of heat transfer for interior pane of double pane window",\
 0.0, 0.0,0.0,0.0,0,2560)
DeclareVariable("building.corGDouPan.Qsek2_dir[1]", "Overall coefficient of heat transfer for double pane window",\
 0.0, 0.0,0.0,0.0,0,2560)
DeclareVariable("building.corGDouPan.Qsek2_dir[2]", "Overall coefficient of heat transfer for double pane window",\
 0.0, 0.0,0.0,0.0,0,2560)
DeclareVariable("building.corGDouPan.CorG_dir[1]", "Transmission coefficient correction factor for direct radiation [1]",\
 0.0, 0.0,0.0,0.0,0,2560)
DeclareVariable("building.corGDouPan.CorG_dir[2]", "Transmission coefficient correction factor for direct radiation [1]",\
 0.0, 0.0,0.0,0.0,0,2560)
DeclareVariable("building.thermalZoneOneElement.energyDynamics", \
"Type of energy balance: dynamic (3 initialization options) or steady state [:#(type=Modelica.Fluid.Types.Dynamics)]",\
 2, 1.0,4.0,0.0,0,517)
DeclareVariable("building.thermalZoneOneElement.massDynamics", "Type of mass balance: dynamic (3 initialization options) or steady state [:#(type=Modelica.Fluid.Types.Dynamics)]",\
 2, 1.0,4.0,0.0,0,517)
DeclareVariable("building.thermalZoneOneElement.substanceDynamics", \
"Type of independent mass fraction balance: dynamic (3 initialization options) or steady state [:#(type=Modelica.Fluid.Types.Dynamics)]",\
 2, 1.0,4.0,0.0,0,517)
DeclareVariable("building.thermalZoneOneElement.traceDynamics", "Type of trace substance balance: dynamic (3 initialization options) or steady state [:#(type=Modelica.Fluid.Types.Dynamics)]",\
 2, 1.0,4.0,0.0,0,517)
DeclareParameter("building.thermalZoneOneElement.p_start", "Start value of pressure [Pa|bar]",\
 58, 101325, 0.0,100000000.0,100000.0,0,560)
DeclareParameter("building.thermalZoneOneElement.T_start", "Start value of temperature [K|degC]",\
 59, 295.15, 273.15,373.15,300.0,0,560)
DeclareParameter("building.thermalZoneOneElement.X_start[1]", "Start value of mass fractions m_i/m [kg/kg]",\
 60, 1.0, 0.0,1.0,0.1,0,560)
DeclareVariable("building.thermalZoneOneElement.mSenFac", "Factor for scaling the sensible thermal mass of the volume",\
 1, 1.0,1E+100,0.0,0,513)
DeclareVariable("building.thermalZoneOneElement.VAir", "Air volume of the zone [m3]",\
 52.5, 0.0,0.0,0.0,0,513)
DeclareParameter("building.thermalZoneOneElement.hRad", "Coefficient of heat transfer for linearized radiation exchange between walls [W/(m2.K)]",\
 61, 5, 0.0,0.0,0.0,0,560)
DeclareVariable("building.thermalZoneOneElement.nOrientations", "Number of orientations [:#(type=Integer)]",\
 2, 1.0,1E+100,0.0,0,517)
DeclareVariable("building.thermalZoneOneElement.nPorts", "Number of fluid ports [:#(type=Integer)]",\
 0, 0.0,0.0,0.0,0,517)
DeclareVariable("building.thermalZoneOneElement.AWin[1]", "Vector of areas of windows by orientations [m2]",\
 7.0, 0.0,0.0,0.0,0,513)
DeclareVariable("building.thermalZoneOneElement.AWin[2]", "Vector of areas of windows by orientations [m2]",\
 7.0, 0.0,0.0,0.0,0,513)
DeclareVariable("building.thermalZoneOneElement.ATransparent[1]", \
"Vector of areas of transparent (solar radiation transmittend) elements by    orientations [m2]",\
 7, 0.0,0.0,0.0,0,513)
DeclareVariable("building.thermalZoneOneElement.ATransparent[2]", \
"Vector of areas of transparent (solar radiation transmittend) elements by    orientations [m2]",\
 7, 0.0,0.0,0.0,0,513)
DeclareParameter("building.thermalZoneOneElement.hConWin", "Convective coefficient of heat transfer of windows (indoor) [W/(m2.K)]",\
 62, 2.7, 0.0,0.0,0.0,0,560)
DeclareParameter("building.thermalZoneOneElement.RWin", "Resistor for windows [K/W]",\
 63, 0.01642857143, 0.0,0.0,0.0,0,560)
DeclareParameter("building.thermalZoneOneElement.gWin", "Total energy transmittance of windows [1]",\
 64, 1, 0.0,0.0,0.0,0,560)
DeclareVariable("building.thermalZoneOneElement.ratioWinConRad", \
"Ratio for windows between indoor convective and radiative heat emission", 0.09,\
 0.0,0.0,0.0,0,513)
DeclareVariable("building.thermalZoneOneElement.indoorPortWin", "Additional heat port at indoor surface of windows [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,515)
DeclareVariable("building.thermalZoneOneElement.AExt[1]", "Vector of areas of exterior walls by orientations [m2]",\
 3.5, 0.0,0.0,0.0,0,513)
DeclareVariable("building.thermalZoneOneElement.AExt[2]", "Vector of areas of exterior walls by orientations [m2]",\
 8.0, 0.0,0.0,0.0,0,513)
DeclareParameter("building.thermalZoneOneElement.hConExt", "Convective coefficient of heat transfer of exterior walls (indoor) [W/(m2.K)]",\
 65, 2.7, 0.0,0.0,0.0,0,560)
DeclareVariable("building.thermalZoneOneElement.nExt", "Number of RC-elements of exterior walls [:#(type=Integer)]",\
 1, 1.0,1E+100,0.0,0,517)
DeclareParameter("building.thermalZoneOneElement.RExt[1]", "Vector of resistances of exterior walls, from inside to outside [K/W]",\
 66, 0.00331421908725, 1E-60,1E+100,0.0,0,560)
DeclareParameter("building.thermalZoneOneElement.RExtRem", "Resistance of remaining resistor RExtRem between capacity n and outside [K/W]",\
 67, 0.1265217391, 1E-60,1E+100,0.0,0,560)
DeclareParameter("building.thermalZoneOneElement.CExt[1]", "Vector of heat capacities of exterior walls, from inside to outside [J/K]",\
 68, 5259932.23, 1E-60,1E+100,0.0,0,560)
DeclareVariable("building.thermalZoneOneElement.indoorPortExtWalls", \
"Additional heat port at indoor surface of exterior walls [:#(type=Boolean)]", \
false, 0.0,0.0,0.0,0,515)
DeclareVariable("building.thermalZoneOneElement.use_moisture_balance", \
"If true, input connector QLat_flow is enabled and room air computes moisture balance [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,515)
DeclareAlias2("building.thermalZoneOneElement.solRad[1]", "Solar radiation transmitted through windows [W/m2]",\
 "building.corGDouPan.solarRadWinTrans[1]", 1, 5, 363, 0)
DeclareAlias2("building.thermalZoneOneElement.solRad[2]", "Solar radiation transmitted through windows [W/m2]",\
 "building.corGDouPan.solarRadWinTrans[2]", 1, 5, 364, 0)
DeclareVariable("building.thermalZoneOneElement.volAir.energyDynamics", \
"Type of energy balance: dynamic (3 initialization options) or steady state [:#(type=Modelica.Fluid.Types.Dynamics)]",\
 2, 1.0,4.0,0.0,0,517)
DeclareVariable("building.thermalZoneOneElement.volAir.massDynamics", \
"Type of mass balance: dynamic (3 initialization options) or steady state [:#(type=Modelica.Fluid.Types.Dynamics)]",\
 2, 1.0,4.0,0.0,0,517)
DeclareVariable("building.thermalZoneOneElement.volAir.substanceDynamics", \
"Type of independent mass fraction balance: dynamic (3 initialization options) or steady state [:#(type=Modelica.Fluid.Types.Dynamics)]",\
 2, 1.0,4.0,0.0,0,517)
DeclareVariable("building.thermalZoneOneElement.volAir.traceDynamics", \
"Type of trace substance balance: dynamic (3 initialization options) or steady state [:#(type=Modelica.Fluid.Types.Dynamics)]",\
 2, 1.0,4.0,0.0,0,517)
DeclareVariable("building.thermalZoneOneElement.volAir.p_start", \
"Start value of pressure [Pa|bar]", 100000.0, 0.0,100000000.0,100000.0,0,513)
DeclareVariable("building.thermalZoneOneElement.volAir.T_start", \
"Start value of temperature [K|degC]", 288.15, 273.15,373.15,300.0,0,513)
DeclareVariable("building.thermalZoneOneElement.volAir.X_start[1]", \
"Start value of mass fractions m_i/m [kg/kg]", 0.0, 0.0,1.0,0.1,0,513)
DeclareVariable("building.thermalZoneOneElement.volAir.mSenFac", \
"Factor for scaling the sensible thermal mass of the volume", 1.0, 1.0,1E+100,\
0.0,0,513)
DeclareVariable("building.thermalZoneOneElement.volAir.initialize_p", \
"= true to set up initial equations for pressure [:#(type=Boolean)]", true, \
0.0,0.0,0.0,0,1539)
DeclareVariable("building.thermalZoneOneElement.volAir.prescribedHeatFlowRate", \
"Set to true if the model has a prescribed heat flow at its heatPort. If the heat flow rate at the heatPort is only based on temperature difference, then set to false [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,515)
DeclareVariable("building.thermalZoneOneElement.volAir.simplify_mWat_flow", \
"Set to true to cause port_a.m_flow + port_b.m_flow = 0 even if mWat_flow is non-zero [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,515)
DeclareVariable("building.thermalZoneOneElement.volAir.m_flow_nominal", \
"Nominal mass flow rate [kg/s]", 0.105, 0.0,1E+100,0.0,0,513)
DeclareVariable("building.thermalZoneOneElement.volAir.nPorts", "Number of ports [:#(type=Integer)]",\
 0, 0.0,0.0,0.0,0,517)
DeclareVariable("building.thermalZoneOneElement.volAir.m_flow_small", \
"Small mass flow rate for regularization of zero flow [kg/s]", 1.05E-05, 0.0,\
1E+100,0.0,0,513)
DeclareVariable("building.thermalZoneOneElement.volAir.allowFlowReversal", \
"= false to simplify equations, assuming, but not enforcing, no flow reversal. Used only if model has two ports. [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,515)
DeclareVariable("building.thermalZoneOneElement.volAir.V", "Volume [m3]", 52.5, \
0.0,0.0,0.0,0,513)
DeclareAlias2("building.thermalZoneOneElement.volAir.T", "Temperature of the fluid [K|degC]",\
 "building.heaPorCoo[1].T", 1, 5, 188, 0)
DeclareAlias2("building.thermalZoneOneElement.volAir.U", "Internal energy of the component [J]",\
 "building.thermalZoneOneElement.volAir.dynBal.U", 1, 1, 13, 0)
DeclareAlias2("building.thermalZoneOneElement.volAir.p", "Pressure of the fluid [Pa|bar]",\
 "building.thermalZoneOneElement.volAir.p_start", 1, 5, 426, 0)
DeclareAlias2("building.thermalZoneOneElement.volAir.m", "Mass of the component [kg]",\
 "building.thermalZoneOneElement.volAir.dynBal.m", 1, 1, 14, 0)
DeclareVariable("building.thermalZoneOneElement.volAir.rho_start", \
"Density, used to compute start and guess values [kg/m3|g/cm3]", 0.0, 0.0,1E+100,\
0.0,0,2561)
DeclareVariable("_GlobalScope.Modelica.Media.Interfaces.PartialPureSubstance.X_default[1]",\
 "Default value for mass fractions of medium (for initialization) [kg/kg]", 1.0,\
 0.0,1.0,0.1,0,2561)
DeclareVariable("building.thermalZoneOneElement.volAir.state_default.p", \
"Absolute pressure of medium [Pa|bar]", 101325.0, 0.0,100000000.0,100000.0,0,2561)
DeclareVariable("building.thermalZoneOneElement.volAir.state_default.T", \
"Temperature of medium [K|degC]", 293.15, 273.15,373.15,300.0,0,2561)
DeclareVariable("building.thermalZoneOneElement.volAir.rho_default", \
"Density, used to compute fluid mass [kg/m3|g/cm3]", 1.204114944782858, 0.0,\
1E+100,0.0,0,2561)
DeclareVariable("building.thermalZoneOneElement.volAir.state_start.p", \
"Absolute pressure of medium [Pa|bar]", 100000.0, 0.0,100000000.0,100000.0,0,2561)
DeclareVariable("building.thermalZoneOneElement.volAir.state_start.T", \
"Temperature of medium [K|degC]", 288.15, 273.15,373.15,300.0,0,2561)
DeclareVariable("building.thermalZoneOneElement.volAir.useSteadyStateTwoPort", \
"Flag, true if the model has two ports only and uses a steady state balance [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,2563)
DeclareVariable("building.thermalZoneOneElement.volAir.hOut_internal", \
"Internal connector for leaving temperature of the component [J/kg]", 0.0, \
0.0,0.0,0.0,0,2560)
DeclareAlias2("building.thermalZoneOneElement.volAir.preTem.port.T", \
"Port temperature [K|degC]", "building.heaPorCoo[1].T", 1, 5, 188, 1028)
DeclareAlias2("building.thermalZoneOneElement.volAir.preTem.port.Q_flow", \
"Heat flow rate (positive if flowing from outside into the component) [W]", \
"building.thermalZoneOneElement.volAir.dynBal.der(U)", 1, 6, 13, 1156)
DeclareAlias2("building.thermalZoneOneElement.volAir.preTem.T", "", \
"building.heaPorCoo[1].T", 1, 5, 188, 1024)
DeclareAlias2("building.thermalZoneOneElement.volAir.portT.y", "Value of Real output",\
 "building.heaPorCoo[1].T", 1, 5, 188, 1024)
DeclareAlias2("building.thermalZoneOneElement.volAir.heaFloSen.Q_flow", \
"Heat flow from port_a to port_b as output signal [W]", "building.thermalZoneOneElement.volAir.dynBal.der(U)", 1,\
 6, 13, 1024)
DeclareAlias2("building.thermalZoneOneElement.volAir.heaFloSen.port_a.T", \
"Port temperature [K|degC]", "building.heaPorCoo[1].T", 1, 5, 188, 1028)
DeclareAlias2("building.thermalZoneOneElement.volAir.heaFloSen.port_a.Q_flow", \
"Heat flow rate (positive if flowing from outside into the component) [W]", \
"building.thermalZoneOneElement.volAir.dynBal.der(U)", 1, 6, 13, 1156)
DeclareAlias2("building.thermalZoneOneElement.volAir.heaFloSen.port_b.T", \
"Port temperature [K|degC]", "building.heaPorCoo[1].T", 1, 5, 188, 1028)
DeclareAlias2("building.thermalZoneOneElement.volAir.heaFloSen.port_b.Q_flow", \
"Heat flow rate (positive if flowing from outside into the component) [W]", \
"building.thermalZoneOneElement.volAir.dynBal.der(U)", -1, 6, 13, 1156)
DeclareVariable("building.thermalZoneOneElement.volAir.use_C_flow", \
"Set to true to enable input connector for trace substance [:#(type=Boolean)]", \
false, 0.0,0.0,0.0,0,515)
DeclareAlias2("building.thermalZoneOneElement.volAir.heatPort.T", \
"Port temperature [K|degC]", "building.heaPorCoo[1].T", 1, 5, 188, 4)
DeclareAlias2("building.thermalZoneOneElement.volAir.heatPort.Q_flow", \
"Heat flow rate (positive if flowing from outside into the component) [W]", \
"building.thermalZoneOneElement.volAir.dynBal.der(U)", 1, 6, 13, 132)
DeclareVariable("building.thermalZoneOneElement.h_fg", "Latent heat of water vapor [J/kg]",\
 2569834.5, 0.0,0.0,0.0,0,2561)
DeclareVariable("building.thermalZoneOneElement.ATot", "Sum of wall surface areas [m2]",\
 25.5, 0.0,0.0,0.0,0,2561)
DeclareVariable("building.thermalZoneOneElement.ATotExt", "Sum of exterior wall surface areas [m2]",\
 11.5, 0.0,0.0,0.0,0,2561)
DeclareVariable("building.thermalZoneOneElement.ATotWin", "Sum of window surface areas [m2]",\
 14, 0.0,0.0,0.0,0,2561)
DeclareVariable("building.thermalZoneOneElement.AArray[1]", "List of all wall surface areas [m2]",\
 11.5, 0.0,0.0,0.0,0,2561)
DeclareVariable("building.thermalZoneOneElement.AArray[2]", "List of all wall surface areas [m2]",\
 14.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("building.thermalZoneOneElement.dimension", "Number of non-zero wall surface areas [:#(type=Integer)]",\
 2, 0.0,0.0,0.0,0,2565)
DeclareVariable("building.thermalZoneOneElement.splitFactor[1, 1]", \
"Share of each wall surface area that is non-zero", 0.45098039215686275, \
0.0,0.0,0.0,0,2561)
DeclareVariable("building.thermalZoneOneElement.splitFactor[2, 1]", \
"Share of each wall surface area that is non-zero", 0.5490196078431373, 0.0,0.0,\
0.0,0,2561)
DeclareVariable("building.thermalZoneOneElement.splitFactorSolRad[1, 1]", \
"Share of each wall surface area that is non-zero, for each orientation separately",\
 0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("building.thermalZoneOneElement.splitFactorSolRad[1, 2]", \
"Share of each wall surface area that is non-zero, for each orientation separately",\
 0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("building.thermalZoneOneElement.splitFactorSolRad[2, 1]", \
"Share of each wall surface area that is non-zero, for each orientation separately",\
 0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("building.thermalZoneOneElement.splitFactorSolRad[2, 2]", \
"Share of each wall surface area that is non-zero, for each orientation separately",\
 0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("building.thermalZoneOneElement.convExtWall.Q_flow", \
"Heat flow rate from solid -> fluid [W]", 0.0, 0.0,0.0,0.0,0,2560)
DeclareVariable("building.thermalZoneOneElement.convExtWall.dT", \
"= solid.T - fluid.T [K,]", 0, 0.0,0.0,0.0,0,2560)
DeclareAlias2("building.thermalZoneOneElement.convExtWall.Gc", "Signal representing the convective thermal conductance in [W/K] [W/K]",\
 "building.thermalZoneOneElement.hConExtWall_const.k", 1, 5, 464, 1024)
DeclareVariable("building.thermalZoneOneElement.convExtWall.solid.T", \
"Port temperature [K|degC]", 288.15, 0.0,1E+100,300.0,0,2568)
DeclareAlias2("building.thermalZoneOneElement.convExtWall.solid.Q_flow", \
"Heat flow rate (positive if flowing from outside into the component) [W]", \
"building.thermalZoneOneElement.convExtWall.Q_flow", 1, 5, 461, 1156)
DeclareAlias2("building.thermalZoneOneElement.convExtWall.fluid.T", \
"Port temperature [K|degC]", "building.heaPorCoo[1].T", 1, 5, 188, 1028)
DeclareAlias2("building.thermalZoneOneElement.convExtWall.fluid.Q_flow", \
"Heat flow rate (positive if flowing from outside into the component) [W]", \
"building.thermalZoneOneElement.convExtWall.Q_flow", -1, 5, 461, 1156)
DeclareVariable("building.thermalZoneOneElement.hConExtWall_const.k", \
"Constant output value", 1, 0.0,0.0,0.0,0,2561)
DeclareAlias2("building.thermalZoneOneElement.hConExtWall_const.y", \
"Connector of Real output signal", "building.thermalZoneOneElement.hConExtWall_const.k", 1,\
 5, 464, 1024)
DeclareVariable("building.thermalZoneOneElement.convWin.Q_flow", \
"Heat flow rate from solid -> fluid [W]", 0.0, 0.0,0.0,0.0,0,2560)
DeclareVariable("building.thermalZoneOneElement.convWin.dT", "= solid.T - fluid.T [K,]",\
 0.0, 0.0,0.0,0.0,0,2560)
DeclareAlias2("building.thermalZoneOneElement.convWin.Gc", "Signal representing the convective thermal conductance in [W/K] [W/K]",\
 "building.thermalZoneOneElement.hConWin_const.k", 1, 5, 468, 1024)
DeclareVariable("building.thermalZoneOneElement.convWin.solid.T", \
"Port temperature [K|degC]", 288.15, 0.0,1E+100,300.0,0,2568)
DeclareAlias2("building.thermalZoneOneElement.convWin.solid.Q_flow", \
"Heat flow rate (positive if flowing from outside into the component) [W]", \
"building.thermalZoneOneElement.convWin.Q_flow", 1, 5, 465, 1156)
DeclareAlias2("building.thermalZoneOneElement.convWin.fluid.T", "Port temperature [K|degC]",\
 "building.heaPorCoo[1].T", 1, 5, 188, 1028)
DeclareAlias2("building.thermalZoneOneElement.convWin.fluid.Q_flow", \
"Heat flow rate (positive if flowing from outside into the component) [W]", \
"building.thermalZoneOneElement.convWin.Q_flow", -1, 5, 465, 1156)
DeclareVariable("building.thermalZoneOneElement.hConWin_const.k", \
"Constant output value", 1, 0.0,0.0,0.0,0,2561)
DeclareAlias2("building.thermalZoneOneElement.hConWin_const.y", "Connector of Real output signal",\
 "building.thermalZoneOneElement.hConWin_const.k", 1, 5, 468, 1024)
DeclareVariable("building.thermalZoneOneElement.eRadSol[1].k", "Gain value multiplied with input signal [1]",\
 1, 0.0,0.0,0.0,0,2561)
DeclareAlias2("building.thermalZoneOneElement.eRadSol[1].u", "Input signal connector",\
 "building.corGDouPan.solarRadWinTrans[1]", 1, 5, 363, 1024)
DeclareAlias2("building.thermalZoneOneElement.eRadSol[1].y", "Output signal connector",\
 "building.thermalZoneOneElement.thermSplitterSolRad.portIn[1].Q_flow", 1, 5, 1404,\
 1024)
DeclareVariable("building.thermalZoneOneElement.eRadSol[2].k", "Gain value multiplied with input signal [1]",\
 1, 0.0,0.0,0.0,0,2561)
DeclareAlias2("building.thermalZoneOneElement.eRadSol[2].u", "Input signal connector",\
 "building.corGDouPan.solarRadWinTrans[2]", 1, 5, 364, 1024)
DeclareAlias2("building.thermalZoneOneElement.eRadSol[2].y", "Output signal connector",\
 "building.thermalZoneOneElement.thermSplitterSolRad.portIn[2].Q_flow", 1, 5, 1406,\
 1024)
DeclareVariable("building.thermalZoneOneElement.eConvSol[1].k", "Gain value multiplied with input signal [1]",\
 1, 0.0,0.0,0.0,0,2561)
DeclareAlias2("building.thermalZoneOneElement.eConvSol[1].u", "Input signal connector",\
 "building.corGDouPan.solarRadWinTrans[1]", 1, 5, 363, 1024)
DeclareAlias2("building.thermalZoneOneElement.eConvSol[1].y", "Output signal connector",\
 "building.thermalZoneOneElement.sumSolRad.u[1]", 1, 5, 479, 1024)
DeclareVariable("building.thermalZoneOneElement.eConvSol[2].k", "Gain value multiplied with input signal [1]",\
 1, 0.0,0.0,0.0,0,2561)
DeclareAlias2("building.thermalZoneOneElement.eConvSol[2].u", "Input signal connector",\
 "building.corGDouPan.solarRadWinTrans[2]", 1, 5, 364, 1024)
DeclareAlias2("building.thermalZoneOneElement.eConvSol[2].y", "Output signal connector",\
 "building.thermalZoneOneElement.sumSolRad.u[2]", 1, 5, 480, 1024)
DeclareVariable("building.thermalZoneOneElement.resExtWallWin.Q_flow", \
"Heat flow rate from port_a -> port_b [W]", 0.0, 0.0,0.0,0.0,0,2560)
DeclareVariable("building.thermalZoneOneElement.resExtWallWin.dT", \
"port_a.T - port_b.T [K,]", 0.0, 0.0,0.0,0.0,0,2560)
DeclareAlias2("building.thermalZoneOneElement.resExtWallWin.port_a.T", \
"Port temperature [K|degC]", "building.thermalZoneOneElement.convWin.solid.T", 1,\
 5, 467, 1028)
DeclareAlias2("building.thermalZoneOneElement.resExtWallWin.port_a.Q_flow", \
"Heat flow rate (positive if flowing from outside into the component) [W]", \
"building.thermalZoneOneElement.resExtWallWin.Q_flow", 1, 5, 473, 1156)
DeclareAlias2("building.thermalZoneOneElement.resExtWallWin.port_b.T", \
"Port temperature [K|degC]", "building.thermalZoneOneElement.convExtWall.solid.T", 1,\
 5, 463, 1028)
DeclareAlias2("building.thermalZoneOneElement.resExtWallWin.port_b.Q_flow", \
"Heat flow rate (positive if flowing from outside into the component) [W]", \
"building.thermalZoneOneElement.resExtWallWin.Q_flow", -1, 5, 473, 1156)
DeclareVariable("building.thermalZoneOneElement.resExtWallWin.G", \
"Constant thermal conductance of material [W/K]", 0.0, 0.0,0.0,0.0,0,2561)
DeclareAlias2("building.thermalZoneOneElement.senTAir.T", "Absolute temperature as output signal [K]",\
 "building.heaPorCoo[1].T", 1, 5, 188, 1024)
DeclareAlias2("building.thermalZoneOneElement.senTAir.port.T", "Port temperature [K|degC]",\
 "building.heaPorCoo[1].T", 1, 5, 188, 1028)
DeclareVariable("building.thermalZoneOneElement.senTAir.port.Q_flow", \
"Heat flow rate (positive if flowing from outside into the component) [W]", 0, \
0.0,0.0,0.0,0,2825)
DeclareAlias2("building.thermalZoneOneElement.senTRad.T", "Absolute temperature as output signal [K]",\
 "building.perRad.port.T", 1, 5, 503, 1024)
DeclareAlias2("building.thermalZoneOneElement.senTRad.port.T", "Port temperature [K|degC]",\
 "building.perRad.port.T", 1, 5, 503, 1028)
DeclareVariable("building.thermalZoneOneElement.senTRad.port.Q_flow", \
"Heat flow rate (positive if flowing from outside into the component) [W]", 0, \
0.0,0.0,0.0,0,2825)
DeclareVariable("building.thermalZoneOneElement.sumSolRad.nin", "Number of inputs [:#(type=Integer)]",\
 2, 0.0,0.0,0.0,0,2565)
DeclareVariable("building.thermalZoneOneElement.sumSolRad.u[1]", \
"Connector of Real input signals", 0.0, 0.0,0.0,0.0,0,2560)
DeclareVariable("building.thermalZoneOneElement.sumSolRad.u[2]", \
"Connector of Real input signals", 0.0, 0.0,0.0,0.0,0,2560)
DeclareVariable("building.thermalZoneOneElement.sumSolRad.y", "Connector of Real output signal",\
 0.0, 0.0,0.0,0.0,0,2560)
DeclareParameter("building.thermalZoneOneElement.sumSolRad.k[1]", \
"Optional: sum coefficients", 69, 1, 0.0,0.0,0.0,0,2608)
DeclareParameter("building.thermalZoneOneElement.sumSolRad.k[2]", \
"Optional: sum coefficients", 70, 1, 0.0,0.0,0.0,0,2608)
DeclareParameter("building.eqAirTemp.aExt", "Coefficient of absorption of exterior walls (outdoor) [1]",\
 71, 0.7, 0.0,0.0,0.0,0,560)
DeclareVariable("building.eqAirTemp.n", "Number of orientations (without ground) [:#(type=Integer)]",\
 2, 0.0,0.0,0.0,0,517)
DeclareParameter("building.eqAirTemp.wfWall[1]", "Weight factors of the walls [1]",\
 72, 0.3043478260869566, 0.0,0.0,0.0,0,560)
DeclareParameter("building.eqAirTemp.wfWall[2]", "Weight factors of the walls [1]",\
 73, 0.6956521739130435, 0.0,0.0,0.0,0,560)
DeclareParameter("building.eqAirTemp.wfWin[1]", "Weight factors of the windows [1]",\
 74, 0.5, 0.0,0.0,0.0,0,560)
DeclareParameter("building.eqAirTemp.wfWin[2]", "Weight factors of the windows [1]",\
 75, 0.5, 0.0,0.0,0.0,0,560)
DeclareParameter("building.eqAirTemp.wfGro", "Weight factor of the ground (0 if not considered) [1]",\
 76, 0, 0.0,0.0,0.0,0,560)
DeclareParameter("building.eqAirTemp.TGro", "Temperature of the ground in contact with floor plate [K|degC]",\
 77, 285.15, 0.0,1E+100,300.0,0,560)
DeclareParameter("building.eqAirTemp.hConWallOut", "Exterior walls convective coefficient of heat transfer (outdoor) [W/(m2.K)]",\
 78, 20, 0.0,0.0,0.0,0,560)
DeclareParameter("building.eqAirTemp.hRad", "Coefficient of heat transfer for linearized radiation [W/(m2.K)]",\
 79, 5, 0.0,0.0,0.0,0,560)
DeclareVariable("building.eqAirTemp.withLongwave", "Set to true to include longwave radiation exchange [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,515)
DeclareVariable("building.eqAirTemp.TEqWall[1]", "Equivalent wall temperature [K|degC]",\
 288.15, 0.0,1E+100,300.0,0,512)
DeclareVariable("building.eqAirTemp.TEqWall[2]", "Equivalent wall temperature [K|degC]",\
 288.15, 0.0,1E+100,300.0,0,512)
DeclareVariable("building.eqAirTemp.TEqWin[1]", "Equivalent window temperature [K|degC]",\
 288.15, 0.0,1E+100,300.0,0,512)
DeclareVariable("building.eqAirTemp.TEqWin[2]", "Equivalent window temperature [K|degC]",\
 288.15, 0.0,1E+100,300.0,0,512)
DeclareVariable("building.eqAirTemp.delTEqLW", "Equivalent long wave temperature [K,]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("building.eqAirTemp.delTEqLWWin", "Equivalent long wave temperature for windows [K,]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("building.eqAirTemp.delTEqSW[1]", "Equivalent short wave temperature [K,]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("building.eqAirTemp.delTEqSW[2]", "Equivalent short wave temperature [K,]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("building.eqAirTemp.HSol[1]", "Solar radiation per unit area [W/m2]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("building.eqAirTemp.HSol[2]", "Solar radiation per unit area [W/m2]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("building.eqAirTemp.TBlaSky", "Black-body sky temperature [K|degC]",\
 "weaDat.TBlaSky_in_internal", 1, 5, 144, 0)
DeclareAlias2("building.eqAirTemp.TDryBul", "Dry bulb temperature [K|degC]", \
"weaDat.TDryBul_in_internal", 1, 5, 142, 0)
DeclareVariable("building.eqAirTemp.TEqAir", "Equivalent air temperature [K|degC]",\
 288.15, 0.0,1E+100,300.0,0,512)
DeclareAlias2("building.eqAirTemp.sunblind[1]", "Opening factor of sunblinds for each direction (0 - open to 1 - closed) [1]",\
 "building.const[1].k", 1, 7, 200, 0)
DeclareAlias2("building.eqAirTemp.sunblind[2]", "Opening factor of sunblinds for each direction (0 - open to 1 - closed) [1]",\
 "building.const[2].k", 1, 7, 201, 0)
DeclareParameter("building.eqAirTemp.hConWinOut", "Windows' convective coefficient of heat transfer (outdoor) [W/(m2.K)]",\
 80, 20, 0.0,0.0,0.0,0,560)
DeclareVariable("building.eqAirTemp.TEqAirWin", "Equivalent air temperature for windows (no short-wave radiation) [K]",\
 288.15, 0.0,1E+100,300.0,0,512)
DeclareAlias2("building.solRad[1].u1", "Connector of Real input signal 1", \
"building.corGDouPan.HDirTil[1]", 1, 5, 357, 0)
DeclareAlias2("building.solRad[1].u2", "Connector of Real input signal 2", \
"building.HDifTil[1].H", 1, 5, 206, 0)
DeclareAlias2("building.solRad[1].y", "Connector of Real output signal", \
"building.eqAirTemp.HSol[1]", 1, 5, 492, 0)
DeclareParameter("building.solRad[1].k1", "Gain of upper input", 81, 1, 0.0,0.0,\
0.0,0,560)
DeclareParameter("building.solRad[1].k2", "Gain of lower input", 82, 1, 0.0,0.0,\
0.0,0,560)
DeclareAlias2("building.solRad[2].u1", "Connector of Real input signal 1", \
"building.corGDouPan.HDirTil[2]", 1, 5, 358, 0)
DeclareAlias2("building.solRad[2].u2", "Connector of Real input signal 2", \
"building.HDifTil[2].H", 1, 5, 264, 0)
DeclareAlias2("building.solRad[2].y", "Connector of Real output signal", \
"building.eqAirTemp.HSol[2]", 1, 5, 493, 0)
DeclareParameter("building.solRad[2].k1", "Gain of upper input", 83, 1, 0.0,0.0,\
0.0,0,560)
DeclareParameter("building.solRad[2].k2", "Gain of lower input", 84, 1, 0.0,0.0,\
0.0,0,560)
DeclareAlias2("building.preTem.port.T", "Port temperature [K|degC]", \
"building.eqAirTemp.TEqAir", 1, 5, 494, 4)
DeclareVariable("building.preTem.port.Q_flow", "Heat flow rate (positive if flowing from outside into the component) [W]",\
 0.0, 0.0,0.0,0.0,0,776)
DeclareAlias2("building.preTem.T", "", "building.eqAirTemp.TEqAir", 1, 5, 494, 0)
DeclareAlias2("building.preTem1.port.T", "Port temperature [K|degC]", \
"building.eqAirTemp.TEqAirWin", 1, 5, 495, 4)
DeclareVariable("building.preTem1.port.Q_flow", "Heat flow rate (positive if flowing from outside into the component) [W]",\
 0.0, 0.0,0.0,0.0,0,776)
DeclareAlias2("building.preTem1.T", "", "building.eqAirTemp.TEqAirWin", 1, 5, 495,\
 0)
DeclareAlias2("building.theConWin.Q_flow", "Heat flow rate from solid -> fluid [W]",\
 "building.preTem1.port.Q_flow", 1, 5, 497, 0)
DeclareVariable("building.theConWin.dT", "= solid.T - fluid.T [K,]", 0.0, \
0.0,0.0,0.0,0,512)
DeclareAlias2("building.theConWin.Gc", "Signal representing the convective thermal conductance in [W/K] [W/K]",\
 "building.hConWin_Const.k", 1, 7, 242, 0)
DeclareVariable("building.theConWin.solid.T", "Port temperature [K|degC]", \
288.15, 0.0,1E+100,300.0,0,520)
DeclareAlias2("building.theConWin.solid.Q_flow", "Heat flow rate (positive if flowing from outside into the component) [W]",\
 "building.preTem1.port.Q_flow", 1, 5, 497, 132)
DeclareAlias2("building.theConWin.fluid.T", "Port temperature [K|degC]", \
"building.eqAirTemp.TEqAirWin", 1, 5, 495, 4)
DeclareAlias2("building.theConWin.fluid.Q_flow", "Heat flow rate (positive if flowing from outside into the component) [W]",\
 "building.preTem1.port.Q_flow", -1, 5, 497, 132)
DeclareAlias2("building.theConWall.Q_flow", "Heat flow rate from solid -> fluid [W]",\
 "building.preTem.port.Q_flow", 1, 5, 496, 0)
DeclareVariable("building.theConWall.dT", "= solid.T - fluid.T [K,]", 0.0, \
0.0,0.0,0.0,0,512)
DeclareAlias2("building.theConWall.Gc", "Signal representing the convective thermal conductance in [W/K] [W/K]",\
 "building.alphaWall.k", 1, 7, 204, 0)
DeclareVariable("building.theConWall.solid.T", "Port temperature [K|degC]", \
288.15, 0.0,1E+100,300.0,0,520)
DeclareAlias2("building.theConWall.solid.Q_flow", "Heat flow rate (positive if flowing from outside into the component) [W]",\
 "building.preTem.port.Q_flow", 1, 5, 496, 132)
DeclareAlias2("building.theConWall.fluid.T", "Port temperature [K|degC]", \
"building.eqAirTemp.TEqAir", 1, 5, 494, 4)
DeclareAlias2("building.theConWall.fluid.Q_flow", "Heat flow rate (positive if flowing from outside into the component) [W]",\
 "building.preTem.port.Q_flow", -1, 5, 496, 132)
DeclareParameter("building.perRad.T_ref", "Reference temperature [K|degC]", 85, \
293.15, 0.0,1E+100,300.0,0,560)
DeclareParameter("building.perRad.alpha", "Temperature coefficient of heat flow rate [1/K]",\
 86, 0, 0.0,0.0,0.0,0,560)
DeclareVariable("building.perRad.Q_flow", "[W]", 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("building.perRad.port.T", "Port temperature [K|degC]", 288.15, \
0.0,1E+100,300.0,0,520)
DeclareVariable("building.perRad.port.Q_flow", "Heat flow rate (positive if flowing from outside into the component) [W]",\
 0.0, 0.0,0.0,0.0,0,776)
DeclareParameter("building.perCon.T_ref", "Reference temperature [K|degC]", 87, \
293.15, 0.0,1E+100,300.0,0,560)
DeclareParameter("building.perCon.alpha", "Temperature coefficient of heat flow rate [1/K]",\
 88, 0, 0.0,0.0,0.0,0,560)
DeclareVariable("building.perCon.Q_flow", "[W]", 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("building.perCon.port.T", "Port temperature [K|degC]", \
"building.heaPorCoo[1].T", 1, 5, 188, 4)
DeclareVariable("building.perCon.port.Q_flow", "Heat flow rate (positive if flowing from outside into the component) [W]",\
 0.0, 0.0,0.0,0.0,0,776)
DeclareVariable("building.intGai.nout", "Number of outputs [:#(type=Integer)]", 3,\
 1.0,1E+100,0.0,0,517)
DeclareAlias2("building.intGai.y[1]", "Connector of Real output signals", \
"building.perRad.Q_flow", 1, 5, 502, 0)
DeclareAlias2("building.intGai.y[2]", "Connector of Real output signals", \
"building.perCon.Q_flow", 1, 5, 505, 0)
DeclareVariable("building.intGai.y[3]", "Connector of Real output signals", 0.0,\
 0.0,0.0,0.0,0,512)
DeclareVariable("building.intGai.tableOnFile", "= true, if table is defined on file or in function usertab [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,515)
DeclareParameter("building.intGai.table[1, 1]", "Table matrix (time = first column; e.g., table=[0,2])",\
 89, 0, 0.0,0.0,0.0,0,560)
DeclareParameter("building.intGai.table[1, 2]", "Table matrix (time = first column; e.g., table=[0,2])",\
 90, 0, 0.0,0.0,0.0,0,560)
DeclareParameter("building.intGai.table[1, 3]", "Table matrix (time = first column; e.g., table=[0,2])",\
 91, 0, 0.0,0.0,0.0,0,560)
DeclareParameter("building.intGai.table[1, 4]", "Table matrix (time = first column; e.g., table=[0,2])",\
 92, 0, 0.0,0.0,0.0,0,560)
DeclareParameter("building.intGai.table[2, 1]", "Table matrix (time = first column; e.g., table=[0,2])",\
 93, 3600, 0.0,0.0,0.0,0,560)
DeclareParameter("building.intGai.table[2, 2]", "Table matrix (time = first column; e.g., table=[0,2])",\
 94, 0, 0.0,0.0,0.0,0,560)
DeclareParameter("building.intGai.table[2, 3]", "Table matrix (time = first column; e.g., table=[0,2])",\
 95, 0, 0.0,0.0,0.0,0,560)
DeclareParameter("building.intGai.table[2, 4]", "Table matrix (time = first column; e.g., table=[0,2])",\
 96, 0, 0.0,0.0,0.0,0,560)
DeclareParameter("building.intGai.table[3, 1]", "Table matrix (time = first column; e.g., table=[0,2])",\
 97, 7200, 0.0,0.0,0.0,0,560)
DeclareParameter("building.intGai.table[3, 2]", "Table matrix (time = first column; e.g., table=[0,2])",\
 98, 0, 0.0,0.0,0.0,0,560)
DeclareParameter("building.intGai.table[3, 3]", "Table matrix (time = first column; e.g., table=[0,2])",\
 99, 0, 0.0,0.0,0.0,0,560)
DeclareParameter("building.intGai.table[3, 4]", "Table matrix (time = first column; e.g., table=[0,2])",\
 100, 0, 0.0,0.0,0.0,0,560)
DeclareParameter("building.intGai.table[4, 1]", "Table matrix (time = first column; e.g., table=[0,2])",\
 101, 10800, 0.0,0.0,0.0,0,560)
DeclareParameter("building.intGai.table[4, 2]", "Table matrix (time = first column; e.g., table=[0,2])",\
 102, 0, 0.0,0.0,0.0,0,560)
DeclareParameter("building.intGai.table[4, 3]", "Table matrix (time = first column; e.g., table=[0,2])",\
 103, 0, 0.0,0.0,0.0,0,560)
DeclareParameter("building.intGai.table[4, 4]", "Table matrix (time = first column; e.g., table=[0,2])",\
 104, 0, 0.0,0.0,0.0,0,560)
DeclareParameter("building.intGai.table[5, 1]", "Table matrix (time = first column; e.g., table=[0,2])",\
 105, 14400, 0.0,0.0,0.0,0,560)
DeclareParameter("building.intGai.table[5, 2]", "Table matrix (time = first column; e.g., table=[0,2])",\
 106, 0, 0.0,0.0,0.0,0,560)
DeclareParameter("building.intGai.table[5, 3]", "Table matrix (time = first column; e.g., table=[0,2])",\
 107, 0, 0.0,0.0,0.0,0,560)
DeclareParameter("building.intGai.table[5, 4]", "Table matrix (time = first column; e.g., table=[0,2])",\
 108, 0, 0.0,0.0,0.0,0,560)
DeclareParameter("building.intGai.table[6, 1]", "Table matrix (time = first column; e.g., table=[0,2])",\
 109, 18000, 0.0,0.0,0.0,0,560)
DeclareParameter("building.intGai.table[6, 2]", "Table matrix (time = first column; e.g., table=[0,2])",\
 110, 0, 0.0,0.0,0.0,0,560)
DeclareParameter("building.intGai.table[6, 3]", "Table matrix (time = first column; e.g., table=[0,2])",\
 111, 0, 0.0,0.0,0.0,0,560)
DeclareParameter("building.intGai.table[6, 4]", "Table matrix (time = first column; e.g., table=[0,2])",\
 112, 0, 0.0,0.0,0.0,0,560)
DeclareParameter("building.intGai.table[7, 1]", "Table matrix (time = first column; e.g., table=[0,2])",\
 113, 21600, 0.0,0.0,0.0,0,560)
DeclareParameter("building.intGai.table[7, 2]", "Table matrix (time = first column; e.g., table=[0,2])",\
 114, 0, 0.0,0.0,0.0,0,560)
DeclareParameter("building.intGai.table[7, 3]", "Table matrix (time = first column; e.g., table=[0,2])",\
 115, 0, 0.0,0.0,0.0,0,560)
DeclareParameter("building.intGai.table[7, 4]", "Table matrix (time = first column; e.g., table=[0,2])",\
 116, 0, 0.0,0.0,0.0,0,560)
DeclareParameter("building.intGai.table[8, 1]", "Table matrix (time = first column; e.g., table=[0,2])",\
 117, 25200, 0.0,0.0,0.0,0,560)
DeclareParameter("building.intGai.table[8, 2]", "Table matrix (time = first column; e.g., table=[0,2])",\
 118, 0, 0.0,0.0,0.0,0,560)
DeclareParameter("building.intGai.table[8, 3]", "Table matrix (time = first column; e.g., table=[0,2])",\
 119, 0, 0.0,0.0,0.0,0,560)
DeclareParameter("building.intGai.table[8, 4]", "Table matrix (time = first column; e.g., table=[0,2])",\
 120, 0, 0.0,0.0,0.0,0,560)
DeclareParameter("building.intGai.table[9, 1]", "Table matrix (time = first column; e.g., table=[0,2])",\
 121, 25200, 0.0,0.0,0.0,0,560)
DeclareParameter("building.intGai.table[9, 2]", "Table matrix (time = first column; e.g., table=[0,2])",\
 122, 80, 0.0,0.0,0.0,0,560)
DeclareParameter("building.intGai.table[9, 3]", "Table matrix (time = first column; e.g., table=[0,2])",\
 123, 80, 0.0,0.0,0.0,0,560)
DeclareParameter("building.intGai.table[9, 4]", "Table matrix (time = first column; e.g., table=[0,2])",\
 124, 200, 0.0,0.0,0.0,0,560)
DeclareParameter("building.intGai.table[10, 1]", "Table matrix (time = first column; e.g., table=[0,2])",\
 125, 28800, 0.0,0.0,0.0,0,560)
DeclareParameter("building.intGai.table[10, 2]", "Table matrix (time = first column; e.g., table=[0,2])",\
 126, 80, 0.0,0.0,0.0,0,560)
DeclareParameter("building.intGai.table[10, 3]", "Table matrix (time = first column; e.g., table=[0,2])",\
 127, 80, 0.0,0.0,0.0,0,560)
DeclareParameter("building.intGai.table[10, 4]", "Table matrix (time = first column; e.g., table=[0,2])",\
 128, 200, 0.0,0.0,0.0,0,560)
DeclareParameter("building.intGai.table[11, 1]", "Table matrix (time = first column; e.g., table=[0,2])",\
 129, 32400, 0.0,0.0,0.0,0,560)
DeclareParameter("building.intGai.table[11, 2]", "Table matrix (time = first column; e.g., table=[0,2])",\
 130, 80, 0.0,0.0,0.0,0,560)
DeclareParameter("building.intGai.table[11, 3]", "Table matrix (time = first column; e.g., table=[0,2])",\
 131, 80, 0.0,0.0,0.0,0,560)
DeclareParameter("building.intGai.table[11, 4]", "Table matrix (time = first column; e.g., table=[0,2])",\
 132, 200, 0.0,0.0,0.0,0,560)
DeclareParameter("building.intGai.table[12, 1]", "Table matrix (time = first column; e.g., table=[0,2])",\
 133, 36000, 0.0,0.0,0.0,0,560)
DeclareParameter("building.intGai.table[12, 2]", "Table matrix (time = first column; e.g., table=[0,2])",\
 134, 80, 0.0,0.0,0.0,0,560)
DeclareParameter("building.intGai.table[12, 3]", "Table matrix (time = first column; e.g., table=[0,2])",\
 135, 80, 0.0,0.0,0.0,0,560)
DeclareParameter("building.intGai.table[12, 4]", "Table matrix (time = first column; e.g., table=[0,2])",\
 136, 200, 0.0,0.0,0.0,0,560)
DeclareParameter("building.intGai.table[13, 1]", "Table matrix (time = first column; e.g., table=[0,2])",\
 137, 39600, 0.0,0.0,0.0,0,560)
DeclareParameter("building.intGai.table[13, 2]", "Table matrix (time = first column; e.g., table=[0,2])",\
 138, 80, 0.0,0.0,0.0,0,560)
DeclareParameter("building.intGai.table[13, 3]", "Table matrix (time = first column; e.g., table=[0,2])",\
 139, 80, 0.0,0.0,0.0,0,560)
DeclareParameter("building.intGai.table[13, 4]", "Table matrix (time = first column; e.g., table=[0,2])",\
 140, 200, 0.0,0.0,0.0,0,560)
DeclareParameter("building.intGai.table[14, 1]", "Table matrix (time = first column; e.g., table=[0,2])",\
 141, 43200, 0.0,0.0,0.0,0,560)
DeclareParameter("building.intGai.table[14, 2]", "Table matrix (time = first column; e.g., table=[0,2])",\
 142, 80, 0.0,0.0,0.0,0,560)
DeclareParameter("building.intGai.table[14, 3]", "Table matrix (time = first column; e.g., table=[0,2])",\
 143, 80, 0.0,0.0,0.0,0,560)
DeclareParameter("building.intGai.table[14, 4]", "Table matrix (time = first column; e.g., table=[0,2])",\
 144, 200, 0.0,0.0,0.0,0,560)
DeclareParameter("building.intGai.table[15, 1]", "Table matrix (time = first column; e.g., table=[0,2])",\
 145, 46800, 0.0,0.0,0.0,0,560)
DeclareParameter("building.intGai.table[15, 2]", "Table matrix (time = first column; e.g., table=[0,2])",\
 146, 80, 0.0,0.0,0.0,0,560)
DeclareParameter("building.intGai.table[15, 3]", "Table matrix (time = first column; e.g., table=[0,2])",\
 147, 80, 0.0,0.0,0.0,0,560)
DeclareParameter("building.intGai.table[15, 4]", "Table matrix (time = first column; e.g., table=[0,2])",\
 148, 200, 0.0,0.0,0.0,0,560)
DeclareParameter("building.intGai.table[16, 1]", "Table matrix (time = first column; e.g., table=[0,2])",\
 149, 50400, 0.0,0.0,0.0,0,560)
DeclareParameter("building.intGai.table[16, 2]", "Table matrix (time = first column; e.g., table=[0,2])",\
 150, 80, 0.0,0.0,0.0,0,560)
DeclareParameter("building.intGai.table[16, 3]", "Table matrix (time = first column; e.g., table=[0,2])",\
 151, 80, 0.0,0.0,0.0,0,560)
DeclareParameter("building.intGai.table[16, 4]", "Table matrix (time = first column; e.g., table=[0,2])",\
 152, 200, 0.0,0.0,0.0,0,560)
DeclareParameter("building.intGai.table[17, 1]", "Table matrix (time = first column; e.g., table=[0,2])",\
 153, 54000, 0.0,0.0,0.0,0,560)
DeclareParameter("building.intGai.table[17, 2]", "Table matrix (time = first column; e.g., table=[0,2])",\
 154, 80, 0.0,0.0,0.0,0,560)
DeclareParameter("building.intGai.table[17, 3]", "Table matrix (time = first column; e.g., table=[0,2])",\
 155, 80, 0.0,0.0,0.0,0,560)
DeclareParameter("building.intGai.table[17, 4]", "Table matrix (time = first column; e.g., table=[0,2])",\
 156, 200, 0.0,0.0,0.0,0,560)
DeclareParameter("building.intGai.table[18, 1]", "Table matrix (time = first column; e.g., table=[0,2])",\
 157, 57600, 0.0,0.0,0.0,0,560)
DeclareParameter("building.intGai.table[18, 2]", "Table matrix (time = first column; e.g., table=[0,2])",\
 158, 80, 0.0,0.0,0.0,0,560)
DeclareParameter("building.intGai.table[18, 3]", "Table matrix (time = first column; e.g., table=[0,2])",\
 159, 80, 0.0,0.0,0.0,0,560)
DeclareParameter("building.intGai.table[18, 4]", "Table matrix (time = first column; e.g., table=[0,2])",\
 160, 200, 0.0,0.0,0.0,0,560)
DeclareParameter("building.intGai.table[19, 1]", "Table matrix (time = first column; e.g., table=[0,2])",\
 161, 61200, 0.0,0.0,0.0,0,560)
DeclareParameter("building.intGai.table[19, 2]", "Table matrix (time = first column; e.g., table=[0,2])",\
 162, 80, 0.0,0.0,0.0,0,560)
DeclareParameter("building.intGai.table[19, 3]", "Table matrix (time = first column; e.g., table=[0,2])",\
 163, 80, 0.0,0.0,0.0,0,560)
DeclareParameter("building.intGai.table[19, 4]", "Table matrix (time = first column; e.g., table=[0,2])",\
 164, 200, 0.0,0.0,0.0,0,560)
DeclareParameter("building.intGai.table[20, 1]", "Table matrix (time = first column; e.g., table=[0,2])",\
 165, 61200, 0.0,0.0,0.0,0,560)
DeclareParameter("building.intGai.table[20, 2]", "Table matrix (time = first column; e.g., table=[0,2])",\
 166, 0, 0.0,0.0,0.0,0,560)
DeclareParameter("building.intGai.table[20, 3]", "Table matrix (time = first column; e.g., table=[0,2])",\
 167, 0, 0.0,0.0,0.0,0,560)
DeclareParameter("building.intGai.table[20, 4]", "Table matrix (time = first column; e.g., table=[0,2])",\
 168, 0, 0.0,0.0,0.0,0,560)
DeclareParameter("building.intGai.table[21, 1]", "Table matrix (time = first column; e.g., table=[0,2])",\
 169, 64800, 0.0,0.0,0.0,0,560)
DeclareParameter("building.intGai.table[21, 2]", "Table matrix (time = first column; e.g., table=[0,2])",\
 170, 0, 0.0,0.0,0.0,0,560)
DeclareParameter("building.intGai.table[21, 3]", "Table matrix (time = first column; e.g., table=[0,2])",\
 171, 0, 0.0,0.0,0.0,0,560)
DeclareParameter("building.intGai.table[21, 4]", "Table matrix (time = first column; e.g., table=[0,2])",\
 172, 0, 0.0,0.0,0.0,0,560)
DeclareParameter("building.intGai.table[22, 1]", "Table matrix (time = first column; e.g., table=[0,2])",\
 173, 72000, 0.0,0.0,0.0,0,560)
DeclareParameter("building.intGai.table[22, 2]", "Table matrix (time = first column; e.g., table=[0,2])",\
 174, 0, 0.0,0.0,0.0,0,560)
DeclareParameter("building.intGai.table[22, 3]", "Table matrix (time = first column; e.g., table=[0,2])",\
 175, 0, 0.0,0.0,0.0,0,560)
DeclareParameter("building.intGai.table[22, 4]", "Table matrix (time = first column; e.g., table=[0,2])",\
 176, 0, 0.0,0.0,0.0,0,560)
DeclareParameter("building.intGai.table[23, 1]", "Table matrix (time = first column; e.g., table=[0,2])",\
 177, 75600, 0.0,0.0,0.0,0,560)
DeclareParameter("building.intGai.table[23, 2]", "Table matrix (time = first column; e.g., table=[0,2])",\
 178, 0, 0.0,0.0,0.0,0,560)
DeclareParameter("building.intGai.table[23, 3]", "Table matrix (time = first column; e.g., table=[0,2])",\
 179, 0, 0.0,0.0,0.0,0,560)
DeclareParameter("building.intGai.table[23, 4]", "Table matrix (time = first column; e.g., table=[0,2])",\
 180, 0, 0.0,0.0,0.0,0,560)
DeclareParameter("building.intGai.table[24, 1]", "Table matrix (time = first column; e.g., table=[0,2])",\
 181, 79200, 0.0,0.0,0.0,0,560)
DeclareParameter("building.intGai.table[24, 2]", "Table matrix (time = first column; e.g., table=[0,2])",\
 182, 0, 0.0,0.0,0.0,0,560)
DeclareParameter("building.intGai.table[24, 3]", "Table matrix (time = first column; e.g., table=[0,2])",\
 183, 0, 0.0,0.0,0.0,0,560)
DeclareParameter("building.intGai.table[24, 4]", "Table matrix (time = first column; e.g., table=[0,2])",\
 184, 0, 0.0,0.0,0.0,0,560)
DeclareParameter("building.intGai.table[25, 1]", "Table matrix (time = first column; e.g., table=[0,2])",\
 185, 82800, 0.0,0.0,0.0,0,560)
DeclareParameter("building.intGai.table[25, 2]", "Table matrix (time = first column; e.g., table=[0,2])",\
 186, 0, 0.0,0.0,0.0,0,560)
DeclareParameter("building.intGai.table[25, 3]", "Table matrix (time = first column; e.g., table=[0,2])",\
 187, 0, 0.0,0.0,0.0,0,560)
DeclareParameter("building.intGai.table[25, 4]", "Table matrix (time = first column; e.g., table=[0,2])",\
 188, 0, 0.0,0.0,0.0,0,560)
DeclareParameter("building.intGai.table[26, 1]", "Table matrix (time = first column; e.g., table=[0,2])",\
 189, 86400, 0.0,0.0,0.0,0,560)
DeclareParameter("building.intGai.table[26, 2]", "Table matrix (time = first column; e.g., table=[0,2])",\
 190, 0, 0.0,0.0,0.0,0,560)
DeclareParameter("building.intGai.table[26, 3]", "Table matrix (time = first column; e.g., table=[0,2])",\
 191, 0, 0.0,0.0,0.0,0,560)
DeclareParameter("building.intGai.table[26, 4]", "Table matrix (time = first column; e.g., table=[0,2])",\
 192, 0, 0.0,0.0,0.0,0,560)
DeclareParameter("building.intGai.verboseRead", "= true, if info message that file is loading is to be printed [:#(type=Boolean)]",\
 193, true, 0.0,0.0,0.0,0,562)
DeclareParameter("building.intGai.columns[1]", "Columns of table to be interpolated [:#(type=Integer)]",\
 194, 2, 0.0,0.0,0.0,0,564)
DeclareParameter("building.intGai.columns[2]", "Columns of table to be interpolated [:#(type=Integer)]",\
 195, 3, 0.0,0.0,0.0,0,564)
DeclareParameter("building.intGai.columns[3]", "Columns of table to be interpolated [:#(type=Integer)]",\
 196, 4, 0.0,0.0,0.0,0,564)
DeclareVariable("building.intGai.smoothness", "Smoothness of table interpolation [:#(type=Modelica.Blocks.Types.Smoothness)]",\
 1, 1.0,5.0,0.0,0,517)
DeclareParameter("building.intGai.extrapolation", "Extrapolation of data outside the definition range [:#(type=Modelica.Blocks.Types.Extrapolation)]",\
 197, 3, 1.0,4.0,0.0,0,564)
DeclareParameter("building.intGai.offset[1]", "Offsets of output signals", 198, 0,\
 0.0,0.0,0.0,0,560)
DeclareParameter("building.intGai.startTime", "Output = offset for time < startTime [s]",\
 199, 0, 0.0,0.0,0.0,0,560)
DeclareVariable("building.intGai.timeScale", "Time scale of first table column [s]",\
 1, 1E-15,1E+100,0.0,0,513)
DeclareVariable("building.intGai.t_min", "Minimum abscissa value defined in table [s]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("building.intGai.t_max", "Maximum abscissa value defined in table [s]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("building.intGai.t_minScaled", "Minimum (scaled) abscissa value defined in table",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("building.intGai.t_maxScaled", "Maximum (scaled) abscissa value defined in table",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("building.intGai.p_offset[1]", "Offsets of output signals", 0.0,\
 0.0,0.0,0.0,0,2561)
DeclareVariable("building.intGai.p_offset[2]", "Offsets of output signals", 0.0,\
 0.0,0.0,0.0,0,2561)
DeclareVariable("building.intGai.p_offset[3]", "Offsets of output signals", 0.0,\
 0.0,0.0,0.0,0,2561)
DeclareVariable("building.intGai.tableID.id", "[:#(type=Integer)]", 0, 0.0,0.0,\
0.0,0,2565)
DeclareVariable("building.intGai.nextTimeEvent", "Next time event instant [s]", 0,\
 0.0,0.0,0.0,0,2704)
DeclareVariable("building.intGai.nextTimeEventScaled", "Next scaled time event instant",\
 0, 0.0,0.0,0.0,0,2704)
DeclareVariable("building.intGai.tableOnFileRead", "= 1, if table was successfully read from file",\
 0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("building.intGai.DBL_MAX", "", 1.7976931348623157E+308, 0.0,0.0,\
0.0,0,2561)
DeclareVariable("building.intGai.timeScaled", "Scaled time", 0.0, 0.0,0.0,0.0,0,2560)
DeclareParameter("building.const[1].k", "Constant output value", 200, 0, 0.0,1.0,\
0.0,0,560)
DeclareAlias2("building.const[1].y", "Connector of Real output signal", \
"building.const[1].k", 1, 7, 200, 0)
DeclareParameter("building.const[2].k", "Constant output value", 201, 0, 0.0,1.0,\
0.0,0,560)
DeclareAlias2("building.const[2].y", "Connector of Real output signal", \
"building.const[2].k", 1, 7, 201, 0)
DeclareParameter("building.macConv.T_ref", "Reference temperature [K|degC]", 202,\
 293.15, 0.0,1E+100,300.0,0,560)
DeclareParameter("building.macConv.alpha", "Temperature coefficient of heat flow rate [1/K]",\
 203, 0, 0.0,0.0,0.0,0,560)
DeclareAlias2("building.macConv.Q_flow", "[W]", "building.intGai.y[3]", 1, 5, 508,\
 0)
DeclareAlias2("building.macConv.port.T", "Port temperature [K|degC]", \
"building.heaPorCoo[1].T", 1, 5, 188, 4)
DeclareVariable("building.macConv.port.Q_flow", "Heat flow rate (positive if flowing from outside into the component) [W]",\
 0.0, 0.0,0.0,0.0,0,776)
DeclareParameter("building.alphaWall.k", "Constant output value", 204, 287.5, \
0.0,0.0,0.0,0,560)
DeclareAlias2("building.alphaWall.y", "Connector of Real output signal", \
"building.alphaWall.k", 1, 7, 204, 0)
DeclareParameter("building.minTSet.k", "Constant output value", 205, 20, \
0.0,0.0,0.0,0,560)
DeclareAlias2("building.minTSet.y", "Connector of Real output signal", \
"building.minTSet.k", 1, 7, 205, 0)
DeclareAlias2("building.from_degC1.u", "Temperature in degree Celsius [degC]", \
"building.minTSet.k", 1, 7, 205, 0)
DeclareVariable("building.from_degC1.y", "Temperature in kelvin [K]", 0.0, \
0.0,0.0,0.0,0,513)
DeclareVariable("building.from_degC1.k", "Multiplier", 1.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("building.from_degC1.p", "Adder", 273.15, 0.0,0.0,0.0,0,2561)
DeclareVariable("building.from_degC1.conv.p", "Value to be added", 273.15, \
0.0,0.0,0.0,0,2561)
DeclareVariable("building.from_degC1.conv.k", "Gain of input", 1.0, 0.0,0.0,0.0,\
0,2561)
DeclareAlias2("building.from_degC1.conv.u", "Connector of Real input signal", \
"building.minTSet.k", 1, 7, 205, 1024)
DeclareAlias2("building.from_degC1.conv.y", "Connector of Real output signal", \
"building.from_degC1.y", 1, 5, 526, 1024)
DeclareParameter("building.maxTSet.k", "Constant output value", 206, 24, \
0.0,0.0,0.0,0,560)
DeclareAlias2("building.maxTSet.y", "Connector of Real output signal", \
"building.maxTSet.k", 1, 7, 206, 0)
DeclareAlias2("building.from_degC2.u", "Temperature in degree Celsius [degC]", \
"building.maxTSet.k", 1, 7, 206, 0)
DeclareVariable("building.from_degC2.y", "Temperature in kelvin [K]", 0.0, \
0.0,0.0,0.0,0,513)
DeclareVariable("building.from_degC2.k", "Multiplier", 1.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("building.from_degC2.p", "Adder", 273.15, 0.0,0.0,0.0,0,2561)
DeclareVariable("building.from_degC2.conv.p", "Value to be added", 273.15, \
0.0,0.0,0.0,0,2561)
DeclareVariable("building.from_degC2.conv.k", "Gain of input", 1.0, 0.0,0.0,0.0,\
0,2561)
DeclareAlias2("building.from_degC2.conv.u", "Connector of Real input signal", \
"building.maxTSet.k", 1, 7, 206, 1024)
DeclareAlias2("building.from_degC2.conv.y", "Connector of Real output signal", \
"building.from_degC2.y", 1, 5, 531, 1024)
DeclareVariable("building.conPIDMinT.controlError", "Control error (set point - measurement)",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("building.conPIDMinT.controllerType", "Type of controller [:#(type=Buildings.Controls.OBC.CDL.Types.SimpleController)]",\
 2, 1.0,4.0,0.0,0,517)
DeclareParameter("building.conPIDMinT.k", "Gain of controller [1]", 207, 1, 0.0,\
1E+100,0.0,0,560)
DeclareParameter("building.conPIDMinT.Ti", "Time constant of integrator block [s]",\
 208, 120, 1E-60,1E+100,0.0,0,560)
DeclareParameter("building.conPIDMinT.Td", "Time constant of derivative block [s]",\
 209, 0.1, 0.0,1E+100,0.0,0,560)
DeclareParameter("building.conPIDMinT.yMax", "Upper limit of output", 210, 1, \
0.0,0.0,0.0,0,560)
DeclareParameter("building.conPIDMinT.yMin", "Lower limit of output", 211, 0, \
0.0,0.0,0.0,0,560)
DeclareParameter("building.conPIDMinT.wp", "Set-point weight for Proportional block (0..1)",\
 212, 1, 0.0,1E+100,0.0,0,560)
DeclareParameter("building.conPIDMinT.wd", "Set-point weight for Derivative block (0..1)",\
 213, 0, 0.0,1E+100,0.0,0,560)
DeclareParameter("building.conPIDMinT.Ni", "Ni*Ti is time constant of anti-windup compensation",\
 214, 0.9, 1E-13,1E+100,0.0,0,560)
DeclareParameter("building.conPIDMinT.Nd", "The higher Nd, the more ideal the derivative block",\
 215, 10, 1E-13,1E+100,0.0,0,560)
DeclareVariable("building.conPIDMinT.initType", "Type of initialization [:#(type=Buildings.Controls.OBC.CDL.Types.Init)]",\
 2, 1.0,3.0,0.0,0,517)
DeclareParameter("building.conPIDMinT.xi_start", "Initial or guess value value for integrator output (= integrator state)",\
 216, 0, 0.0,0.0,0.0,0,560)
DeclareParameter("building.conPIDMinT.xd_start", "Initial or guess value for state of derivative block",\
 217, 0, 0.0,0.0,0.0,0,560)
DeclareParameter("building.conPIDMinT.y_start", "Initial value of output", 218, 0,\
 0.0,0.0,0.0,0,560)
DeclareVariable("building.conPIDMinT.strict", "= true, if strict limits with noEvent(..) [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,515)
DeclareParameter("building.conPIDMinT.reverseAction", "Set to true for throttling the water flow rate through a cooling coil controller [:#(type=Boolean)]",\
 219, false, 0.0,0.0,0.0,0,562)
DeclareVariable("building.conPIDMinT.reset", "Type of controller output reset [:#(type=Buildings.Controls.OBC.CDL.Types.Reset)]",\
 1, 1.0,3.0,0.0,0,517)
DeclareVariable("building.conPIDMinT.y_reset", "Value to which the controller output is reset if the boolean trigger has a rising edge, used if reset == CDL.Types.Reset.Parameter",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareAlias2("building.conPIDMinT.u_s", "Connector of setpoint input signal", \
"building.from_degC1.y", 1, 5, 526, 0)
DeclareAlias2("building.conPIDMinT.u_m", "Connector of measurement input signal",\
 "building.heaPorCoo[1].T", 1, 5, 188, 0)
DeclareVariable("building.conPIDMinT.y", "Connector of actuator output signal", \
0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("building.conPIDMinT.addP.k1", "Gain for input u1", 0.0, \
0.0,0.0,0.0,0,513)
DeclareVariable("building.conPIDMinT.addP.k2", "Gain for input u2", 0.0, \
0.0,0.0,0.0,0,513)
DeclareAlias2("building.conPIDMinT.addP.u1", "Connector of Real input signal 1",\
 "building.from_degC1.y", 1, 5, 526, 0)
DeclareAlias2("building.conPIDMinT.addP.u2", "Connector of Real input signal 2",\
 "building.heaPorCoo[1].T", 1, 5, 188, 0)
DeclareVariable("building.conPIDMinT.addP.y", "Connector of Real output signal",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareParameter("building.conPIDMinT.P.k", "Gain value multiplied with input signal",\
 220, 1, 0.0,0.0,0.0,0,560)
DeclareAlias2("building.conPIDMinT.P.u", "Input signal connector", \
"building.conPIDMinT.addP.y", 1, 5, 545, 0)
DeclareVariable("building.conPIDMinT.P.y", "Output signal connector", 0.0, \
0.0,0.0,0.0,0,512)
DeclareVariable("building.conPIDMinT.addPID.k1", "Gain of upper input", 1, \
0.0,0.0,0.0,0,513)
DeclareVariable("building.conPIDMinT.addPID.k2", "Gain of middle input", 1, \
0.0,0.0,0.0,0,513)
DeclareVariable("building.conPIDMinT.addPID.k3", "Gain of lower input", 1, \
0.0,0.0,0.0,0,513)
DeclareAlias2("building.conPIDMinT.addPID.u1", "Connector 1 of Real input signals",\
 "building.conPIDMinT.P.y", 1, 5, 546, 0)
DeclareVariable("building.conPIDMinT.addPID.u2", "Connector 2 of Real input signals",\
 0, 0.0,0.0,0.0,0,513)
DeclareAlias2("building.conPIDMinT.addPID.u3", "Connector 3 of Real input signals",\
 "building.conPIDMinT.I.y", 1, 1, 16, 0)
DeclareVariable("building.conPIDMinT.addPID.y", "Connector of Real output signals",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("building.conPIDMinT.unitTime", "[s]", 1, 0.0,0.0,0.0,0,1537)
DeclareVariable("building.conPIDMinT.revAct", "Switch for sign for reverse action",\
 0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("building.conPIDMinT.with_I", "Boolean flag to enable integral action [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,1539)
DeclareVariable("building.conPIDMinT.with_D", "Boolean flag to enable derivative action [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,1539)
DeclareVariable("building.conPIDMinT.Dzero.k", "Constant output value", 0, \
0.0,0.0,0.0,0,1537)
DeclareVariable("building.conPIDMinT.Dzero.y", "Connector of Real output signal",\
 0.0, 0.0,0.0,0.0,0,1537)
DeclareAlias2("building.conPIDMinT.y_reset_internal", "Internal connector for controller output reset",\
 "building.conPIDMinT.y_reset", 1, 5, 541, 1024)
DeclareVariable("building.conPIDMinT.addI.k1", "Gain of upper input", 0.0, \
0.0,0.0,0.0,0,2561)
DeclareVariable("building.conPIDMinT.addI.k2", "Gain of middle input", 0.0, \
0.0,0.0,0.0,0,2561)
DeclareParameter("building.conPIDMinT.addI.k3", "Gain of lower input", 221, 1, \
0.0,0.0,0.0,0,2608)
DeclareAlias2("building.conPIDMinT.addI.u1", "Connector 1 of Real input signals",\
 "building.from_degC1.y", 1, 5, 526, 1024)
DeclareAlias2("building.conPIDMinT.addI.u2", "Connector 2 of Real input signals",\
 "building.heaPorCoo[1].T", 1, 5, 188, 1024)
DeclareVariable("building.conPIDMinT.addI.u3", "Connector 3 of Real input signals",\
 0.0, 0.0,0.0,0.0,0,2560)
DeclareVariable("building.conPIDMinT.addI.y", "Connector of Real output signals",\
 0.0, 0.0,0.0,0.0,0,2560)
DeclareVariable("building.conPIDMinT.addSat.k1", "Gain for input u1", 1, \
0.0,0.0,0.0,0,2561)
DeclareVariable("building.conPIDMinT.addSat.k2", "Gain for input u2", -1, \
0.0,0.0,0.0,0,2561)
DeclareAlias2("building.conPIDMinT.addSat.u1", "Connector of Real input signal 1",\
 "building.conPIDMinT.y", 1, 5, 542, 1024)
DeclareAlias2("building.conPIDMinT.addSat.u2", "Connector of Real input signal 2",\
 "building.conPIDMinT.gainPID.y", 1, 5, 566, 1024)
DeclareVariable("building.conPIDMinT.addSat.y", "Connector of Real output signal",\
 0.0, 0.0,0.0,0.0,0,2560)
DeclareVariable("building.conPIDMinT.gainPID.k", "Gain value multiplied with input signal",\
 0.0, 0.0,0.0,0.0,0,2561)
DeclareAlias2("building.conPIDMinT.gainPID.u", "Input signal connector", \
"building.conPIDMinT.addPID.y", 1, 5, 551, 1024)
DeclareVariable("building.conPIDMinT.gainPID.y", "Output signal connector", 0.0,\
 0.0,0.0,0.0,0,2560)
DeclareVariable("building.conPIDMinT.gainTrack.k", "Gain value multiplied with input signal",\
 0.0, 0.0,0.0,0.0,0,2561)
DeclareAlias2("building.conPIDMinT.gainTrack.u", "Input signal connector", \
"building.conPIDMinT.addSat.y", 1, 5, 564, 1024)
DeclareAlias2("building.conPIDMinT.gainTrack.y", "Output signal connector", \
"building.conPIDMinT.addI.u3", 1, 5, 560, 1024)
DeclareVariable("building.conPIDMinT.limiter.uMax", "Upper limits of input signals",\
 1, 0.0,0.0,0.0,0,2561)
DeclareVariable("building.conPIDMinT.limiter.uMin", "Lower limits of input signals",\
 0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("building.conPIDMinT.limiter.strict", "= true, if strict limits with noEvent(..) [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,2563)
DeclareVariable("building.conPIDMinT.limiter.limitsAtInit", "Has no longer an effect and is only kept for backwards compatibility (the implementation uses now the homotopy operator) [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,2563)
DeclareAlias2("building.conPIDMinT.limiter.u", "Connector of Real input signal",\
 "building.conPIDMinT.gainPID.y", 1, 5, 566, 1024)
DeclareAlias2("building.conPIDMinT.limiter.y", "Connector of Real output signal",\
 "building.conPIDMinT.y", 1, 5, 542, 1024)
DeclareVariable("building.conPIDMax.controlError", "Control error (set point - measurement)",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("building.conPIDMax.controllerType", "Type of controller [:#(type=Buildings.Controls.OBC.CDL.Types.SimpleController)]",\
 2, 1.0,4.0,0.0,0,517)
DeclareParameter("building.conPIDMax.k", "Gain of controller [1]", 222, 1, 0.0,\
1E+100,0.0,0,560)
DeclareParameter("building.conPIDMax.Ti", "Time constant of integrator block [s]",\
 223, 120, 1E-60,1E+100,0.0,0,560)
DeclareParameter("building.conPIDMax.Td", "Time constant of derivative block [s]",\
 224, 0.1, 0.0,1E+100,0.0,0,560)
DeclareParameter("building.conPIDMax.yMax", "Upper limit of output", 225, 1, \
0.0,0.0,0.0,0,560)
DeclareParameter("building.conPIDMax.yMin", "Lower limit of output", 226, 0, \
0.0,0.0,0.0,0,560)
DeclareParameter("building.conPIDMax.wp", "Set-point weight for Proportional block (0..1)",\
 227, 1, 0.0,1E+100,0.0,0,560)
DeclareParameter("building.conPIDMax.wd", "Set-point weight for Derivative block (0..1)",\
 228, 0, 0.0,1E+100,0.0,0,560)
DeclareParameter("building.conPIDMax.Ni", "Ni*Ti is time constant of anti-windup compensation",\
 229, 0.9, 1E-13,1E+100,0.0,0,560)
DeclareParameter("building.conPIDMax.Nd", "The higher Nd, the more ideal the derivative block",\
 230, 10, 1E-13,1E+100,0.0,0,560)
DeclareVariable("building.conPIDMax.initType", "Type of initialization [:#(type=Buildings.Controls.OBC.CDL.Types.Init)]",\
 2, 1.0,3.0,0.0,0,517)
DeclareParameter("building.conPIDMax.xi_start", "Initial or guess value value for integrator output (= integrator state)",\
 231, 0, 0.0,0.0,0.0,0,560)
DeclareParameter("building.conPIDMax.xd_start", "Initial or guess value for state of derivative block",\
 232, 0, 0.0,0.0,0.0,0,560)
DeclareParameter("building.conPIDMax.y_start", "Initial value of output", 233, 0,\
 0.0,0.0,0.0,0,560)
DeclareVariable("building.conPIDMax.strict", "= true, if strict limits with noEvent(..) [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,515)
DeclareParameter("building.conPIDMax.reverseAction", "Set to true for throttling the water flow rate through a cooling coil controller [:#(type=Boolean)]",\
 234, true, 0.0,0.0,0.0,0,562)
DeclareVariable("building.conPIDMax.reset", "Type of controller output reset [:#(type=Buildings.Controls.OBC.CDL.Types.Reset)]",\
 1, 1.0,3.0,0.0,0,517)
DeclareVariable("building.conPIDMax.y_reset", "Value to which the controller output is reset if the boolean trigger has a rising edge, used if reset == CDL.Types.Reset.Parameter",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareAlias2("building.conPIDMax.u_s", "Connector of setpoint input signal", \
"building.from_degC2.y", 1, 5, 531, 0)
DeclareAlias2("building.conPIDMax.u_m", "Connector of measurement input signal",\
 "building.heaPorCoo[1].T", 1, 5, 188, 0)
DeclareVariable("building.conPIDMax.y", "Connector of actuator output signal", \
0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("building.conPIDMax.addP.k1", "Gain for input u1", 0.0, 0.0,0.0,\
0.0,0,513)
DeclareVariable("building.conPIDMax.addP.k2", "Gain for input u2", 0.0, 0.0,0.0,\
0.0,0,513)
DeclareAlias2("building.conPIDMax.addP.u1", "Connector of Real input signal 1", \
"building.from_degC2.y", 1, 5, 531, 0)
DeclareAlias2("building.conPIDMax.addP.u2", "Connector of Real input signal 2", \
"building.heaPorCoo[1].T", 1, 5, 188, 0)
DeclareVariable("building.conPIDMax.addP.y", "Connector of Real output signal", \
0.0, 0.0,0.0,0.0,0,512)
DeclareParameter("building.conPIDMax.P.k", "Gain value multiplied with input signal",\
 235, 1, 0.0,0.0,0.0,0,560)
DeclareAlias2("building.conPIDMax.P.u", "Input signal connector", \
"building.conPIDMax.addP.y", 1, 5, 581, 0)
DeclareVariable("building.conPIDMax.P.y", "Output signal connector", 0.0, \
0.0,0.0,0.0,0,512)
DeclareVariable("building.conPIDMax.addPID.k1", "Gain of upper input", 1, \
0.0,0.0,0.0,0,513)
DeclareVariable("building.conPIDMax.addPID.k2", "Gain of middle input", 1, \
0.0,0.0,0.0,0,513)
DeclareVariable("building.conPIDMax.addPID.k3", "Gain of lower input", 1, \
0.0,0.0,0.0,0,513)
DeclareAlias2("building.conPIDMax.addPID.u1", "Connector 1 of Real input signals",\
 "building.conPIDMax.P.y", 1, 5, 582, 0)
DeclareVariable("building.conPIDMax.addPID.u2", "Connector 2 of Real input signals",\
 0, 0.0,0.0,0.0,0,513)
DeclareAlias2("building.conPIDMax.addPID.u3", "Connector 3 of Real input signals",\
 "building.conPIDMax.I.y", 1, 1, 17, 0)
DeclareVariable("building.conPIDMax.addPID.y", "Connector of Real output signals",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("building.conPIDMax.unitTime", "[s]", 1, 0.0,0.0,0.0,0,1537)
DeclareVariable("building.conPIDMax.revAct", "Switch for sign for reverse action",\
 0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("building.conPIDMax.with_I", "Boolean flag to enable integral action [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,1539)
DeclareVariable("building.conPIDMax.with_D", "Boolean flag to enable derivative action [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,1539)
DeclareVariable("building.conPIDMax.Dzero.k", "Constant output value", 0, \
0.0,0.0,0.0,0,1537)
DeclareVariable("building.conPIDMax.Dzero.y", "Connector of Real output signal",\
 0.0, 0.0,0.0,0.0,0,1537)
DeclareAlias2("building.conPIDMax.y_reset_internal", "Internal connector for controller output reset",\
 "building.conPIDMax.y_reset", 1, 5, 577, 1024)
DeclareVariable("building.conPIDMax.addI.k1", "Gain of upper input", 0.0, \
0.0,0.0,0.0,0,2561)
DeclareVariable("building.conPIDMax.addI.k2", "Gain of middle input", 0.0, \
0.0,0.0,0.0,0,2561)
DeclareParameter("building.conPIDMax.addI.k3", "Gain of lower input", 236, 1, \
0.0,0.0,0.0,0,2608)
DeclareAlias2("building.conPIDMax.addI.u1", "Connector 1 of Real input signals",\
 "building.from_degC2.y", 1, 5, 531, 1024)
DeclareAlias2("building.conPIDMax.addI.u2", "Connector 2 of Real input signals",\
 "building.heaPorCoo[1].T", 1, 5, 188, 1024)
DeclareVariable("building.conPIDMax.addI.u3", "Connector 3 of Real input signals",\
 0.0, 0.0,0.0,0.0,0,2560)
DeclareVariable("building.conPIDMax.addI.y", "Connector of Real output signals",\
 0.0, 0.0,0.0,0.0,0,2560)
DeclareVariable("building.conPIDMax.addSat.k1", "Gain for input u1", 1, 0.0,0.0,\
0.0,0,2561)
DeclareVariable("building.conPIDMax.addSat.k2", "Gain for input u2", -1, \
0.0,0.0,0.0,0,2561)
DeclareAlias2("building.conPIDMax.addSat.u1", "Connector of Real input signal 1",\
 "building.conPIDMax.y", 1, 5, 578, 1024)
DeclareAlias2("building.conPIDMax.addSat.u2", "Connector of Real input signal 2",\
 "building.conPIDMax.gainPID.y", 1, 5, 602, 1024)
DeclareVariable("building.conPIDMax.addSat.y", "Connector of Real output signal",\
 0.0, 0.0,0.0,0.0,0,2560)
DeclareVariable("building.conPIDMax.gainPID.k", "Gain value multiplied with input signal",\
 0.0, 0.0,0.0,0.0,0,2561)
DeclareAlias2("building.conPIDMax.gainPID.u", "Input signal connector", \
"building.conPIDMax.addPID.y", 1, 5, 587, 1024)
DeclareVariable("building.conPIDMax.gainPID.y", "Output signal connector", 0.0, \
0.0,0.0,0.0,0,2560)
DeclareVariable("building.conPIDMax.gainTrack.k", "Gain value multiplied with input signal",\
 0.0, 0.0,0.0,0.0,0,2561)
DeclareAlias2("building.conPIDMax.gainTrack.u", "Input signal connector", \
"building.conPIDMax.addSat.y", 1, 5, 600, 1024)
DeclareAlias2("building.conPIDMax.gainTrack.y", "Output signal connector", \
"building.conPIDMax.addI.u3", 1, 5, 596, 1024)
DeclareVariable("building.conPIDMax.limiter.uMax", "Upper limits of input signals",\
 1, 0.0,0.0,0.0,0,2561)
DeclareVariable("building.conPIDMax.limiter.uMin", "Lower limits of input signals",\
 0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("building.conPIDMax.limiter.strict", "= true, if strict limits with noEvent(..) [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,2563)
DeclareVariable("building.conPIDMax.limiter.limitsAtInit", "Has no longer an effect and is only kept for backwards compatibility (the implementation uses now the homotopy operator) [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,2563)
DeclareAlias2("building.conPIDMax.limiter.u", "Connector of Real input signal", \
"building.conPIDMax.gainPID.y", 1, 5, 602, 1024)
DeclareAlias2("building.conPIDMax.limiter.y", "Connector of Real output signal",\
 "building.conPIDMax.y", 1, 5, 578, 1024)
DeclareVariable("building.gai.k", "Gain value multiplied with input signal", 0.0,\
 0.0,0.0,0.0,0,513)
DeclareAlias2("building.gai.u", "Input signal connector", "building.conPIDMinT.y", 1,\
 5, 542, 0)
DeclareAlias2("building.gai.y", "Output signal connector", "building.Q_flowHeaReq[1]", 1,\
 5, 193, 0)
DeclareVariable("building.gai1.k", "Gain value multiplied with input signal", \
0.0, 0.0,0.0,0.0,0,513)
DeclareAlias2("building.gai1.u", "Input signal connector", "building.conPIDMax.y", 1,\
 5, 578, 0)
DeclareAlias2("building.gai1.y", "Output signal connector", "building.Q_flowCooReq[1]", 1,\
 5, 192, 0)
DeclareParameter("building.sin.amplitude", "Amplitude of sine wave", 237, 500, \
0.0,0.0,0.0,0,560)
DeclareParameter("building.sin.freqHz", "Frequency of sine wave [Hz]", 238, \
1.1574074074074073E-05, 0.0,0.0,0.0,0,560)
DeclareParameter("building.sin.phase", "Phase of sine wave [rad|deg]", 239, 0, \
0.0,0.0,0.0,0,560)
DeclareParameter("building.sin.offset", "Offset of output signal", 240, 500, \
0.0,0.0,0.0,0,560)
DeclareParameter("building.sin.startTime", "Output = offset for time < startTime [s]",\
 241, 0, 0.0,0.0,0.0,0,560)
DeclareAlias2("building.sin.y", "Connector of Real output signal", \
"building.Q_flowHeaReq[2]", 1, 5, 194, 0)
DeclareParameter("building.hConWin_Const.k", "Constant output value", 242, 287.5,\
 0.0,0.0,0.0,0,560)
DeclareAlias2("building.hConWin_Const.y", "Connector of Real output signal", \
"building.hConWin_Const.k", 1, 7, 242, 0)
DeclareVariable("coo.allowFlowReversal1", "= false to simplify equations, assuming, but not enforcing, no flow reversal for medium 1 [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,515)
DeclareVariable("coo.allowFlowReversal2", "= false to simplify equations, assuming, but not enforcing, no flow reversal for medium 2 [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,515)
DeclareVariable("coo.port_a1.m_flow", "Mass flow rate from the connection point into the component [kg/s]",\
 0, -100000.0,100000.0,0.5,0,840)
DeclareAlias2("coo.port_a1.p", "Thermodynamic pressure in the connection point [Pa|bar]",\
 "souDis.p", 1, 7, 307, 4)
DeclareVariable("coo.port_a1.h_outflow", "Specific thermodynamic enthalpy close to the connection point if m_flow < 0 [J/kg]",\
 83680.0, -10000000000.0,10000000000.0,83680.0,0,520)
DeclareAlias2("coo.port_b1.m_flow", "Mass flow rate from the connection point into the component [kg/s]",\
 "coo.port_a1.m_flow", -1, 5, 612, 132)
DeclareAlias2("coo.port_b1.p", "Thermodynamic pressure in the connection point [Pa|bar]",\
 "sinDis.p", 1, 7, 316, 4)
DeclareVariable("coo.port_b1.h_outflow", "Specific thermodynamic enthalpy close to the connection point if m_flow < 0 [J/kg]",\
 83680.0, -10000000000.0,10000000000.0,83680.0,0,520)
DeclareVariable("coo.port_a2.m_flow", "Mass flow rate from the connection point into the component [kg/s]",\
 0, -0.0,100000.0,0.5,0,776)
DeclareVariable("coo.port_a2.p", "Thermodynamic pressure in the connection point [Pa|bar]",\
 0.0, 0.0,100000000.0,100000.0,0,520)
DeclareVariable("coo.port_a2.h_outflow", "Specific thermodynamic enthalpy close to the connection point if m_flow < 0 [J/kg]",\
 83680.0, -10000000000.0,10000000000.0,83680.0,0,520)
DeclareAlias2("coo.port_b2.m_flow", "Mass flow rate from the connection point into the component [kg/s]",\
 "coo.port_a2.m_flow", -1, 5, 615, 132)
DeclareAlias2("coo.port_b2.p", "Thermodynamic pressure in the connection point [Pa|bar]",\
 "exp.p_start", 1, 7, 345, 4)
DeclareVariable("coo.port_b2.h_outflow", "Specific thermodynamic enthalpy close to the connection point if m_flow < 0 [J/kg]",\
 83680.0, -10000000000.0,10000000000.0,83680.0,0,520)
DeclareVariable("coo.m1_flow_nominal", "Nominal mass flow rate of primary (district) district cooling side [kg/s]",\
 0.5, 0.0,1E+100,0.0,0,513)
DeclareVariable("coo.m2_flow_nominal", "Nominal mass flow rate of secondary (building) district cooling side [kg/s]",\
 0.5, 0.0,1E+100,0.0,0,513)
DeclareParameter("coo.dpValve_nominal", "Nominal pressure drop of fully open control valve [Pa|Pa]",\
 243, 10, 0.0,1E+100,0.0,0,560)
DeclareVariable("coo.dp1_nominal", "Nominal pressure difference on primary side [Pa|Pa]",\
 1000, 0.0,1E+100,0.0,0,513)
DeclareVariable("coo.dp2_nominal", "Nominal pressure difference on secondary side [Pa|Pa]",\
 500, 0.0,1E+100,0.0,0,513)
DeclareParameter("coo.use_Q_flow_nominal", "Set to true to specify Q_flow_nominal and temperatures, or to false to specify effectiveness [:#(type=Boolean)]",\
 244, true, 0.0,0.0,0.0,0,562)
DeclareParameter("coo.Q_flow_nominal", "Nominal heat transfer [W]", 245, 1000, \
0.0,1E+100,0.0,0,560)
DeclareParameter("coo.T_a1_nominal", "Nominal temperature at port a1 [K|K]", 246,\
 280.15, 273.0,373.15,300.0,0,560)
DeclareParameter("coo.T_a2_nominal", "Nominal temperature at port a2 [K|K]", 247,\
 303.15, 273.0,373.15,300.0,0,560)
DeclareParameter("coo.eta", "Constant effectiveness [1]", 248, 0.8, 0.0,1.0,0.0,\
0,560)
DeclareParameter("coo.controllerType", "Type of controller [:#(type=Modelica.Blocks.Types.SimpleController)]",\
 249, 2, 1.0,4.0,0.0,0,564)
DeclareParameter("coo.k", "Gain of controller [1]", 250, 1, 0.0,1E+100,0.0,0,560)
DeclareParameter("coo.Ti", "Time constant of integrator block [s]", 251, 120, \
1E-60,1E+100,0.0,0,560)
DeclareParameter("coo.Td", "Time constant of derivative block [s]", 252, 0.1, \
0.0,1E+100,0.0,0,560)
DeclareVariable("coo.yMax", "Upper limit of output", 1, 0.0,0.0,0.0,0,513)
DeclareVariable("coo.yMin", "Lower limit of output", 0, 0.0,0.0,0.0,0,513)
DeclareParameter("coo.wp", "Set-point weight for Proportional block (0..1)", 253,\
 1, 0.0,1E+100,0.0,0,560)
DeclareParameter("coo.wd", "Set-point weight for Derivative block (0..1)", 254, 0,\
 0.0,1E+100,0.0,0,560)
DeclareParameter("coo.Ni", "Ni*Ti is time constant of anti-windup compensation",\
 255, 0.9, 1E-13,1E+100,0.0,0,560)
DeclareParameter("coo.Nd", "The higher Nd, the more ideal the derivative block",\
 256, 10, 1E-13,1E+100,0.0,0,560)
DeclareVariable("coo.initType", "Type of initialization (1: no init, 2: steady state, 3: initial state, 4: initial output) [:#(type=Modelica.Blocks.Types.InitPID)]",\
 5, 1.0,5.0,0.0,0,517)
DeclareVariable("coo.xi_start", "Initial or guess value value for integrator output (= integrator state)",\
 0, 0.0,0.0,0.0,0,513)
DeclareParameter("coo.xd_start", "Initial or guess value for state of derivative block",\
 257, 0, 0.0,0.0,0.0,0,560)
DeclareVariable("coo.yCon_start", "Initial value of output from the controller",\
 0, 0.0,0.0,0.0,0,513)
DeclareParameter("coo.reverseAction", "Set to true for throttling the water flow rate through a cooling coil controller [:#(type=Boolean)]",\
 258, true, 0.0,0.0,0.0,0,562)
DeclareAlias2("coo.TSet", "Setpoint temperature [K]", "TSetCHWS.k", 1, 7, 297, 0)
DeclareVariable("coo.Q_flow", "Measured power demand at the ETS [W|kW]", 0.0, \
0.0,0.0,0.0,0,512)
DeclareAlias2("coo.Q", "Measured energy consumption at the ETS [J|kWh]", \
"coo.int.y", 1, 1, 2, 0)
DeclareVariable("coo.hex.allowFlowReversal1", "= false to simplify equations, assuming, but not enforcing, no flow reversal for medium 1 [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,515)
DeclareVariable("coo.hex.allowFlowReversal2", "= false to simplify equations, assuming, but not enforcing, no flow reversal for medium 2 [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,515)
DeclareAlias2("coo.hex.port_a1.m_flow", "Mass flow rate from the connection point into the component [kg/s]",\
 "coo.port_a1.m_flow", 1, 5, 612, 132)
DeclareVariable("coo.hex.port_a1.p", "Thermodynamic pressure in the connection point [Pa|bar]",\
 300000, 0.0,100000000.0,100000.0,0,520)
DeclareAlias2("coo.hex.port_a1.h_outflow", "Specific thermodynamic enthalpy close to the connection point if m_flow < 0 [J/kg]",\
 "coo.port_a1.h_outflow", 1, 5, 613, 4)
DeclareAlias2("coo.hex.port_b1.m_flow", "Mass flow rate from the connection point into the component [kg/s]",\
 "coo.port_a1.m_flow", -1, 5, 612, 132)
DeclareAlias2("coo.hex.port_b1.p", "Thermodynamic pressure in the connection point [Pa|bar]",\
 "sinDis.p", 1, 7, 316, 4)
DeclareAlias2("coo.hex.port_b1.h_outflow", "Specific thermodynamic enthalpy close to the connection point if m_flow < 0 [J/kg]",\
 "coo.port_b1.h_outflow", 1, 5, 614, 4)
DeclareAlias2("coo.hex.port_a2.m_flow", "Mass flow rate from the connection point into the component [kg/s]",\
 "coo.port_a2.m_flow", 1, 5, 615, 132)
DeclareAlias2("coo.hex.port_a2.p", "Thermodynamic pressure in the connection point [Pa|bar]",\
 "coo.port_a2.p", 1, 5, 616, 4)
DeclareAlias2("coo.hex.port_a2.h_outflow", "Specific thermodynamic enthalpy close to the connection point if m_flow < 0 [J/kg]",\
 "coo.port_a2.h_outflow", 1, 5, 617, 4)
DeclareAlias2("coo.hex.port_b2.m_flow", "Mass flow rate from the connection point into the component [kg/s]",\
 "coo.port_a2.m_flow", -1, 5, 615, 132)
DeclareAlias2("coo.hex.port_b2.p", "Thermodynamic pressure in the connection point [Pa|bar]",\
 "exp.p_start", 1, 7, 345, 4)
DeclareAlias2("coo.hex.port_b2.h_outflow", "Specific thermodynamic enthalpy close to the connection point if m_flow < 0 [J/kg]",\
 "coo.port_b2.h_outflow", 1, 5, 618, 4)
DeclareVariable("coo.hex.m1_flow_nominal", "Nominal mass flow rate [kg/s]", 0.5,\
 0.0,1E+100,0.0,0,513)
DeclareVariable("coo.hex.m2_flow_nominal", "Nominal mass flow rate [kg/s]", 0.5,\
 0.0,1E+100,0.0,0,513)
DeclareVariable("coo.hex.m1_flow_small", "Small mass flow rate for regularization of zero flow [kg/s]",\
 5E-05, 0.0,100000.0,0.0,0,513)
DeclareVariable("coo.hex.m2_flow_small", "Small mass flow rate for regularization of zero flow [kg/s]",\
 5E-05, 0.0,100000.0,0.0,0,513)
DeclareVariable("coo.hex.show_T", "= true, if actual temperature at port is computed [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,515)
DeclareAlias2("coo.hex.m1_flow", "Mass flow rate from port_a1 to port_b1 (m1_flow > 0 is design flow direction) [kg/s]",\
 "coo.port_a1.m_flow", 1, 5, 612, 0)
DeclareVariable("coo.hex.dp1", "Pressure difference between port_a1 and port_b1 [Pa|Pa]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("coo.hex.m2_flow", "Mass flow rate from port_a2 to port_b2 (m2_flow > 0 is design flow direction) [kg/s]",\
 "coo.port_a2.m_flow", 1, 5, 615, 0)
DeclareVariable("coo.hex.dp2", "Pressure difference between port_a2 and port_b2 [Pa|Pa]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("coo.hex.state_a1_inflow.p", "Absolute pressure of medium [Pa|bar]",\
 "coo.hex.port_a1.p", 1, 5, 631, 1024)
DeclareVariable("coo.hex.state_a1_inflow.T", "Temperature of medium [K|degC]", \
293.15, 1.0,10000.0,300.0,0,2560)
DeclareAlias2("coo.hex.state_b1_inflow.p", "Absolute pressure of medium [Pa|bar]",\
 "sinDis.p", 1, 7, 316, 1024)
DeclareVariable("coo.hex.state_b1_inflow.T", "Temperature of medium [K|degC]", \
293.15, 1.0,10000.0,300.0,0,2561)
DeclareAlias2("coo.hex.state_a2_inflow.p", "Absolute pressure of medium [Pa|bar]",\
 "coo.port_a2.p", 1, 5, 616, 1024)
DeclareVariable("coo.hex.state_a2_inflow.T", "Temperature of medium [K|degC]", \
293.15, 1.0,10000.0,300.0,0,2560)
DeclareAlias2("coo.hex.state_b2_inflow.p", "Absolute pressure of medium [Pa|bar]",\
 "exp.p_start", 1, 7, 345, 1024)
DeclareVariable("coo.hex.state_b2_inflow.T", "Temperature of medium [K|degC]", \
293.15, 1.0,10000.0,300.0,0,2560)
DeclareVariable("coo.hex.computeFlowResistance1", "=true, compute flow resistance. Set to false to assume no friction [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,515)
DeclareVariable("coo.hex.from_dp1", "= true, use m_flow = f(dp) else dp = f(m_flow) [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,515)
DeclareVariable("coo.hex.dp1_nominal", "Pressure difference [Pa|Pa]", 1000, 0.0,\
1E+100,0.0,0,513)
DeclareVariable("coo.hex.linearizeFlowResistance1", "= true, use linear relation between m_flow and dp for any flow rate [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,515)
DeclareVariable("coo.hex.deltaM1", "Fraction of nominal flow rate where flow transitions to laminar",\
 0.1, 0.0,0.0,0.0,0,513)
DeclareVariable("coo.hex.computeFlowResistance2", "=true, compute flow resistance. Set to false to assume no friction [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,515)
DeclareVariable("coo.hex.from_dp2", "= true, use m_flow = f(dp) else dp = f(m_flow) [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,515)
DeclareVariable("coo.hex.dp2_nominal", "Pressure difference [Pa|Pa]", 500, 0.0,\
1E+100,0.0,0,513)
DeclareVariable("coo.hex.linearizeFlowResistance2", "= true, use linear relation between m_flow and dp for any flow rate [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,515)
DeclareVariable("coo.hex.deltaM2", "Fraction of nominal flow rate where flow transitions to laminar",\
 0.1, 0.0,0.0,0.0,0,513)
DeclareVariable("coo.hex.prescribedHeatFlowRate1", "Set to true if the heat flow rate into fluid 1 is not a function of the component temperature [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,515)
DeclareVariable("coo.hex.prescribedHeatFlowRate2", "Set to true if the heat flow rate into fluid 2 is not a function of the component temperature [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,515)
DeclareVariable("coo.hex.homotopyInitialization", "= true, use homotopy method [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,515)
DeclareVariable("coo.hex.Q1_flow", "Heat transferred into the medium 1 [W]", 0.0,\
 0.0,0.0,0.0,0,512)
DeclareVariable("coo.hex.mWat1_flow", "Moisture mass flow rate added to the medium 1 [kg/s]",\
 0, -100000.0,100000.0,0.0,0,513)
DeclareAlias2("coo.hex.Q2_flow", "Heat transferred into the medium 2 [W]", \
"coo.hex.Q1_flow", -1, 5, 656, 0)
DeclareVariable("coo.hex.mWat2_flow", "Moisture mass flow rate added to the medium 2 [kg/s]",\
 0, -100000.0,100000.0,0.0,0,513)
DeclareVariable("coo.hex.sensibleOnly1", "Set to true if sensible exchange only for medium 1 [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,515)
DeclareVariable("coo.hex.sensibleOnly2", "Set to true if sensible exchange only for medium 2 [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,515)
DeclareVariable("coo.hex.bal1.allowFlowReversal", "= false to simplify equations, assuming, but not enforcing, no flow reversal [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,2563)
DeclareAlias2("coo.hex.bal1.port_a.m_flow", "Mass flow rate from the connection point into the component [kg/s]",\
 "coo.port_a1.m_flow", 1, 5, 612, 1156)
DeclareAlias2("coo.hex.bal1.port_a.p", "Thermodynamic pressure in the connection point [Pa|bar]",\
 "coo.hex.port_a1.p", 1, 5, 631, 1028)
DeclareAlias2("coo.hex.bal1.port_a.h_outflow", "Specific thermodynamic enthalpy close to the connection point if m_flow < 0 [J/kg]",\
 "coo.port_a1.h_outflow", 1, 5, 613, 1028)
DeclareAlias2("coo.hex.bal1.port_b.m_flow", "Mass flow rate from the connection point into the component [kg/s]",\
 "coo.port_a1.m_flow", -1, 5, 612, 1156)
DeclareAlias2("coo.hex.bal1.port_b.p", "Thermodynamic pressure in the connection point [Pa|bar]",\
 "sinDis.p", 1, 7, 316, 1028)
DeclareAlias2("coo.hex.bal1.port_b.h_outflow", "Specific thermodynamic enthalpy close to the connection point if m_flow < 0 [J/kg]",\
 "coo.port_b1.h_outflow", 1, 5, 614, 1028)
DeclareVariable("coo.hex.bal1.m_flow_nominal", "Nominal mass flow rate [kg/s]", \
0.5, 0.0,0.0,0.0,0,2561)
DeclareVariable("coo.hex.bal1.m_flow_small", "Small mass flow rate for regularization of zero flow [kg/s]",\
 5E-05, 0.0,1E+100,0.0,0,2561)
DeclareVariable("coo.hex.bal1.show_T", "= true, if actual temperature at port is computed [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,2563)
DeclareAlias2("coo.hex.bal1.m_flow", "Mass flow rate from port_a to port_b (m_flow > 0 is design flow direction) [kg/s]",\
 "coo.port_a1.m_flow", 1, 5, 612, 1024)
DeclareVariable("coo.hex.bal1.dp", "Pressure difference between port_a and port_b [Pa|Pa]",\
 0, 0.0,0.0,0.0,0,2560)
DeclareVariable("coo.hex.bal1._m_flow_start", "Start value for m_flow, used to avoid a warning if not set in m_flow, and to avoid m_flow.start in parameter window [kg/s]",\
 0, 0.0,0.0,0.0,0,2561)
DeclareVariable("coo.hex.bal1._dp_start", "Start value for dp, used to avoid a warning if not set in dp, and to avoid dp.start in parameter window [Pa|Pa]",\
 0, 0.0,0.0,0.0,0,2561)
DeclareVariable("coo.hex.bal1.computeFlowResistance", "=true, compute flow resistance. Set to false to assume no friction [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,2563)
DeclareVariable("coo.hex.bal1.from_dp", "= true, use m_flow = f(dp) else dp = f(m_flow) [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,2563)
DeclareVariable("coo.hex.bal1.dp_nominal", "Pressure difference [Pa|Pa]", 1000, \
0.0,1E+100,0.0,0,2561)
DeclareVariable("coo.hex.bal1.linearizeFlowResistance", "= true, use linear relation between m_flow and dp for any flow rate [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,2563)
DeclareVariable("coo.hex.bal1.deltaM", "Fraction of nominal flow rate where flow transitions to laminar",\
 0.1, 0.0,0.0,0.0,0,2561)
DeclareVariable("coo.hex.bal1.sensibleOnly", "Set to true if sensible exchange only [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,2563)
DeclareVariable("coo.hex.bal1.prescribedHeatFlowRate", "Set to true if the heat flow rate is not a function of the component temperature [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,2563)
DeclareVariable("coo.hex.bal1.homotopyInitialization", "= true, use homotopy method [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,2563)
DeclareAlias2("coo.hex.bal1.Q_flow", "Heat transferred into the medium [W]", \
"coo.hex.Q1_flow", 1, 5, 656, 1024)
DeclareVariable("coo.hex.bal1.mWat_flow", "Moisture mass flow rate added to the medium [kg/s]",\
 0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("coo.hex.bal1.vol.allowFlowReversal", "= false to simplify equations, assuming, but not enforcing, no flow reversal [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,2563)
DeclareAlias2("coo.hex.bal1.vol.port_a.m_flow", "Mass flow rate from the connection point into the component [kg/s]",\
 "coo.port_a1.m_flow", 1, 5, 612, 1156)
DeclareAlias2("coo.hex.bal1.vol.port_a.p", "Thermodynamic pressure in the connection point [Pa|bar]",\
 "sinDis.p", 1, 7, 316, 1028)
DeclareAlias2("coo.hex.bal1.vol.port_a.h_outflow", "Specific thermodynamic enthalpy close to the connection point if m_flow < 0 [J/kg]",\
 "coo.port_a1.h_outflow", 1, 5, 613, 1028)
DeclareAlias2("coo.hex.bal1.vol.port_b.m_flow", "Mass flow rate from the connection point into the component [kg/s]",\
 "coo.port_a1.m_flow", -1, 5, 612, 1156)
DeclareAlias2("coo.hex.bal1.vol.port_b.p", "Thermodynamic pressure in the connection point [Pa|bar]",\
 "sinDis.p", 1, 7, 316, 1028)
DeclareAlias2("coo.hex.bal1.vol.port_b.h_outflow", "Specific thermodynamic enthalpy close to the connection point if m_flow < 0 [J/kg]",\
 "coo.port_b1.h_outflow", 1, 5, 614, 1028)
DeclareVariable("coo.hex.bal1.vol.m_flow_nominal", "Nominal mass flow rate [kg/s]",\
 0.5, 0.0,0.0,0.0,0,2561)
DeclareVariable("coo.hex.bal1.vol.m_flow_small", "Small mass flow rate for regularization of zero flow [kg/s]",\
 5E-05, 0.0,1E+100,0.0,0,2561)
DeclareVariable("coo.hex.bal1.vol.show_T", "= true, if actual temperature at port is computed [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,2563)
DeclareAlias2("coo.hex.bal1.vol.m_flow", "Mass flow rate from port_a to port_b (m_flow > 0 is design flow direction) [kg/s]",\
 "coo.port_a1.m_flow", 1, 5, 612, 1024)
DeclareVariable("coo.hex.bal1.vol.dp", "Pressure difference between port_a and port_b [Pa|Pa]",\
 0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("coo.hex.bal1.vol._m_flow_start", "Start value for m_flow, used to avoid a warning if not set in m_flow, and to avoid m_flow.start in parameter window [kg/s]",\
 0, 0.0,0.0,0.0,0,2561)
DeclareVariable("coo.hex.bal1.vol._dp_start", "Start value for dp, used to avoid a warning if not set in dp, and to avoid dp.start in parameter window [Pa|Pa]",\
 0, 0.0,0.0,0.0,0,2561)
DeclareVariable("coo.hex.bal1.vol.simplify_mWat_flow", "Set to true to cause port_a.m_flow + port_b.m_flow = 0 even if mWat_flow is non-zero [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,2563)
DeclareVariable("coo.hex.bal1.vol.prescribedHeatFlowRate", "Set to true if the heat flow rate is not a function of a temperature difference to the fluid temperature [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,2563)
DeclareVariable("coo.hex.bal1.vol.use_mWat_flow", "Set to true to enable input connector for moisture mass flow rate [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,2563)
DeclareVariable("coo.hex.bal1.vol.use_C_flow", "Set to true to enable input connector for trace substance [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,2563)
DeclareAlias2("coo.hex.bal1.vol.Q_flow", "Sensible plus latent heat flow rate transferred into the medium [W]",\
 "coo.hex.Q1_flow", 1, 5, 656, 1024)
DeclareAlias2("coo.hex.bal1.vol.hOut", "Leaving specific enthalpy of the component [J/kg]",\
 "coo.hex.bal1.hOut", 1, 5, 723, 1024)
DeclareVariable("coo.hex.bal1.vol.use_m_flowInv", "Flag, true if m_flowInv is used in the model [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,2563)
DeclareVariable("coo.hex.bal1.vol.m_flowInv", "Regularization of 1/m_flow of port_a [s/kg]",\
 0.0, 0.0,0.0,0.0,0,2560)
DeclareVariable("coo.hex.bal1.vol.deltaReg", "Smoothing region for inverseXRegularized",\
 5.0000000000000004E-08, 0.0,0.0,0.0,0,2561)
DeclareVariable("coo.hex.bal1.vol.deltaInvReg", "Inverse value of delta for inverseXRegularized",\
 20000000.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("coo.hex.bal1.vol.aReg", "Polynomial coefficient for inverseXRegularized",\
 -300000000.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("coo.hex.bal1.vol.bReg", "Polynomial coefficient for inverseXRegularized",\
 4.76E+16, 0.0,0.0,0.0,0,2561)
DeclareVariable("coo.hex.bal1.vol.cReg", "Polynomial coefficient for inverseXRegularized",\
 -2.888E+24, 0.0,0.0,0.0,0,2561)
DeclareVariable("coo.hex.bal1.vol.dReg", "Polynomial coefficient for inverseXRegularized",\
 8.544E+31, 0.0,0.0,0.0,0,2561)
DeclareVariable("coo.hex.bal1.vol.eReg", "Polynomial coefficient for inverseXRegularized",\
 -1.216E+39, 0.0,0.0,0.0,0,2561)
DeclareVariable("coo.hex.bal1.vol.fReg", "Polynomial coefficient for inverseXRegularized",\
 6.656E+45, 0.0,0.0,0.0,0,2561)
DeclareVariable("_GlobalScope.Modelica.Media.Interfaces.PartialPureSubstance.X_default_Unique10[1]",\
 "Default value for mass fractions of medium (for initialization) [kg/kg]", 1, \
0.0,1.0,0.1,0,2561)
DeclareVariable("coo.hex.bal1.vol.state_default.p", "Absolute pressure of medium [Pa|bar]",\
 300000.0, 0.0,100000000.0,100000.0,0,2561)
DeclareVariable("coo.hex.bal1.vol.state_default.T", "Temperature of medium [K|degC]",\
 293.15, 1.0,10000.0,300.0,0,2561)
DeclareVariable("coo.hex.bal1.vol.cp_default", "Specific heat capacity, used to verify energy conservation [J/(kg.K)]",\
 4184, 0.0,0.0,0.0,0,2561)
DeclareVariable("coo.hex.bal1.vol.dTMax", "Maximum temperature difference across the StaticTwoPortConservationEquation [K,]",\
 200, 1.0,1E+100,0.0,0,2561)
DeclareVariable("coo.hex.bal1.vol.mWat_flow_internal", "Needed to connect to conditional connector [kg/s]",\
 0, 0.0,0.0,0.0,0,2561)
DeclareVariable("coo.hex.bal1.preDro.allowFlowReversal", "= false to simplify equations, assuming, but not enforcing, no flow reversal [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,2563)
DeclareAlias2("coo.hex.bal1.preDro.port_a.m_flow", "Mass flow rate from the connection point into the component [kg/s]",\
 "coo.port_a1.m_flow", 1, 5, 612, 1156)
DeclareAlias2("coo.hex.bal1.preDro.port_a.p", "Thermodynamic pressure in the connection point [Pa|bar]",\
 "coo.hex.port_a1.p", 1, 5, 631, 1028)
DeclareAlias2("coo.hex.bal1.preDro.port_a.h_outflow", "Specific thermodynamic enthalpy close to the connection point if m_flow < 0 [J/kg]",\
 "coo.port_a1.h_outflow", 1, 5, 613, 1028)
DeclareAlias2("coo.hex.bal1.preDro.port_b.m_flow", "Mass flow rate from the connection point into the component [kg/s]",\
 "coo.port_a1.m_flow", -1, 5, 612, 1156)
DeclareAlias2("coo.hex.bal1.preDro.port_b.p", "Thermodynamic pressure in the connection point [Pa|bar]",\
 "sinDis.p", 1, 7, 316, 1028)
DeclareAlias2("coo.hex.bal1.preDro.port_b.h_outflow", "Specific thermodynamic enthalpy close to the connection point if m_flow < 0 [J/kg]",\
 "souDis.ports[1].h_outflow", 1, 5, 988, 1028)
DeclareVariable("coo.hex.bal1.preDro.m_flow_nominal", "Nominal mass flow rate [kg/s]",\
 0.5, 0.0,0.0,0.0,0,2561)
DeclareVariable("coo.hex.bal1.preDro.m_flow_small", "Small mass flow rate for regularization of zero flow [kg/s]",\
 5E-05, 0.0,1E+100,0.0,0,2561)
DeclareVariable("coo.hex.bal1.preDro.show_T", "= true, if actual temperature at port is computed [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,2563)
DeclareAlias2("coo.hex.bal1.preDro.m_flow", "Mass flow rate from port_a to port_b (m_flow > 0 is design flow direction) [kg/s]",\
 "coo.port_a1.m_flow", 1, 5, 612, 1024)
DeclareVariable("coo.hex.bal1.preDro.dp", "Pressure difference between port_a and port_b [Pa|Pa]",\
 0, 0.0,0.0,1000.0,0,2560)
DeclareVariable("coo.hex.bal1.preDro._m_flow_start", "Start value for m_flow, used to avoid a warning if not set in m_flow, and to avoid m_flow.start in parameter window [kg/s]",\
 0, 0.0,0.0,0.0,0,2561)
DeclareVariable("coo.hex.bal1.preDro._dp_start", "Start value for dp, used to avoid a warning if not set in dp, and to avoid dp.start in parameter window [Pa|Pa]",\
 0, 0.0,0.0,0.0,0,2561)
DeclareVariable("coo.hex.bal1.preDro.from_dp", "= true, use m_flow = f(dp) else dp = f(m_flow) [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,2563)
DeclareVariable("coo.hex.bal1.preDro.dp_nominal", "Pressure drop at nominal mass flow rate [Pa|Pa]",\
 1000, 0.0,0.0,0.0,0,2561)
DeclareVariable("coo.hex.bal1.preDro.homotopyInitialization", "= true, use homotopy method [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,2563)
DeclareVariable("coo.hex.bal1.preDro.linearized", "= true, use linear relation between m_flow and dp for any flow rate [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,2563)
DeclareVariable("coo.hex.bal1.preDro.m_flow_turbulent", "Turbulent flow if |m_flow| >= m_flow_turbulent [kg/s]",\
 0.05, 0.0,1E+100,0.0,0,2561)
DeclareParameter("coo.hex.bal1.preDro.sta_default.p", "Absolute pressure of medium [Pa|bar]",\
 259, 300000.0, 0.0,100000000.0,100000.0,0,2608)
DeclareParameter("coo.hex.bal1.preDro.sta_default.T", "Temperature of medium [K|degC]",\
 260, 293.15, 1.0,10000.0,300.0,0,2608)
DeclareVariable("coo.hex.bal1.preDro.eta_default", "Dynamic viscosity, used to compute transition to turbulent flow regime [Pa.s]",\
 0.001, 0.0,1E+100,0.0,0,2561)
DeclareVariable("coo.hex.bal1.preDro.m_flow_nominal_pos", "Absolute value of nominal flow rate [kg/s]",\
 0.5, 0.0,0.0,0.0,0,2561)
DeclareVariable("coo.hex.bal1.preDro.dp_nominal_pos", "Absolute value of nominal pressure difference [Pa|Pa]",\
 1000, 0.0,0.0,0.0,0,2561)
DeclareVariable("coo.hex.bal1.preDro.deltaM", "Fraction of nominal mass flow rate where transition to turbulent occurs",\
 0.1, 1E-06,1E+100,0.0,0,2561)
DeclareVariable("coo.hex.bal1.preDro.k", "Flow coefficient, k=m_flow/sqrt(dp), with unit=(kg.m)^(1/2)",\
 0.015811388300841896, 0.0,0.0,0.0,0,2561)
DeclareVariable("coo.hex.bal1.preDro.computeFlowResistance", "Flag to enable/disable computation of flow resistance [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,2563)
DeclareVariable("coo.hex.bal1.preDro.coeff", "Precomputed coefficient to avoid division by parameter",\
 0, 0.0,0.0,0.0,0,2561)
DeclareVariable("coo.hex.bal1.hOut", "Leaving temperature of the component [J/kg]",\
 83680.0, 0.0,0.0,0.0,0,2560)
DeclareAlias2("coo.hex.bal1.heaInp.y", "Value of Real output", "coo.hex.Q1_flow", 1,\
 5, 656, 1024)
DeclareVariable("coo.hex.bal1.masExc.y", "Value of Real output", 0.0, 0.0,0.0,\
0.0,0,2561)
DeclareVariable("coo.hex.bal2.allowFlowReversal", "= false to simplify equations, assuming, but not enforcing, no flow reversal [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,2563)
DeclareAlias2("coo.hex.bal2.port_a.m_flow", "Mass flow rate from the connection point into the component [kg/s]",\
 "coo.port_a2.m_flow", 1, 5, 615, 1156)
DeclareAlias2("coo.hex.bal2.port_a.p", "Thermodynamic pressure in the connection point [Pa|bar]",\
 "coo.port_a2.p", 1, 5, 616, 1028)
DeclareAlias2("coo.hex.bal2.port_a.h_outflow", "Specific thermodynamic enthalpy close to the connection point if m_flow < 0 [J/kg]",\
 "coo.port_a2.h_outflow", 1, 5, 617, 1028)
DeclareAlias2("coo.hex.bal2.port_b.m_flow", "Mass flow rate from the connection point into the component [kg/s]",\
 "coo.port_a2.m_flow", -1, 5, 615, 1156)
DeclareAlias2("coo.hex.bal2.port_b.p", "Thermodynamic pressure in the connection point [Pa|bar]",\
 "exp.p_start", 1, 7, 345, 1028)
DeclareAlias2("coo.hex.bal2.port_b.h_outflow", "Specific thermodynamic enthalpy close to the connection point if m_flow < 0 [J/kg]",\
 "coo.port_b2.h_outflow", 1, 5, 618, 1028)
DeclareVariable("coo.hex.bal2.m_flow_nominal", "Nominal mass flow rate [kg/s]", \
0.5, 0.0,0.0,0.0,0,2561)
DeclareVariable("coo.hex.bal2.m_flow_small", "Small mass flow rate for regularization of zero flow [kg/s]",\
 5E-05, 0.0,1E+100,0.0,0,2561)
DeclareVariable("coo.hex.bal2.show_T", "= true, if actual temperature at port is computed [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,2563)
DeclareAlias2("coo.hex.bal2.m_flow", "Mass flow rate from port_a to port_b (m_flow > 0 is design flow direction) [kg/s]",\
 "coo.port_a2.m_flow", 1, 5, 615, 1024)
DeclareVariable("coo.hex.bal2.dp", "Pressure difference between port_a and port_b [Pa|Pa]",\
 0, 0.0,0.0,0.0,0,2560)
DeclareVariable("coo.hex.bal2._m_flow_start", "Start value for m_flow, used to avoid a warning if not set in m_flow, and to avoid m_flow.start in parameter window [kg/s]",\
 0, 0.0,0.0,0.0,0,2561)
DeclareVariable("coo.hex.bal2._dp_start", "Start value for dp, used to avoid a warning if not set in dp, and to avoid dp.start in parameter window [Pa|Pa]",\
 0, 0.0,0.0,0.0,0,2561)
DeclareVariable("coo.hex.bal2.computeFlowResistance", "=true, compute flow resistance. Set to false to assume no friction [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,2563)
DeclareVariable("coo.hex.bal2.from_dp", "= true, use m_flow = f(dp) else dp = f(m_flow) [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,2563)
DeclareVariable("coo.hex.bal2.dp_nominal", "Pressure difference [Pa|Pa]", 500, \
0.0,1E+100,0.0,0,2561)
DeclareVariable("coo.hex.bal2.linearizeFlowResistance", "= true, use linear relation between m_flow and dp for any flow rate [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,2563)
DeclareVariable("coo.hex.bal2.deltaM", "Fraction of nominal flow rate where flow transitions to laminar",\
 0.1, 0.0,0.0,0.0,0,2561)
DeclareVariable("coo.hex.bal2.sensibleOnly", "Set to true if sensible exchange only [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,2563)
DeclareVariable("coo.hex.bal2.prescribedHeatFlowRate", "Set to true if the heat flow rate is not a function of the component temperature [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,2563)
DeclareVariable("coo.hex.bal2.homotopyInitialization", "= true, use homotopy method [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,2563)
DeclareAlias2("coo.hex.bal2.Q_flow", "Heat transferred into the medium [W]", \
"coo.hex.Q1_flow", -1, 5, 656, 1024)
DeclareVariable("coo.hex.bal2.mWat_flow", "Moisture mass flow rate added to the medium [kg/s]",\
 0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("coo.hex.bal2.vol.allowFlowReversal", "= false to simplify equations, assuming, but not enforcing, no flow reversal [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,2563)
DeclareAlias2("coo.hex.bal2.vol.port_a.m_flow", "Mass flow rate from the connection point into the component [kg/s]",\
 "coo.port_a2.m_flow", 1, 5, 615, 1156)
DeclareAlias2("coo.hex.bal2.vol.port_a.p", "Thermodynamic pressure in the connection point [Pa|bar]",\
 "exp.p_start", 1, 7, 345, 1028)
DeclareAlias2("coo.hex.bal2.vol.port_a.h_outflow", "Specific thermodynamic enthalpy close to the connection point if m_flow < 0 [J/kg]",\
 "coo.port_a2.h_outflow", 1, 5, 617, 1028)
DeclareAlias2("coo.hex.bal2.vol.port_b.m_flow", "Mass flow rate from the connection point into the component [kg/s]",\
 "coo.port_a2.m_flow", -1, 5, 615, 1156)
DeclareAlias2("coo.hex.bal2.vol.port_b.p", "Thermodynamic pressure in the connection point [Pa|bar]",\
 "exp.p_start", 1, 7, 345, 1028)
DeclareAlias2("coo.hex.bal2.vol.port_b.h_outflow", "Specific thermodynamic enthalpy close to the connection point if m_flow < 0 [J/kg]",\
 "coo.port_b2.h_outflow", 1, 5, 618, 1028)
DeclareVariable("coo.hex.bal2.vol.m_flow_nominal", "Nominal mass flow rate [kg/s]",\
 0.5, 0.0,0.0,0.0,0,2561)
DeclareVariable("coo.hex.bal2.vol.m_flow_small", "Small mass flow rate for regularization of zero flow [kg/s]",\
 5E-05, 0.0,1E+100,0.0,0,2561)
DeclareVariable("coo.hex.bal2.vol.show_T", "= true, if actual temperature at port is computed [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,2563)
DeclareAlias2("coo.hex.bal2.vol.m_flow", "Mass flow rate from port_a to port_b (m_flow > 0 is design flow direction) [kg/s]",\
 "coo.port_a2.m_flow", 1, 5, 615, 1024)
DeclareVariable("coo.hex.bal2.vol.dp", "Pressure difference between port_a and port_b [Pa|Pa]",\
 0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("coo.hex.bal2.vol._m_flow_start", "Start value for m_flow, used to avoid a warning if not set in m_flow, and to avoid m_flow.start in parameter window [kg/s]",\
 0, 0.0,0.0,0.0,0,2561)
DeclareVariable("coo.hex.bal2.vol._dp_start", "Start value for dp, used to avoid a warning if not set in dp, and to avoid dp.start in parameter window [Pa|Pa]",\
 0, 0.0,0.0,0.0,0,2561)
DeclareVariable("coo.hex.bal2.vol.simplify_mWat_flow", "Set to true to cause port_a.m_flow + port_b.m_flow = 0 even if mWat_flow is non-zero [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,2563)
DeclareVariable("coo.hex.bal2.vol.prescribedHeatFlowRate", "Set to true if the heat flow rate is not a function of a temperature difference to the fluid temperature [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,2563)
DeclareVariable("coo.hex.bal2.vol.use_mWat_flow", "Set to true to enable input connector for moisture mass flow rate [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,2563)
DeclareVariable("coo.hex.bal2.vol.use_C_flow", "Set to true to enable input connector for trace substance [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,2563)
DeclareAlias2("coo.hex.bal2.vol.Q_flow", "Sensible plus latent heat flow rate transferred into the medium [W]",\
 "coo.hex.Q1_flow", -1, 5, 656, 1024)
DeclareAlias2("coo.hex.bal2.vol.hOut", "Leaving specific enthalpy of the component [J/kg]",\
 "coo.hex.bal2.hOut", 1, 5, 786, 1024)
DeclareVariable("coo.hex.bal2.vol.use_m_flowInv", "Flag, true if m_flowInv is used in the model [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,2563)
DeclareVariable("coo.hex.bal2.vol.m_flowInv", "Regularization of 1/m_flow of port_a [s/kg]",\
 0.0, 0.0,0.0,0.0,0,2560)
DeclareVariable("coo.hex.bal2.vol.deltaReg", "Smoothing region for inverseXRegularized",\
 5.0000000000000004E-08, 0.0,0.0,0.0,0,2561)
DeclareVariable("coo.hex.bal2.vol.deltaInvReg", "Inverse value of delta for inverseXRegularized",\
 20000000.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("coo.hex.bal2.vol.aReg", "Polynomial coefficient for inverseXRegularized",\
 -300000000.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("coo.hex.bal2.vol.bReg", "Polynomial coefficient for inverseXRegularized",\
 4.76E+16, 0.0,0.0,0.0,0,2561)
DeclareVariable("coo.hex.bal2.vol.cReg", "Polynomial coefficient for inverseXRegularized",\
 -2.888E+24, 0.0,0.0,0.0,0,2561)
DeclareVariable("coo.hex.bal2.vol.dReg", "Polynomial coefficient for inverseXRegularized",\
 8.544E+31, 0.0,0.0,0.0,0,2561)
DeclareVariable("coo.hex.bal2.vol.eReg", "Polynomial coefficient for inverseXRegularized",\
 -1.216E+39, 0.0,0.0,0.0,0,2561)
DeclareVariable("coo.hex.bal2.vol.fReg", "Polynomial coefficient for inverseXRegularized",\
 6.656E+45, 0.0,0.0,0.0,0,2561)
DeclareVariable("coo.hex.bal2.vol.state_default.p", "Absolute pressure of medium [Pa|bar]",\
 300000.0, 0.0,100000000.0,100000.0,0,2561)
DeclareVariable("coo.hex.bal2.vol.state_default.T", "Temperature of medium [K|degC]",\
 293.15, 1.0,10000.0,300.0,0,2561)
DeclareVariable("coo.hex.bal2.vol.cp_default", "Specific heat capacity, used to verify energy conservation [J/(kg.K)]",\
 4184, 0.0,0.0,0.0,0,2561)
DeclareVariable("coo.hex.bal2.vol.dTMax", "Maximum temperature difference across the StaticTwoPortConservationEquation [K,]",\
 200, 1.0,1E+100,0.0,0,2561)
DeclareVariable("coo.hex.bal2.vol.mWat_flow_internal", "Needed to connect to conditional connector [kg/s]",\
 0, 0.0,0.0,0.0,0,2561)
DeclareVariable("coo.hex.bal2.preDro.allowFlowReversal", "= false to simplify equations, assuming, but not enforcing, no flow reversal [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,2563)
DeclareAlias2("coo.hex.bal2.preDro.port_a.m_flow", "Mass flow rate from the connection point into the component [kg/s]",\
 "coo.port_a2.m_flow", 1, 5, 615, 1156)
DeclareAlias2("coo.hex.bal2.preDro.port_a.p", "Thermodynamic pressure in the connection point [Pa|bar]",\
 "coo.port_a2.p", 1, 5, 616, 1028)
DeclareAlias2("coo.hex.bal2.preDro.port_a.h_outflow", "Specific thermodynamic enthalpy close to the connection point if m_flow < 0 [J/kg]",\
 "coo.port_a2.h_outflow", 1, 5, 617, 1028)
DeclareAlias2("coo.hex.bal2.preDro.port_b.m_flow", "Mass flow rate from the connection point into the component [kg/s]",\
 "coo.port_a2.m_flow", -1, 5, 615, 1156)
DeclareAlias2("coo.hex.bal2.preDro.port_b.p", "Thermodynamic pressure in the connection point [Pa|bar]",\
 "exp.p_start", 1, 7, 345, 1028)
DeclareAlias2("coo.hex.bal2.preDro.port_b.h_outflow", "Specific thermodynamic enthalpy close to the connection point if m_flow < 0 [J/kg]",\
 "CoolingUnit.port_a.h_outflow", 1, 5, 1251, 1028)
DeclareVariable("coo.hex.bal2.preDro.m_flow_nominal", "Nominal mass flow rate [kg/s]",\
 0.5, 0.0,0.0,0.0,0,2561)
DeclareVariable("coo.hex.bal2.preDro.m_flow_small", "Small mass flow rate for regularization of zero flow [kg/s]",\
 5E-05, 0.0,1E+100,0.0,0,2561)
DeclareVariable("coo.hex.bal2.preDro.show_T", "= true, if actual temperature at port is computed [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,2563)
DeclareAlias2("coo.hex.bal2.preDro.m_flow", "Mass flow rate from port_a to port_b (m_flow > 0 is design flow direction) [kg/s]",\
 "coo.port_a2.m_flow", 1, 5, 615, 1024)
DeclareVariable("coo.hex.bal2.preDro.dp", "Pressure difference between port_a and port_b [Pa|Pa]",\
 0, 0.0,0.0,500.0,0,2560)
DeclareVariable("coo.hex.bal2.preDro._m_flow_start", "Start value for m_flow, used to avoid a warning if not set in m_flow, and to avoid m_flow.start in parameter window [kg/s]",\
 0, 0.0,0.0,0.0,0,2561)
DeclareVariable("coo.hex.bal2.preDro._dp_start", "Start value for dp, used to avoid a warning if not set in dp, and to avoid dp.start in parameter window [Pa|Pa]",\
 0, 0.0,0.0,0.0,0,2561)
DeclareVariable("coo.hex.bal2.preDro.from_dp", "= true, use m_flow = f(dp) else dp = f(m_flow) [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,2563)
DeclareVariable("coo.hex.bal2.preDro.dp_nominal", "Pressure drop at nominal mass flow rate [Pa|Pa]",\
 500, 0.0,0.0,0.0,0,2561)
DeclareVariable("coo.hex.bal2.preDro.homotopyInitialization", "= true, use homotopy method [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,2563)
DeclareVariable("coo.hex.bal2.preDro.linearized", "= true, use linear relation between m_flow and dp for any flow rate [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,2563)
DeclareVariable("coo.hex.bal2.preDro.m_flow_turbulent", "Turbulent flow if |m_flow| >= m_flow_turbulent [kg/s]",\
 0.05, 0.0,1E+100,0.0,0,2561)
DeclareParameter("coo.hex.bal2.preDro.sta_default.p", "Absolute pressure of medium [Pa|bar]",\
 261, 300000.0, 0.0,100000000.0,100000.0,0,2608)
DeclareParameter("coo.hex.bal2.preDro.sta_default.T", "Temperature of medium [K|degC]",\
 262, 293.15, 1.0,10000.0,300.0,0,2608)
DeclareVariable("coo.hex.bal2.preDro.eta_default", "Dynamic viscosity, used to compute transition to turbulent flow regime [Pa.s]",\
 0.001, 0.0,1E+100,0.0,0,2561)
DeclareVariable("coo.hex.bal2.preDro.m_flow_nominal_pos", "Absolute value of nominal flow rate [kg/s]",\
 0.5, 0.0,0.0,0.0,0,2561)
DeclareVariable("coo.hex.bal2.preDro.dp_nominal_pos", "Absolute value of nominal pressure difference [Pa|Pa]",\
 500, 0.0,0.0,0.0,0,2561)
DeclareVariable("coo.hex.bal2.preDro.deltaM", "Fraction of nominal mass flow rate where transition to turbulent occurs",\
 0.1, 1E-06,1E+100,0.0,0,2561)
DeclareVariable("coo.hex.bal2.preDro.k", "Flow coefficient, k=m_flow/sqrt(dp), with unit=(kg.m)^(1/2)",\
 0.022360679774997897, 0.0,0.0,0.0,0,2561)
DeclareVariable("coo.hex.bal2.preDro.computeFlowResistance", "Flag to enable/disable computation of flow resistance [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,2563)
DeclareVariable("coo.hex.bal2.preDro.coeff", "Precomputed coefficient to avoid division by parameter",\
 0, 0.0,0.0,0.0,0,2561)
DeclareVariable("coo.hex.bal2.hOut", "Leaving temperature of the component [J/kg]",\
 83680.0, 0.0,0.0,0.0,0,2560)
DeclareAlias2("coo.hex.bal2.heaInp.y", "Value of Real output", "coo.hex.Q1_flow", -1,\
 5, 656, 1024)
DeclareVariable("coo.hex.bal2.masExc.y", "Value of Real output", 0.0, 0.0,0.0,\
0.0,0,2561)
DeclareVariable("coo.hex.T_in1", "Inlet temperature medium 1 [K|degC]", 293.15, \
1.0,10000.0,300.0,0,512)
DeclareVariable("coo.hex.T_in2", "Inlet temperature medium 2 [K|degC]", 293.15, \
1.0,10000.0,300.0,0,512)
DeclareVariable("coo.hex.C1_flow", "Heat capacity flow rate medium 1 [W/K]", 0.0,\
 0.0,0.0,0.0,0,512)
DeclareVariable("coo.hex.C2_flow", "Heat capacity flow rate medium 2 [W/K]", 0.0,\
 0.0,0.0,0.0,0,512)
DeclareVariable("coo.hex.CMin_flow", "Minimum heat capacity flow rate [W/K]", \
0.0, 0.0,1E+100,0.0,0,512)
DeclareVariable("coo.hex.QMax_flow", "Maximum heat flow rate into medium 1 [W]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareParameter("coo.hex.delta", "Parameter used for smoothing", 263, 0.001, \
0.0,0.0,0.0,0,2608)
DeclareVariable("coo.hex.cp1_default", "Specific heat capacity of medium 1 at default medium state [J/(kg.K)]",\
 0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("coo.hex.cp2_default", "Specific heat capacity of medium 2 at default medium state [J/(kg.K)]",\
 0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("coo.hex.CMin_flow_small", "Small value for smoothing of minimum heat capacity flow rate [W/K]",\
 0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("coo.hex.fra_a1", "Fraction of incoming state taken from port a2 (used to avoid excessive calls to regStep)",\
 0.0, 0.0,1.0,0.0,0,2560)
DeclareVariable("coo.hex.fra_b1", "Fraction of incoming state taken from port b2 (used to avoid excessive calls to regStep)",\
 0.0, 0.0,1.0,0.0,0,2560)
DeclareVariable("coo.hex.fra_a2", "Fraction of incoming state taken from port a2 (used to avoid excessive calls to regStep)",\
 0.0, 0.0,1.0,0.0,0,2560)
DeclareVariable("coo.hex.fra_b2", "Fraction of incoming state taken from port b2 (used to avoid excessive calls to regStep)",\
 0.0, 0.0,1.0,0.0,0,2560)
DeclareVariable("coo.hex.configuration", "Heat exchanger configuration [:#(type=Buildings.Fluid.Types.HeatExchangerConfiguration)]",\
 2, 1.0,6.0,0.0,0,517)
DeclareVariable("coo.hex.use_Q_flow_nominal", "Set to true to specify Q_flow_nominal and temperatures, or to false to specify effectiveness [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,515)
DeclareVariable("coo.hex.Q_flow_nominal", "Nominal heat transfer [W]", 0.0, \
0.0,0.0,0.0,0,513)
DeclareVariable("coo.hex.T_a1_nominal", "Nominal temperature at port a1 [K|degC]",\
 288.15, 0.0,1E+100,300.0,0,513)
DeclareVariable("coo.hex.T_a2_nominal", "Nominal temperature at port a2 [K|degC]",\
 288.15, 0.0,1E+100,300.0,0,513)
DeclareVariable("coo.hex.eps_nominal", "Nominal heat transfer effectiveness", \
0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("coo.hex.UA", "UA value [W/K]", 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("coo.hex.eps", "Heat exchanger effectiveness", 0.0, 0.0,1.0,0.0,\
0,512)
DeclareVariable("coo.hex.UA_nominal", "Nominal UA value [W/K]", 0.0, 0.0,0.0,0.0,\
0,513)
DeclareVariable("coo.hex.NTU_nominal", "Nominal number of transfer units", 0.0, \
0.0,1E+100,0.0,0,513)
DeclareVariable("coo.hex.sta1_default.p", "Absolute pressure of medium [Pa|bar]",\
 300000.0, 0.0,100000000.0,100000.0,0,2561)
DeclareVariable("coo.hex.sta1_default.T", "Temperature of medium [K|degC]", \
293.15, 1.0,10000.0,300.0,0,2561)
DeclareVariable("coo.hex.sta2_default.p", "Absolute pressure of medium [Pa|bar]",\
 300000.0, 0.0,100000000.0,100000.0,0,2561)
DeclareVariable("coo.hex.sta2_default.T", "Temperature of medium [K|degC]", \
293.15, 1.0,10000.0,300.0,0,2561)
DeclareVariable("coo.hex.cp1_nominal", "Specific heat capacity of medium 1 at nominal condition [J/(kg.K)]",\
 0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("coo.hex.cp2_nominal", "Specific heat capacity of medium 2 at nominal condition [J/(kg.K)]",\
 0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("coo.hex.C1_flow_nominal", "Nominal capacity flow rate of Medium 1 [W/K]",\
 0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("coo.hex.C2_flow_nominal", "Nominal capacity flow rate of Medium 2 [W/K]",\
 0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("coo.hex.CMin_flow_nominal", "Minimal capacity flow rate at nominal condition [W/K]",\
 0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("coo.hex.CMax_flow_nominal", "Maximum capacity flow rate at nominal condition [W/K]",\
 0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("coo.hex.Z_nominal", "Ratio of capacity flow rate at nominal condition",\
 0.0, 0.0,1.0,0.0,0,2561)
DeclareVariable("coo.hex.T_b1_nominal", "Nominal temperature at port b1 [K|degC]",\
 288.15, 0.0,1E+100,300.0,0,2561)
DeclareVariable("coo.hex.T_b2_nominal", "Nominal temperature at port b2 [K|degC]",\
 288.15, 0.0,1E+100,300.0,0,2561)
DeclareVariable("coo.hex.flowRegime_nominal", "Heat exchanger flow regime at nominal flow rates [:#(type=Buildings.Fluid.Types.HeatExchangerFlowRegime)]",\
 1, 1.0,6.0,0.0,0,2565)
DeclareVariable("coo.hex.flowRegime", "Heat exchanger flow regime [:#(type=Buildings.Fluid.Types.HeatExchangerFlowRegime)]",\
 1, 1.0,6.0,0.0,0,2692)
DeclareVariable("coo.hex.hA1_nominal", "Nominal convective heat transfer coefficient for medium 1 [W/K]",\
 0.0, 0.0,1E+100,0.0,0,2561)
DeclareVariable("coo.hex.hA2_nominal", "Nominal convective heat transfer coefficient for medium 2 [W/K]",\
 0.0, 0.0,1E+100,0.0,0,2561)
DeclareParameter("coo.hex.n1", "Exponent for convective heat transfer coefficient, h1~m1_flow^n1",\
 264, 0.8, 0.0,1.0,0.0,0,2608)
DeclareParameter("coo.hex.n2", "Exponent for convective heat transfer coefficient, h2~m2_flow^n2",\
 265, 0.8, 0.0,1.0,0.0,0,2608)
DeclareVariable("coo.hex.hA1", "Convective heat transfer coefficient for medium 1 [W/K]",\
 0.0, 0.0,0.0,0.0,0,2560)
DeclareVariable("coo.hex.hA2", "Convective heat transfer coefficient for medium 2 [W/K]",\
 0.0, 0.0,0.0,0.0,0,2560)
DeclareAlias2("coo.con.u_s", "Connector of setpoint input signal", "TSetCHWS.k", 1,\
 7, 297, 0)
DeclareAlias2("coo.con.u_m", "Connector of measurement input signal", \
"coo.TBuiRet.T", 1, 1, 3, 0)
DeclareVariable("coo.con.y", "Connector of actuator output signal", 0.0, 0.0,1.0,\
0.0,0,512)
DeclareVariable("coo.con.controlError", "Control error (set point - measurement)",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("coo.con.controllerType", "Type of controller [:#(type=Modelica.Blocks.Types.SimpleController)]",\
 4, 1.0,4.0,0.0,0,517)
DeclareVariable("coo.con.k", "Gain of controller [1]", 0.0, 0.0,1E+100,0.0,0,513)
DeclareVariable("coo.con.Ti", "Time constant of Integrator block [s]", 1E-60, \
1E-60,1E+100,0.0,0,513)
DeclareVariable("coo.con.Td", "Time constant of Derivative block [s]", 0.0, 0.0,\
1E+100,0.0,0,513)
DeclareVariable("coo.con.yMax", "Upper limit of output", 1, 0.0,0.0,0.0,0,513)
DeclareVariable("coo.con.yMin", "Lower limit of output", 0, 0.0,0.0,0.0,0,513)
DeclareVariable("coo.con.wp", "Set-point weight for Proportional block (0..1)", \
0.0, 0.0,1E+100,0.0,0,513)
DeclareVariable("coo.con.wd", "Set-point weight for Derivative block (0..1)", \
0.0, 0.0,1E+100,0.0,0,513)
DeclareVariable("coo.con.Ni", "Ni*Ti is time constant of anti-windup compensation",\
 1E-13, 1E-13,1E+100,0.0,0,513)
DeclareVariable("coo.con.Nd", "The higher Nd, the more ideal the derivative block",\
 1E-13, 1E-13,1E+100,0.0,0,513)
DeclareVariable("coo.con.initType", "Type of initialization (1: no init, 2: steady state, 3: initial state, 4: initial output) [:#(type=Modelica.Blocks.Types.InitPID)]",\
 4, 1.0,5.0,0.0,0,517)
DeclareVariable("coo.con.xi_start", "Initial or guess value value for integrator output (= integrator state)",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("coo.con.xd_start", "Initial or guess value for state of derivative block",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("coo.con.y_start", "Initial value of output", 0, 0.0,0.0,0.0,0,513)
DeclareVariable("coo.con.strict", "= true, if strict limits with noEvent(..) [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,515)
DeclareVariable("coo.con.reverseAction", "Set to true for throttling the water flow rate through a cooling coil controller [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,515)
DeclareVariable("coo.con.reset", "Type of controller output reset [:#(type=Buildings.Types.Reset)]",\
 1, 1.0,3.0,0.0,0,517)
DeclareVariable("coo.con.y_reset", "Value to which the controller output is reset if the boolean trigger has a rising edge, used if reset == Buildings.Types.Reset.Parameter",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareAlias2("coo.con.addP.u1", "Connector of Real input signal 1", \
"TSetCHWS.k", 1, 7, 297, 0)
DeclareAlias2("coo.con.addP.u2", "Connector of Real input signal 2", \
"coo.TBuiRet.T", 1, 1, 3, 0)
DeclareVariable("coo.con.addP.y", "Connector of Real output signal", 0.0, \
0.0,0.0,0.0,0,512)
DeclareVariable("coo.con.addP.k1", "Gain of upper input", 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("coo.con.addP.k2", "Gain of lower input", 0.0, 0.0,0.0,0.0,0,513)
DeclareParameter("coo.con.P.k", "Gain value multiplied with input signal [1]", 266,\
 1, 0.0,0.0,0.0,0,560)
DeclareAlias2("coo.con.P.u", "Input signal connector", "coo.con.addP.y", 1, 5, 850,\
 0)
DeclareVariable("coo.con.P.y", "Output signal connector", 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("coo.con.addPID.k1", "Gain of upper input", 1, 0.0,0.0,0.0,0,513)
DeclareVariable("coo.con.addPID.k2", "Gain of middle input", 1, 0.0,0.0,0.0,0,513)
DeclareVariable("coo.con.addPID.k3", "Gain of lower input", 1, 0.0,0.0,0.0,0,513)
DeclareAlias2("coo.con.addPID.u1", "Connector 1 of Real input signals", \
"coo.con.P.y", 1, 5, 853, 0)
DeclareVariable("coo.con.addPID.u2", "Connector 2 of Real input signals", 0.0, \
0.0,0.0,0.0,0,512)
DeclareAlias2("coo.con.addPID.u3", "Connector 3 of Real input signals", \
"coo.con.I.y", 1, 1, 18, 0)
DeclareVariable("coo.con.addPID.y", "Connector of Real output signals", 0.0, \
0.0,0.0,0.0,0,512)
DeclareVariable("coo.con.unitTime", "[s]", 1, 0.0,0.0,0.0,0,1537)
DeclareVariable("coo.con.revAct", "Switch for sign for reverse action", 0.0, \
0.0,0.0,0.0,0,2561)
DeclareVariable("coo.con.with_I", "Boolean flag to enable integral action [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,1539)
DeclareVariable("coo.con.with_D", "Boolean flag to enable derivative action [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,1539)
DeclareVariable("coo.con.y_reset_internal", "Internal connector for controller output reset",\
 0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("coo.con.addI.k1", "Gain of upper input", 0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("coo.con.addI.k2", "Gain of middle input", 0.0, 0.0,0.0,0.0,0,2561)
DeclareParameter("coo.con.addI.k3", "Gain of lower input", 267, 1, 0.0,0.0,0.0,0,2608)
DeclareAlias2("coo.con.addI.u1", "Connector 1 of Real input signals", \
"TSetCHWS.k", 1, 7, 297, 1024)
DeclareAlias2("coo.con.addI.u2", "Connector 2 of Real input signals", \
"coo.TBuiRet.T", 1, 1, 3, 1024)
DeclareVariable("coo.con.addI.u3", "Connector 3 of Real input signals", 0.0, \
0.0,0.0,0.0,0,2560)
DeclareVariable("coo.con.addI.y", "Connector of Real output signals", 0.0, \
0.0,0.0,0.0,0,2560)
DeclareAlias2("coo.con.addSat.u1", "Connector of Real input signal 1", \
"coo.con.y", 1, 5, 830, 1024)
DeclareAlias2("coo.con.addSat.u2", "Connector of Real input signal 2", \
"coo.con.gainPID.y", 1, 5, 872, 1024)
DeclareVariable("coo.con.addSat.y", "Connector of Real output signal", 0.0, \
0.0,0.0,0.0,0,2560)
DeclareVariable("coo.con.addSat.k1", "Gain of upper input", 1, 0.0,0.0,0.0,0,2561)
DeclareVariable("coo.con.addSat.k2", "Gain of lower input", -1, 0.0,0.0,0.0,0,2561)
DeclareVariable("coo.con.gainPID.k", "Gain value multiplied with input signal [1]",\
 1, 0.0,0.0,0.0,0,2561)
DeclareAlias2("coo.con.gainPID.u", "Input signal connector", "coo.con.addPID.y", 1,\
 5, 858, 1024)
DeclareVariable("coo.con.gainPID.y", "Output signal connector", 0.0, 0.0,0.0,0.0,\
0,2560)
DeclareVariable("coo.con.gainTrack.k", "Gain value multiplied with input signal [1]",\
 1, 0.0,0.0,0.0,0,2561)
DeclareAlias2("coo.con.gainTrack.u", "Input signal connector", "coo.con.addSat.y", 1,\
 5, 868, 1024)
DeclareAlias2("coo.con.gainTrack.y", "Output signal connector", "coo.con.addI.u3", 1,\
 5, 866, 1024)
DeclareVariable("coo.con.limiter.uMax", "Upper limits of input signals", 1, \
0.0,0.0,0.0,0,2561)
DeclareVariable("coo.con.limiter.uMin", "Lower limits of input signals", 0.0, \
0.0,0.0,0.0,0,2561)
DeclareVariable("coo.con.limiter.strict", "= true, if strict limits with noEvent(..) [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,2563)
DeclareVariable("coo.con.limiter.limitsAtInit", "Has no longer an effect and is only kept for backwards compatibility (the implementation uses now the homotopy operator) [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,2563)
DeclareAlias2("coo.con.limiter.u", "Connector of Real input signal", \
"coo.con.gainPID.y", 1, 5, 872, 1024)
DeclareAlias2("coo.con.limiter.y", "Connector of Real output signal", \
"coo.con.y", 1, 5, 830, 1024)
DeclareVariable("coo.senTDisSup.allowFlowReversal", "= false to simplify equations, assuming, but not enforcing, no flow reversal [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,515)
DeclareAlias2("coo.senTDisSup.port_a.m_flow", "Mass flow rate from the connection point into the component [kg/s]",\
 "coo.port_a1.m_flow", 1, 5, 612, 132)
DeclareAlias2("coo.senTDisSup.port_a.p", "Thermodynamic pressure in the connection point [Pa|bar]",\
 "souDis.p", 1, 7, 307, 4)
DeclareAlias2("coo.senTDisSup.port_a.h_outflow", "Specific thermodynamic enthalpy close to the connection point if m_flow < 0 [J/kg]",\
 "coo.port_a1.h_outflow", 1, 5, 613, 4)
DeclareAlias2("coo.senTDisSup.port_b.m_flow", "Mass flow rate from the connection point into the component [kg/s]",\
 "coo.port_a1.m_flow", -1, 5, 612, 132)
DeclareAlias2("coo.senTDisSup.port_b.p", "Thermodynamic pressure in the connection point [Pa|bar]",\
 "souDis.p", 1, 7, 307, 4)
DeclareAlias2("coo.senTDisSup.port_b.h_outflow", "Specific thermodynamic enthalpy close to the connection point if m_flow < 0 [J/kg]",\
 "souDis.ports[1].h_outflow", 1, 5, 988, 4)
DeclareVariable("coo.senTDisSup.m_flow_nominal", "Nominal mass flow rate, used for regularization near zero flow [kg/s]",\
 0.5, 0.0,1E+100,0.0,0,513)
DeclareVariable("coo.senTDisSup.m_flow_small", "For bi-directional flow, temperature is regularized in the region |m_flow| < m_flow_small (m_flow_small > 0 required) [kg/s]",\
 5E-05, 0.0,1E+100,0.0,0,513)
DeclareVariable("coo.senTDisSup.tau", "Time constant at nominal flow rate (use tau=0 for steady-state sensor, but see user guide for potential problems) [s]",\
 1, 0.0,1E+100,0.0,0,513)
DeclareVariable("coo.senTDisSup.initType", "Type of initialization (InitialState and InitialOutput are identical) [:#(type=Modelica.Blocks.Types.Init)]",\
 3, 1.0,4.0,0.0,0,517)
DeclareVariable("coo.senTDisSup.k", "Gain to take flow rate into account for sensor time constant",\
 1, 0.0,0.0,0.0,0,2560)
DeclareVariable("coo.senTDisSup.dynamic", "Flag, true if the sensor is a dynamic sensor [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,2563)
DeclareVariable("coo.senTDisSup.mNor_flow", "Normalized mass flow rate", 0.0, \
0.0,0.0,0.0,0,2560)
DeclareVariable("coo.senTDisSup.tauInv", "Inverse of tau [s-1]", 1.0, 0.0,0.0,\
0.0,0,2561)
DeclareState("coo.senTDisSup.T", "Temperature of the passing fluid [K|degC]", 0,\
 0.0, 0.0,1E+100,0.0,0,544)
DeclareDerivative("coo.senTDisSup.der(T)", "der(Temperature of the passing fluid) [K/s]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareParameter("coo.senTDisSup.T_start", "Initial or guess value of output (= state) [K|degC]",\
 268, 293.15, 0.0,1E+100,300.0,0,560)
DeclareVariable("coo.senTDisSup.transferHeat", "if true, temperature T converges towards TAmb when no flow [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,515)
DeclareParameter("coo.senTDisSup.TAmb", "Fixed ambient temperature for heat transfer [K|degC]",\
 269, 293.15, 0.0,1E+100,300.0,0,560)
DeclareParameter("coo.senTDisSup.tauHeaTra", "Time constant for heat transfer, default 20 minutes [s]",\
 270, 1200, 1.0,1E+100,0.0,0,560)
DeclareVariable("coo.senTDisSup.tauHeaTraInv", "Dummy parameter to avoid division by tauHeaTra [1/s]",\
 0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("coo.senTDisSup.ratTau", "Ratio of tau", 0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("coo.senTDisSup.TMed", "Medium temperature to which the sensor is exposed [K|degC]",\
 300.0, 1.0,10000.0,300.0,0,2560)
DeclareVariable("coo.senTDisSup.T_a_inflow", "Temperature of inflowing fluid at port_a [K|degC]",\
 293.15, 1.0,10000.0,300.0,0,2560)
DeclareVariable("coo.senTDisSup.T_b_inflow", "Temperature of inflowing fluid at port_b, or T_a_inflow if uni-directional flow [K|degC]",\
 293.15, 1.0,10000.0,300.0,0,2560)
DeclareVariable("coo.senTDisRet.allowFlowReversal", "= false to simplify equations, assuming, but not enforcing, no flow reversal [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,515)
DeclareAlias2("coo.senTDisRet.port_a.m_flow", "Mass flow rate from the connection point into the component [kg/s]",\
 "coo.port_a1.m_flow", 1, 5, 612, 132)
DeclareAlias2("coo.senTDisRet.port_a.p", "Thermodynamic pressure in the connection point [Pa|bar]",\
 "sinDis.p", 1, 7, 316, 4)
DeclareAlias2("coo.senTDisRet.port_a.h_outflow", "Specific thermodynamic enthalpy close to the connection point if m_flow < 0 [J/kg]",\
 "TDisRet.port_a.h_outflow", 1, 5, 1014, 4)
DeclareAlias2("coo.senTDisRet.port_b.m_flow", "Mass flow rate from the connection point into the component [kg/s]",\
 "coo.port_a1.m_flow", -1, 5, 612, 132)
DeclareAlias2("coo.senTDisRet.port_b.p", "Thermodynamic pressure in the connection point [Pa|bar]",\
 "sinDis.p", 1, 7, 316, 4)
DeclareAlias2("coo.senTDisRet.port_b.h_outflow", "Specific thermodynamic enthalpy close to the connection point if m_flow < 0 [J/kg]",\
 "coo.port_b1.h_outflow", 1, 5, 614, 4)
DeclareVariable("coo.senTDisRet.m_flow_nominal", "Nominal mass flow rate, used for regularization near zero flow [kg/s]",\
 0.5, 0.0,1E+100,0.0,0,513)
DeclareVariable("coo.senTDisRet.m_flow_small", "For bi-directional flow, temperature is regularized in the region |m_flow| < m_flow_small (m_flow_small > 0 required) [kg/s]",\
 5E-05, 0.0,1E+100,0.0,0,513)
DeclareVariable("coo.senTDisRet.tau", "Time constant at nominal flow rate (use tau=0 for steady-state sensor, but see user guide for potential problems) [s]",\
 1, 0.0,1E+100,0.0,0,513)
DeclareVariable("coo.senTDisRet.initType", "Type of initialization (InitialState and InitialOutput are identical) [:#(type=Modelica.Blocks.Types.Init)]",\
 3, 1.0,4.0,0.0,0,517)
DeclareVariable("coo.senTDisRet.k", "Gain to take flow rate into account for sensor time constant",\
 1, 0.0,0.0,0.0,0,2560)
DeclareVariable("coo.senTDisRet.dynamic", "Flag, true if the sensor is a dynamic sensor [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,2563)
DeclareVariable("coo.senTDisRet.mNor_flow", "Normalized mass flow rate", 0.0, \
0.0,0.0,0.0,0,2560)
DeclareVariable("coo.senTDisRet.tauInv", "Inverse of tau [s-1]", 1.0, 0.0,0.0,\
0.0,0,2561)
DeclareState("coo.senTDisRet.T", "Temperature of the passing fluid [K|degC]", 1,\
 0.0, 0.0,1E+100,0.0,0,544)
DeclareDerivative("coo.senTDisRet.der(T)", "der(Temperature of the passing fluid) [K/s]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareParameter("coo.senTDisRet.T_start", "Initial or guess value of output (= state) [K|degC]",\
 271, 293.15, 0.0,1E+100,300.0,0,560)
DeclareVariable("coo.senTDisRet.transferHeat", "if true, temperature T converges towards TAmb when no flow [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,515)
DeclareParameter("coo.senTDisRet.TAmb", "Fixed ambient temperature for heat transfer [K|degC]",\
 272, 293.15, 0.0,1E+100,300.0,0,560)
DeclareParameter("coo.senTDisRet.tauHeaTra", "Time constant for heat transfer, default 20 minutes [s]",\
 273, 1200, 1.0,1E+100,0.0,0,560)
DeclareVariable("coo.senTDisRet.tauHeaTraInv", "Dummy parameter to avoid division by tauHeaTra [1/s]",\
 0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("coo.senTDisRet.ratTau", "Ratio of tau", 0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("coo.senTDisRet.TMed", "Medium temperature to which the sensor is exposed [K|degC]",\
 300.0, 1.0,10000.0,300.0,0,2560)
DeclareVariable("coo.senTDisRet.T_a_inflow", "Temperature of inflowing fluid at port_a [K|degC]",\
 293.15, 1.0,10000.0,300.0,0,2560)
DeclareVariable("coo.senTDisRet.T_b_inflow", "Temperature of inflowing fluid at port_b, or T_a_inflow if uni-directional flow [K|degC]",\
 293.15, 1.0,10000.0,300.0,0,2561)
DeclareParameter("coo.int.k", "Integrator gain [1]", 274, 1, 0.0,0.0,0.0,0,560)
DeclareVariable("coo.int.initType", "Type of initialization (1: no init, 2: steady state, 3,4: initial output) [:#(type=Modelica.Blocks.Types.Init)]",\
 3, 1.0,4.0,0.0,0,517)
DeclareParameter("coo.int.y_start", "Initial or guess value of output (= state)",\
 275, 0, 0.0,0.0,0.0,0,560)
DeclareAlias2("coo.int.u", "Connector of Real input signal", "coo.Q_flow", 1, 5,\
 628, 0)
DeclareState("coo.int.y", "Connector of Real output signal", 2, 0.0, 0.0,0.0,0.0,\
0,544)
DeclareDerivative("coo.int.der(y)", "der(Connector of Real output signal)", 0.0,\
 0.0,0.0,0.0,0,512)
DeclareVariable("coo.senMasFlo.allowFlowReversal", "= false to simplify equations, assuming, but not enforcing, no flow reversal [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,515)
DeclareAlias2("coo.senMasFlo.port_a.m_flow", "Mass flow rate from the connection point into the component [kg/s]",\
 "coo.port_a1.m_flow", 1, 5, 612, 132)
DeclareAlias2("coo.senMasFlo.port_a.p", "Thermodynamic pressure in the connection point [Pa|bar]",\
 "souDis.p", 1, 7, 307, 4)
DeclareAlias2("coo.senMasFlo.port_a.h_outflow", "Specific thermodynamic enthalpy close to the connection point if m_flow < 0 [J/kg]",\
 "coo.port_a1.h_outflow", 1, 5, 613, 4)
DeclareAlias2("coo.senMasFlo.port_b.m_flow", "Mass flow rate from the connection point into the component [kg/s]",\
 "coo.port_a1.m_flow", -1, 5, 612, 132)
DeclareAlias2("coo.senMasFlo.port_b.p", "Thermodynamic pressure in the connection point [Pa|bar]",\
 "souDis.p", 1, 7, 307, 4)
DeclareAlias2("coo.senMasFlo.port_b.h_outflow", "Specific thermodynamic enthalpy close to the connection point if m_flow < 0 [J/kg]",\
 "souDis.ports[1].h_outflow", 1, 5, 988, 4)
DeclareVariable("coo.senMasFlo.m_flow_nominal", "Nominal mass flow rate, used for regularization near zero flow [kg/s]",\
 0, 0.0,1E+100,0.0,0,513)
DeclareVariable("coo.senMasFlo.m_flow_small", "For bi-directional flow, temperature is regularized in the region |m_flow| < m_flow_small (m_flow_small > 0 required) [kg/s]",\
 0, 0.0,1E+100,0.0,0,513)
DeclareVariable("_GlobalScope.Modelica.Media.Interfaces.PartialPureSubstance.X_default_Unique16[1]",\
 "Default value for mass fractions of medium (for initialization) [kg/kg]", 1, \
0.0,1.0,0.1,0,2561)
DeclareAlias2("coo.senMasFlo.m_flow", "Mass flow rate from port_a to port_b [kg/s]",\
 "coo.port_a1.m_flow", 1, 5, 612, 0)
DeclareVariable("coo.TBuiRet.allowFlowReversal", "= false to simplify equations, assuming, but not enforcing, no flow reversal [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,515)
DeclareAlias2("coo.TBuiRet.port_a.m_flow", "Mass flow rate from the connection point into the component [kg/s]",\
 "coo.port_a2.m_flow", 1, 5, 615, 132)
DeclareAlias2("coo.TBuiRet.port_a.p", "Thermodynamic pressure in the connection point [Pa|bar]",\
 "exp.p_start", 1, 7, 345, 4)
DeclareAlias2("coo.TBuiRet.port_a.h_outflow", "Specific thermodynamic enthalpy close to the connection point if m_flow < 0 [J/kg]",\
 "exp.port_a.h_outflow", 1, 5, 1246, 4)
DeclareAlias2("coo.TBuiRet.port_b.m_flow", "Mass flow rate from the connection point into the component [kg/s]",\
 "coo.port_a2.m_flow", -1, 5, 615, 132)
DeclareAlias2("coo.TBuiRet.port_b.p", "Thermodynamic pressure in the connection point [Pa|bar]",\
 "exp.p_start", 1, 7, 345, 4)
DeclareAlias2("coo.TBuiRet.port_b.h_outflow", "Specific thermodynamic enthalpy close to the connection point if m_flow < 0 [J/kg]",\
 "coo.port_b2.h_outflow", 1, 5, 618, 4)
DeclareVariable("coo.TBuiRet.m_flow_nominal", "Nominal mass flow rate, used for regularization near zero flow [kg/s]",\
 0.5, 0.0,1E+100,0.0,0,513)
DeclareVariable("coo.TBuiRet.m_flow_small", "For bi-directional flow, temperature is regularized in the region |m_flow| < m_flow_small (m_flow_small > 0 required) [kg/s]",\
 5E-05, 0.0,1E+100,0.0,0,513)
DeclareVariable("coo.TBuiRet.tau", "Time constant at nominal flow rate (use tau=0 for steady-state sensor, but see user guide for potential problems) [s]",\
 1, 0.0,1E+100,0.0,0,513)
DeclareVariable("coo.TBuiRet.initType", "Type of initialization (InitialState and InitialOutput are identical) [:#(type=Modelica.Blocks.Types.Init)]",\
 3, 1.0,4.0,0.0,0,517)
DeclareVariable("coo.TBuiRet.k", "Gain to take flow rate into account for sensor time constant",\
 1, 0.0,0.0,0.0,0,2560)
DeclareVariable("coo.TBuiRet.dynamic", "Flag, true if the sensor is a dynamic sensor [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,2563)
DeclareVariable("coo.TBuiRet.mNor_flow", "Normalized mass flow rate", 0.0, \
0.0,0.0,0.0,0,2560)
DeclareVariable("coo.TBuiRet.tauInv", "Inverse of tau [s-1]", 1.0, 0.0,0.0,0.0,0,2561)
DeclareState("coo.TBuiRet.T", "Temperature of the passing fluid [K|degC]", 3, \
0.0, 0.0,1E+100,0.0,0,544)
DeclareDerivative("coo.TBuiRet.der(T)", "der(Temperature of the passing fluid) [K/s]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareParameter("coo.TBuiRet.T_start", "Initial or guess value of output (= state) [K|degC]",\
 276, 293.15, 0.0,1E+100,300.0,0,560)
DeclareVariable("coo.TBuiRet.transferHeat", "if true, temperature T converges towards TAmb when no flow [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,515)
DeclareParameter("coo.TBuiRet.TAmb", "Fixed ambient temperature for heat transfer [K|degC]",\
 277, 293.15, 0.0,1E+100,300.0,0,560)
DeclareParameter("coo.TBuiRet.tauHeaTra", "Time constant for heat transfer, default 20 minutes [s]",\
 278, 1200, 1.0,1E+100,0.0,0,560)
DeclareVariable("coo.TBuiRet.tauHeaTraInv", "Dummy parameter to avoid division by tauHeaTra [1/s]",\
 0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("coo.TBuiRet.ratTau", "Ratio of tau", 0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("coo.TBuiRet.TMed", "Medium temperature to which the sensor is exposed [K|degC]",\
 300.0, 1.0,10000.0,300.0,0,2560)
DeclareVariable("coo.TBuiRet.T_a_inflow", "Temperature of inflowing fluid at port_a [K|degC]",\
 293.15, 1.0,10000.0,300.0,0,2560)
DeclareVariable("coo.TBuiRet.T_b_inflow", "Temperature of inflowing fluid at port_b, or T_a_inflow if uni-directional flow [K|degC]",\
 293.15, 1.0,10000.0,300.0,0,2560)
DeclareVariable("coo.val.allowFlowReversal", "= false to simplify equations, assuming, but not enforcing, no flow reversal [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,515)
DeclareAlias2("coo.val.port_a.m_flow", "Mass flow rate from the connection point into the component [kg/s]",\
 "coo.port_a1.m_flow", 1, 5, 612, 132)
DeclareAlias2("coo.val.port_a.p", "Thermodynamic pressure in the connection point [Pa|bar]",\
 "souDis.p", 1, 7, 307, 4)
DeclareAlias2("coo.val.port_a.h_outflow", "Specific thermodynamic enthalpy close to the connection point if m_flow < 0 [J/kg]",\
 "coo.port_a1.h_outflow", 1, 5, 613, 4)
DeclareAlias2("coo.val.port_b.m_flow", "Mass flow rate from the connection point into the component [kg/s]",\
 "coo.port_a1.m_flow", -1, 5, 612, 132)
DeclareAlias2("coo.val.port_b.p", "Thermodynamic pressure in the connection point [Pa|bar]",\
 "coo.hex.port_a1.p", 1, 5, 631, 4)
DeclareAlias2("coo.val.port_b.h_outflow", "Specific thermodynamic enthalpy close to the connection point if m_flow < 0 [J/kg]",\
 "souDis.ports[1].h_outflow", 1, 5, 988, 4)
DeclareVariable("coo.val.m_flow_nominal", "Nominal mass flow rate [kg/s]", 0.5, \
0.0,0.0,0.0,0,513)
DeclareVariable("coo.val.m_flow_small", "Small mass flow rate for regularization of zero flow [kg/s]",\
 5E-05, 0.0,1E+100,0.0,0,513)
DeclareVariable("coo.val.show_T", "= true, if actual temperature at port is computed [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,515)
DeclareAlias2("coo.val.m_flow", "Mass flow rate from port_a to port_b (m_flow > 0 is design flow direction) [kg/s]",\
 "coo.port_a1.m_flow", 1, 5, 612, 0)
DeclareVariable("coo.val.dp", "Pressure difference between port_a and port_b [Pa|Pa]",\
 0, 0.0,0.0,6000.0,0,512)
DeclareVariable("coo.val._m_flow_start", "Start value for m_flow, used to avoid a warning if not set in m_flow, and to avoid m_flow.start in parameter window [kg/s]",\
 0, 0.0,0.0,0.0,0,2561)
DeclareVariable("coo.val._dp_start", "Start value for dp, used to avoid a warning if not set in dp, and to avoid dp.start in parameter window [Pa|Pa]",\
 0, 0.0,0.0,0.0,0,2561)
DeclareVariable("coo.val.from_dp", "= true, use m_flow = f(dp) else dp = f(m_flow) [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,515)
DeclareVariable("coo.val.dp_nominal", "Pressure drop at nominal mass flow rate [Pa|Pa]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("coo.val.homotopyInitialization", "= true, use homotopy method [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,515)
DeclareVariable("coo.val.linearized", "= true, use linear relation between m_flow and dp for any flow rate [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,515)
DeclareVariable("coo.val.m_flow_turbulent", "Turbulent flow if |m_flow| >= m_flow_turbulent [kg/s]",\
 0.0, 0.0,1E+100,0.0,0,513)
DeclareParameter("coo.val.sta_default.p", "Absolute pressure of medium [Pa|bar]",\
 279, 300000.0, 0.0,100000000.0,100000.0,0,2608)
DeclareParameter("coo.val.sta_default.T", "Temperature of medium [K|degC]", 280,\
 293.15, 1.0,10000.0,300.0,0,2608)
DeclareVariable("coo.val.eta_default", "Dynamic viscosity, used to compute transition to turbulent flow regime [Pa.s]",\
 0.001, 0.0,1E+100,0.0,0,2561)
DeclareVariable("coo.val.m_flow_nominal_pos", "Absolute value of nominal flow rate [kg/s]",\
 0.5, 0.0,0.0,0.0,0,2561)
DeclareVariable("coo.val.dp_nominal_pos", "Absolute value of nominal pressure difference [Pa|Pa]",\
 0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("coo.val.CvData", "Selection of flow coefficient [:#(type=Buildings.Fluid.Types.CvTypes)]",\
 1, 1.0,4.0,0.0,0,517)
DeclareVariable("coo.val.Kv", "Kv (metric) flow coefficient [m3/h/(bar)^(1/2)] []",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("coo.val.Cv", "Cv (US) flow coefficient [USG/min/(psi)^(1/2)] []",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("coo.val.Av", "Av (metric) flow coefficient [m2]", 0.0, 0.0,0.0,\
0.0,0,513)
DeclareParameter("coo.val.deltaM", "Fraction of nominal flow rate where linearization starts, if y=1",\
 281, 0.02, 0.0,0.0,0.0,0,560)
DeclareVariable("coo.val.dpValve_nominal", "Nominal pressure drop of fully open valve, used if CvData=Buildings.Fluid.Types.CvTypes.OpPoint [Pa|Pa]",\
 0.0, 0.0,1E+100,0.0,0,513)
DeclareParameter("coo.val.rhoStd", "Inlet density for which valve coefficients are defined [kg/m3|g/cm3]",\
 282, 995.586, 0.0,1E+100,0.0,0,560)
DeclareVariable("coo.val.Kv_SI", "Flow coefficient for fully open valve in SI units, Kv=m_flow/sqrt(dp) [kg/s/(Pa)^(1/2)] []",\
 0.0, 0.0,1E+100,0.0,0,2561)
DeclareVariable("coo.val.use_inputFilter", "= true, if opening is filtered with a 2nd order CriticalDamping filter [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,515)
DeclareParameter("coo.val.riseTime", "Rise time of the filter (time to reach 99.6 % of an opening step) [s|s]",\
 283, 60, 0.0,0.0,0.0,0,560)
DeclareVariable("coo.val.order", "Order of filter [:#(type=Integer)]", 2, 1.0,\
1E+100,0.0,0,517)
DeclareVariable("coo.val.init", "Type of initialization (no init/steady state/initial state/initial output) [:#(type=Modelica.Blocks.Types.Init)]",\
 4, 1.0,4.0,0.0,0,517)
DeclareParameter("coo.val.y_start", "Initial value of output", 284, 0, 0.0,0.0,\
0.0,0,560)
DeclareAlias2("coo.val.y", "Actuator position (0: closed, 1: open)", "coo.con.y", 1,\
 5, 830, 0)
DeclareVariable("coo.val.y_actual", "Actual valve position", 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("coo.val.y_filtered", "Filtered valve position in the range 0..1",\
 "coo.val.y_actual", 1, 5, 952, 1024)
DeclareAlias2("coo.val.filter.u", "Connector of Real input signal", "coo.con.y", 1,\
 5, 830, 1024)
DeclareAlias2("coo.val.filter.y", "Connector of Real output signal", \
"coo.val.y_actual", 1, 5, 952, 1024)
DeclareVariable("coo.val.filter.analogFilter", "Analog filter characteristics (CriticalDamping/Bessel/Butterworth/ChebyshevI) [:#(type=Modelica.Blocks.Types.AnalogFilter)]",\
 1, 1.0,4.0,0.0,0,2565)
DeclareVariable("coo.val.filter.filterType", "Type of filter (LowPass/HighPass/BandPass/BandStop) [:#(type=Modelica.Blocks.Types.FilterType)]",\
 1, 1.0,4.0,0.0,0,2565)
DeclareVariable("coo.val.filter.order", "Order of filter [:#(type=Integer)]", 2,\
 1.0,1E+100,0.0,0,2565)
DeclareVariable("coo.val.filter.f_cut", "Cut-off frequency [Hz]", 0.0, 0.0,0.0,\
0.0,0,2561)
DeclareParameter("coo.val.filter.gain", "Gain (= amplitude of frequency response at zero frequency)",\
 285, 1.0, 0.0,0.0,0.0,0,2608)
DeclareParameter("coo.val.filter.A_ripple", "Pass band ripple for Chebyshev filter (otherwise not used); > 0 required [dB]",\
 286, 0.5, 0.0,0.0,0.0,0,2608)
DeclareParameter("coo.val.filter.f_min", "Band of band pass/stop filter is f_min (A=-3db*gain) .. f_cut (A=-3db*gain) [Hz]",\
 287, 0, 0.0,0.0,0.0,0,2608)
DeclareParameter("coo.val.filter.normalized", "= true, if amplitude at f_cut = -3db, otherwise unmodified filter [:#(type=Boolean)]",\
 288, true, 0.0,0.0,0.0,0,2610)
DeclareVariable("coo.val.filter.init", "Type of initialization (no init/steady state/initial state/initial output) [:#(type=Modelica.Blocks.Types.Init)]",\
 4, 1.0,4.0,0.0,0,2565)
DeclareVariable("coo.val.filter.nx", "[:#(type=Integer)]", 2, 0.0,0.0,0.0,0,2565)
DeclareParameter("coo.val.filter.x_start[1]", "Initial or guess values of states",\
 289, 0, 0.0,0.0,0.0,0,2608)
DeclareParameter("coo.val.filter.x_start[2]", "Initial or guess values of states",\
 290, 0, 0.0,0.0,0.0,0,2608)
DeclareVariable("coo.val.filter.y_start", "Initial value of output", 0.0, \
0.0,0.0,0.0,0,2561)
DeclareParameter("coo.val.filter.u_nominal", "Nominal value of input (used for scaling the states)",\
 291, 1.0, 0.0,0.0,0.0,0,2608)
DeclareState("coo.val.filter.x[1]", "Filter states", 4, 0.0, 0.0,0.0,0.0,0,2592)
DeclareDerivative("coo.val.filter.der(x[1])", "der(Filter states)", 0.0, \
0.0,0.0,0.0,0,2560)
DeclareState("coo.val.filter.x[2]", "Filter states", 5, 0.0, 0.0,0.0,0.0,0,2592)
DeclareDerivative("coo.val.filter.der(x[2])", "der(Filter states)", 0.0, \
0.0,0.0,0.0,0,2560)
DeclareVariable("coo.val.filter.ncr", "[:#(type=Integer)]", 2, 0.0,0.0,0.0,0,2565)
DeclareVariable("coo.val.filter.nc0", "[:#(type=Integer)]", 0, 0.0,0.0,0.0,0,2565)
DeclareVariable("coo.val.filter.na", "[:#(type=Integer)]", 0, 0.0,0.0,0.0,0,2565)
DeclareVariable("coo.val.filter.nr", "[:#(type=Integer)]", 2, 0.0,0.0,0.0,0,2565)
DeclareVariable("coo.val.filter.cr[1]", "", 0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("coo.val.filter.cr[2]", "", 0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("coo.val.filter.r[1]", "", 0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("coo.val.filter.r[2]", "", 0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("coo.val.filter.uu[1]", "", 0.0, 0.0,0.0,0.0,0,2560)
DeclareAlias2("coo.val.filter.uu[2]", "", "coo.val.filter.x[1]", 1, 1, 4, 1024)
DeclareAlias2("coo.val.filter.uu[3]", "", "coo.val.filter.x[2]", 1, 1, 5, 1024)
DeclareVariable("coo.val.dpFixed_nominal", "Pressure drop of pipe and other resistances that are in series [Pa|Pa]",\
 0, 0.0,1E+100,0.0,0,513)
DeclareParameter("coo.val.l", "Valve leakage, l=Kv(y=0)/Kv(y=1)", 292, 0.0001, \
1E-10,1.0,0.0,0,560)
DeclareVariable("coo.val.phi", "Ratio actual to nominal mass flow rate of valve, phi=Kv(y)/Kv(y=1)",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("coo.val.kFixed", "Flow coefficient of fixed resistance that may be in series with valve, k=m_flow/sqrt(dp), with unit=(kg.m)^(1/2).",\
 0.0, 0.0,1E+100,0.0,0,513)
DeclareVariable("coo.val.kVal", "Flow coefficient of valve, k=m_flow/sqrt(dp), with unit=(kg.m)^(1/2).",\
 1E-60, 1E-60,1E+100,0.0,0,512)
DeclareAlias2("coo.val.k", "Flow coefficient of valve and pipe in series, k=m_flow/sqrt(dp), with unit=(kg.m)^(1/2).",\
 "coo.val.kVal", 1, 5, 972, 0)
DeclareParameter("coo.val.alp", "Parameter for valve characteristics, alp>0", 293,\
 2, 0.0,0.0,0.0,0,560)
DeclareParameter("coo.val.delta0", "Range of significant deviation from power law",\
 294, 0.01, 0.0,0.0,0.0,0,560)
DeclareVariable("coo.val.alpInv", "Inverse of alpha", 0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("coo.cp.k", "Gain value multiplied with input signal [1]", \
4184.0, 0.0,0.0,0.0,0,513)
DeclareVariable("coo.cp.u", "Input signal connector", 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("coo.cp.y", "Output signal connector", "coo.Q_flow", 1, 5, 628, 0)
DeclareVariable("coo.pro.u1", "Connector of Real input signal 1", 0.0, 0.0,0.0,\
0.0,0,512)
DeclareAlias2("coo.pro.u2", "Connector of Real input signal 2", "coo.port_a1.m_flow", 1,\
 5, 612, 0)
DeclareAlias2("coo.pro.y", "Connector of Real output signal", "coo.cp.u", 1, 5, 975,\
 0)
DeclareAlias2("coo.dTDis.u1", "Connector of Real input signal 1", \
"coo.senTDisSup.T", 1, 1, 0, 0)
DeclareAlias2("coo.dTDis.u2", "Connector of Real input signal 2", \
"coo.senTDisRet.T", 1, 1, 1, 0)
DeclareAlias2("coo.dTDis.y", "Connector of Real output signal", "coo.pro.u1", 1,\
 5, 976, 0)
DeclareParameter("coo.dTDis.k1", "Gain of upper input", 295, -1, 0.0,0.0,0.0,0,560)
DeclareParameter("coo.dTDis.k2", "Gain of lower input", 296, 1, 0.0,0.0,0.0,0,560)
DeclareVariable("coo.sta_default.p", "Absolute pressure of medium [Pa|bar]", \
300000.0, 0.0,100000000.0,100000.0,0,2561)
DeclareVariable("coo.sta_default.T", "Temperature of medium [K|degC]", 293.15, \
1.0,10000.0,300.0,0,2561)
DeclareVariable("coo.cp_default", "Specific heat capacity of the fluid [J/(kg.K)]",\
 4184, 0.0,0.0,0.0,0,2561)
DeclareParameter("TSetCHWS.k", "Constant output value", 297, 280.15, 0.0,0.0,0.0,\
0,560)
DeclareAlias2("TSetCHWS.y", "Connector of Real output signal", "TSetCHWS.k", 1, 7,\
 297, 0)
DeclareParameter("tra.amplitude", "Amplitude of trapezoid", 298, 1.5, 0.0,0.0,\
0.0,0,560)
DeclareParameter("tra.rising", "Rising duration of trapezoid [s|h]", 299, 10800,\
 0.0,1E+100,0.0,0,560)
DeclareParameter("tra.width", "Width duration of trapezoid [s|h]", 300, 10800, \
0.0,1E+100,0.0,0,560)
DeclareParameter("tra.falling", "Falling duration of trapezoid [s|h]", 301, 10800,\
 0.0,1E+100,0.0,0,560)
DeclareParameter("tra.period", "Time for one period [s|h]", 302, 43200, 1E-60,\
1E+100,0.0,0,560)
DeclareParameter("tra.nperiod", "Number of periods (< 0 means infinite number of periods) [:#(type=Integer)]",\
 303, -1, 0.0,0.0,0.0,0,564)
DeclareParameter("tra.offset", "Offset of output signal", 304, 276.5, 0.0,0.0,\
0.0,0,560)
DeclareParameter("tra.startTime", "Output = offset for time < startTime [s]", 305,\
 0, 0.0,0.0,0.0,0,560)
DeclareVariable("tra.y", "Connector of Real output signal", 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("tra.T_rising", "End time of rising phase within one period [s]",\
 0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("tra.T_width", "End time of width phase within one period [s]", \
0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("tra.T_falling", "End time of falling phase within one period [s]",\
 0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("tra.T_start", "Start time of current period [s]", 0.0, 0.0,0.0,\
0.0,0,2688)
DeclareVariable("tra.count", "Period count [:#(type=Integer)]", 0, 0.0,0.0,0.0,0,2692)
DeclareVariable("souDis.nPorts", "Number of ports [:#(type=Integer)]", 1, \
0.0,0.0,0.0,0,517)
DeclareVariable("souDis.verifyInputs", "Set to true to stop the simulation with an error if the medium temperature is outside its allowable range [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,515)
DeclareAlias2("souDis.ports[1].m_flow", "Mass flow rate from the connection point into the component [kg/s]",\
 "coo.port_a1.m_flow", -1, 5, 612, 132)
DeclareAlias2("souDis.ports[1].p", "Thermodynamic pressure in the connection point [Pa|bar]",\
 "souDis.p", 1, 7, 307, 4)
DeclareVariable("souDis.ports[1].h_outflow", "Specific thermodynamic enthalpy close to the connection point if m_flow < 0 [J/kg]",\
 83680.0, -10000000000.0,10000000000.0,1000000.0,0,520)
DeclareVariable("souDis.flowDirection", "Allowed flow direction [:#(type=Modelica.Fluid.Types.PortFlowDirection)]",\
 3, 1.0,3.0,0.0,0,2565)
DeclareAlias2("souDis.p_in_internal", "Needed to connect to conditional connector [Pa]",\
 "souDis.p", 1, 7, 307, 1024)
DeclareVariable("souDis.X_in_internal[1]", "Needed to connect to conditional connector [kg/kg]",\
 0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("souDis.use_X_in", "Get the composition (all fractions) from the input connector [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,1539)
DeclareVariable("souDis.use_Xi_in", "Get the composition (independent fractions) from the input connector [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,1539)
DeclareVariable("souDis.use_C_in", "Get the trace substances from the input connector [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,1539)
DeclareParameter("souDis.X[1]", "Fixed value of composition [kg/kg]", 306, 1, \
0.0,1.0,0.1,0,560)
DeclareVariable("souDis.use_p_in", "Get the pressure from the input connector [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,1539)
DeclareParameter("souDis.p", "Fixed value of pressure [Pa|Pa]", 307, 300800, 0.0,\
100000000.0,100000.0,0,560)
DeclareVariable("souDis.use_T_in", "Get the temperature from the input connector [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,1539)
DeclareParameter("souDis.T", "Fixed value of temperature [K|degC]", 308, 278.15,\
 1.0,10000.0,300.0,0,560)
DeclareAlias2("souDis.T_in", "Prescribed boundary temperature [K|degC]", "tra.y", 1,\
 5, 980, 0)
DeclareVariable("souDis.checkWaterPressure", "Evaluates to true if the pressure should be checked [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,2563)
DeclareVariable("souDis.checkAirPressure", "Evaluates to true if the pressure should be checked [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,2563)
DeclareAlias2("souDis.T_in_internal", "Needed to connect to conditional connector [K|degC]",\
 "tra.y", 1, 5, 980, 1024)
DeclareAlias2("souDis.h_internal", "Internal connector for enthalpy", \
"souDis.ports[1].h_outflow", 1, 5, 988, 1024)
DeclareVariable("TDisSup.allowFlowReversal", "= false to simplify equations, assuming, but not enforcing, no flow reversal [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,515)
DeclareAlias2("TDisSup.port_a.m_flow", "Mass flow rate from the connection point into the component [kg/s]",\
 "coo.port_a1.m_flow", 1, 5, 612, 132)
DeclareAlias2("TDisSup.port_a.p", "Thermodynamic pressure in the connection point [Pa|bar]",\
 "souDis.p", 1, 7, 307, 4)
DeclareAlias2("TDisSup.port_a.h_outflow", "Specific thermodynamic enthalpy close to the connection point if m_flow < 0 [J/kg]",\
 "coo.port_a1.h_outflow", 1, 5, 613, 4)
DeclareAlias2("TDisSup.port_b.m_flow", "Mass flow rate from the connection point into the component [kg/s]",\
 "coo.port_a1.m_flow", -1, 5, 612, 132)
DeclareAlias2("TDisSup.port_b.p", "Thermodynamic pressure in the connection point [Pa|bar]",\
 "souDis.p", 1, 7, 307, 4)
DeclareAlias2("TDisSup.port_b.h_outflow", "Specific thermodynamic enthalpy close to the connection point if m_flow < 0 [J/kg]",\
 "souDis.ports[1].h_outflow", 1, 5, 988, 4)
DeclareVariable("TDisSup.m_flow_nominal", "Nominal mass flow rate, used for regularization near zero flow [kg/s]",\
 0.0, 0.0,1E+100,0.0,0,513)
DeclareVariable("TDisSup.m_flow_small", "For bi-directional flow, temperature is regularized in the region |m_flow| < m_flow_small (m_flow_small > 0 required) [kg/s]",\
 0.0, 0.0,1E+100,0.0,0,513)
DeclareVariable("TDisSup.tau", "Time constant at nominal flow rate (use tau=0 for steady-state sensor, but see user guide for potential problems) [s]",\
 1, 0.0,1E+100,0.0,0,513)
DeclareVariable("TDisSup.initType", "Type of initialization (InitialState and InitialOutput are identical) [:#(type=Modelica.Blocks.Types.Init)]",\
 3, 1.0,4.0,0.0,0,517)
DeclareVariable("TDisSup.k", "Gain to take flow rate into account for sensor time constant",\
 1, 0.0,0.0,0.0,0,2560)
DeclareVariable("TDisSup.dynamic", "Flag, true if the sensor is a dynamic sensor [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,2563)
DeclareVariable("TDisSup.mNor_flow", "Normalized mass flow rate", 0.0, 0.0,0.0,\
0.0,0,2560)
DeclareVariable("TDisSup.tauInv", "Inverse of tau [s-1]", 1.0, 0.0,0.0,0.0,0,2561)
DeclareState("TDisSup.T", "Temperature of the passing fluid [K|degC]", 6, 0.0, \
0.0,1E+100,0.0,0,544)
DeclareDerivative("TDisSup.der(T)", "der(Temperature of the passing fluid) [K/s]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareParameter("TDisSup.T_start", "Initial or guess value of output (= state) [K|degC]",\
 309, 278.15, 0.0,1E+100,300.0,0,560)
DeclareVariable("TDisSup.transferHeat", "if true, temperature T converges towards TAmb when no flow [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,515)
DeclareParameter("TDisSup.TAmb", "Fixed ambient temperature for heat transfer [K|degC]",\
 310, 293.15, 0.0,1E+100,300.0,0,560)
DeclareParameter("TDisSup.tauHeaTra", "Time constant for heat transfer, default 20 minutes [s]",\
 311, 1200, 1.0,1E+100,0.0,0,560)
DeclareVariable("TDisSup.tauHeaTraInv", "Dummy parameter to avoid division by tauHeaTra [1/s]",\
 0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("TDisSup.ratTau", "Ratio of tau", 0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("TDisSup.TMed", "Medium temperature to which the sensor is exposed [K|degC]",\
 300.0, 1.0,10000.0,300.0,0,2560)
DeclareVariable("TDisSup.T_a_inflow", "Temperature of inflowing fluid at port_a [K|degC]",\
 293.15, 1.0,10000.0,300.0,0,2560)
DeclareVariable("TDisSup.T_b_inflow", "Temperature of inflowing fluid at port_b, or T_a_inflow if uni-directional flow [K|degC]",\
 293.15, 1.0,10000.0,300.0,0,2560)
DeclareVariable("TDisRet.allowFlowReversal", "= false to simplify equations, assuming, but not enforcing, no flow reversal [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,515)
DeclareAlias2("TDisRet.port_a.m_flow", "Mass flow rate from the connection point into the component [kg/s]",\
 "coo.port_a1.m_flow", 1, 5, 612, 132)
DeclareAlias2("TDisRet.port_a.p", "Thermodynamic pressure in the connection point [Pa|bar]",\
 "sinDis.p", 1, 7, 316, 4)
DeclareVariable("TDisRet.port_a.h_outflow", "Specific thermodynamic enthalpy close to the connection point if m_flow < 0 [J/kg]",\
 83680.0, -10000000000.0,10000000000.0,83680.0,0,521)
DeclareAlias2("TDisRet.port_b.m_flow", "Mass flow rate from the connection point into the component [kg/s]",\
 "coo.port_a1.m_flow", -1, 5, 612, 132)
DeclareAlias2("TDisRet.port_b.p", "Thermodynamic pressure in the connection point [Pa|bar]",\
 "sinDis.p", 1, 7, 316, 4)
DeclareAlias2("TDisRet.port_b.h_outflow", "Specific thermodynamic enthalpy close to the connection point if m_flow < 0 [J/kg]",\
 "coo.port_b1.h_outflow", 1, 5, 614, 4)
DeclareVariable("TDisRet.m_flow_nominal", "Nominal mass flow rate, used for regularization near zero flow [kg/s]",\
 0.0, 0.0,1E+100,0.0,0,513)
DeclareVariable("TDisRet.m_flow_small", "For bi-directional flow, temperature is regularized in the region |m_flow| < m_flow_small (m_flow_small > 0 required) [kg/s]",\
 0.0, 0.0,1E+100,0.0,0,513)
DeclareVariable("TDisRet.tau", "Time constant at nominal flow rate (use tau=0 for steady-state sensor, but see user guide for potential problems) [s]",\
 1, 0.0,1E+100,0.0,0,513)
DeclareVariable("TDisRet.initType", "Type of initialization (InitialState and InitialOutput are identical) [:#(type=Modelica.Blocks.Types.Init)]",\
 3, 1.0,4.0,0.0,0,517)
DeclareVariable("TDisRet.k", "Gain to take flow rate into account for sensor time constant",\
 1, 0.0,0.0,0.0,0,2560)
DeclareVariable("TDisRet.dynamic", "Flag, true if the sensor is a dynamic sensor [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,2563)
DeclareVariable("TDisRet.mNor_flow", "Normalized mass flow rate", 0.0, 0.0,0.0,\
0.0,0,2560)
DeclareVariable("TDisRet.tauInv", "Inverse of tau [s-1]", 1.0, 0.0,0.0,0.0,0,2561)
DeclareState("TDisRet.T", "Temperature of the passing fluid [K|degC]", 7, 0.0, \
0.0,1E+100,0.0,0,544)
DeclareDerivative("TDisRet.der(T)", "der(Temperature of the passing fluid) [K/s]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareParameter("TDisRet.T_start", "Initial or guess value of output (= state) [K|degC]",\
 312, 287.15, 0.0,1E+100,300.0,0,560)
DeclareVariable("TDisRet.transferHeat", "if true, temperature T converges towards TAmb when no flow [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,515)
DeclareParameter("TDisRet.TAmb", "Fixed ambient temperature for heat transfer [K|degC]",\
 313, 293.15, 0.0,1E+100,300.0,0,560)
DeclareParameter("TDisRet.tauHeaTra", "Time constant for heat transfer, default 20 minutes [s]",\
 314, 1200, 1.0,1E+100,0.0,0,560)
DeclareVariable("TDisRet.tauHeaTraInv", "Dummy parameter to avoid division by tauHeaTra [1/s]",\
 0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("TDisRet.ratTau", "Ratio of tau", 0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("TDisRet.TMed", "Medium temperature to which the sensor is exposed [K|degC]",\
 300.0, 1.0,10000.0,300.0,0,2560)
DeclareVariable("TDisRet.T_a_inflow", "Temperature of inflowing fluid at port_a [K|degC]",\
 293.15, 1.0,10000.0,300.0,0,2560)
DeclareVariable("TDisRet.T_b_inflow", "Temperature of inflowing fluid at port_b, or T_a_inflow if uni-directional flow [K|degC]",\
 293.15, 1.0,10000.0,300.0,0,2561)
DeclareVariable("sinDis.nPorts", "Number of ports [:#(type=Integer)]", 1, \
0.0,0.0,0.0,0,517)
DeclareVariable("sinDis.verifyInputs", "Set to true to stop the simulation with an error if the medium temperature is outside its allowable range [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,515)
DeclareAlias2("sinDis.ports[1].m_flow", "Mass flow rate from the connection point into the component [kg/s]",\
 "coo.port_a1.m_flow", 1, 5, 612, 132)
DeclareAlias2("sinDis.ports[1].p", "Thermodynamic pressure in the connection point [Pa|bar]",\
 "sinDis.p", 1, 7, 316, 4)
DeclareAlias2("sinDis.ports[1].h_outflow", "Specific thermodynamic enthalpy close to the connection point if m_flow < 0 [J/kg]",\
 "TDisRet.port_a.h_outflow", 1, 5, 1014, 4)
DeclareVariable("sinDis.flowDirection", "Allowed flow direction [:#(type=Modelica.Fluid.Types.PortFlowDirection)]",\
 3, 1.0,3.0,0.0,0,2565)
DeclareAlias2("sinDis.p_in_internal", "Needed to connect to conditional connector [Pa]",\
 "sinDis.p", 1, 7, 316, 1024)
DeclareVariable("sinDis.X_in_internal[1]", "Needed to connect to conditional connector [kg/kg]",\
 0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("sinDis.use_X_in", "Get the composition (all fractions) from the input connector [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,1539)
DeclareVariable("sinDis.use_Xi_in", "Get the composition (independent fractions) from the input connector [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,1539)
DeclareVariable("sinDis.use_C_in", "Get the trace substances from the input connector [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,1539)
DeclareParameter("sinDis.X[1]", "Fixed value of composition [kg/kg]", 315, 1, \
0.0,1.0,0.1,0,560)
DeclareVariable("sinDis.use_p_in", "Get the pressure from the input connector [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,1539)
DeclareParameter("sinDis.p", "Fixed value of pressure [Pa|bar]", 316, 300000, \
0.0,100000000.0,100000.0,0,560)
DeclareVariable("sinDis.use_T_in", "Get the temperature from the input connector [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,1539)
DeclareParameter("sinDis.T", "Fixed value of temperature [K|degC]", 317, 287.15,\
 1.0,10000.0,300.0,0,560)
DeclareVariable("sinDis.checkWaterPressure", "Evaluates to true if the pressure should be checked [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,2563)
DeclareVariable("sinDis.checkAirPressure", "Evaluates to true if the pressure should be checked [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,2563)
DeclareAlias2("sinDis.T_in_internal", "Needed to connect to conditional connector [K|degC]",\
 "sinDis.T", 1, 7, 317, 1024)
DeclareAlias2("sinDis.h_internal", "Internal connector for enthalpy", \
"TDisRet.port_a.h_outflow", 1, 5, 1014, 1024)
DeclareVariable("pumpBuiding.energyDynamics", "Type of energy balance: dynamic (3 initialization options) or steady state [:#(type=Modelica.Fluid.Types.Dynamics)]",\
 4, 1.0,4.0,0.0,0,517)
DeclareVariable("pumpBuiding.massDynamics", "Type of mass balance: dynamic (3 initialization options) or steady state [:#(type=Modelica.Fluid.Types.Dynamics)]",\
 4, 1.0,4.0,0.0,0,517)
DeclareVariable("pumpBuiding.substanceDynamics", "Type of independent mass fraction balance: dynamic (3 initialization options) or steady state [:#(type=Modelica.Fluid.Types.Dynamics)]",\
 4, 1.0,4.0,0.0,0,517)
DeclareVariable("pumpBuiding.traceDynamics", "Type of trace substance balance: dynamic (3 initialization options) or steady state [:#(type=Modelica.Fluid.Types.Dynamics)]",\
 4, 1.0,4.0,0.0,0,517)
DeclareParameter("pumpBuiding.p_start", "Start value of pressure [Pa|bar]", 318,\
 300000, 0.0,100000000.0,100000.0,0,560)
DeclareParameter("pumpBuiding.T_start", "Start value of temperature [K|degC]", 319,\
 293.15, 1.0,10000.0,300.0,0,560)
DeclareParameter("pumpBuiding.X_start[1]", "Start value of mass fractions m_i/m [kg/kg]",\
 320, 1, 0.0,1.0,0.1,0,560)
DeclareVariable("pumpBuiding.mSenFac", "Factor for scaling the sensible thermal mass of the volume",\
 1, 1.0,1E+100,0.0,0,513)
DeclareVariable("pumpBuiding.allowFlowReversal", "= false to simplify equations, assuming, but not enforcing, no flow reversal [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,515)
DeclareAlias2("pumpBuiding.port_a.m_flow", "Mass flow rate from the connection point into the component [kg/s]",\
 "coo.port_a2.m_flow", 1, 5, 615, 132)
DeclareAlias2("pumpBuiding.port_a.p", "Thermodynamic pressure in the connection point [Pa|bar]",\
 "exp.p_start", 1, 7, 345, 4)
DeclareVariable("pumpBuiding.port_a.h_outflow", "Specific thermodynamic enthalpy close to the connection point if m_flow < 0 [J/kg]",\
 83680.0, -10000000000.0,10000000000.0,83680.0,0,521)
DeclareAlias2("pumpBuiding.port_b.m_flow", "Mass flow rate from the connection point into the component [kg/s]",\
 "coo.port_a2.m_flow", -1, 5, 615, 132)
DeclareVariable("pumpBuiding.port_b.p", "Thermodynamic pressure in the connection point [Pa|bar]",\
 0.0, 0.0,100000000.0,100000.0,0,520)
DeclareVariable("pumpBuiding.port_b.h_outflow", "Specific thermodynamic enthalpy close to the connection point if m_flow < 0 [J/kg]",\
 0.0, -10000000000.0,10000000000.0,83680.0,0,520)
DeclareVariable("pumpBuiding.m_flow_nominal", "Nominal mass flow rate [kg/s]", \
0.5, 1E-60,1E+100,0.0,0,513)
DeclareVariable("pumpBuiding.m_flow_small", "Small mass flow rate for regularization of zero flow [kg/s]",\
 5E-05, 0.0,1E+100,0.0,0,513)
DeclareVariable("pumpBuiding.show_T", "= true, if actual temperature at port is computed [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,515)
DeclareAlias2("pumpBuiding.m_flow", "Mass flow rate from port_a to port_b (m_flow > 0 is design flow direction) [kg/s]",\
 "coo.port_a2.m_flow", 1, 5, 615, 0)
DeclareVariable("pumpBuiding.dp", "Pressure difference between port_a and port_b [Pa|Pa]",\
 0, 0.0,0.0,0.0,0,512)
DeclareVariable("pumpBuiding._m_flow_start", "Start value for m_flow, used to avoid a warning if not set in m_flow, and to avoid m_flow.start in parameter window [kg/s]",\
 0, 0.0,0.0,0.0,0,2561)
DeclareVariable("pumpBuiding._dp_start", "Start value for dp, used to avoid a warning if not set in dp, and to avoid dp.start in parameter window [Pa|Pa]",\
 0, 0.0,0.0,0.0,0,2561)
DeclareVariable("pumpBuiding.per.pressure.V_flow[1]", "Volume flow rate at user-selected operating points [m3/s]",\
 0, 0.0,1E+100,0.0,0,513)
DeclareVariable("pumpBuiding.per.pressure.V_flow[2]", "Volume flow rate at user-selected operating points [m3/s]",\
 0, 0.0,1E+100,0.0,0,513)
DeclareVariable("pumpBuiding.per.pressure.dp[1]", "Fan or pump total pressure at these flow rates [Pa|Pa]",\
 0, 0.0,1E+100,0.0,0,513)
DeclareVariable("pumpBuiding.per.pressure.dp[2]", "Fan or pump total pressure at these flow rates [Pa|Pa]",\
 0, 0.0,1E+100,0.0,0,513)
DeclareParameter("pumpBuiding.per.use_powerCharacteristic", "Use power data instead of motor efficiency [:#(type=Boolean)]",\
 321, false, 0.0,0.0,0.0,0,562)
DeclareParameter("pumpBuiding.per.hydraulicEfficiency.V_flow[1]", \
"Volumetric flow rate at user-selected operating points [m3/s]", 322, 0, 0.0,\
1E+100,0.0,0,560)
DeclareParameter("pumpBuiding.per.hydraulicEfficiency.eta[1]", "Fan or pump efficiency at these flow rates [1]",\
 323, 0.7, 0.0,1.0,0.0,0,560)
DeclareParameter("pumpBuiding.per.motorEfficiency.V_flow[1]", "Volumetric flow rate at user-selected operating points [m3/s]",\
 324, 0, 0.0,1E+100,0.0,0,560)
DeclareParameter("pumpBuiding.per.motorEfficiency.eta[1]", "Fan or pump efficiency at these flow rates [1]",\
 325, 0.7, 0.0,1.0,0.0,0,560)
DeclareParameter("pumpBuiding.per.power.V_flow[1]", "Volume flow rate at user-selected operating points [m3/s]",\
 326, 0, 0.0,1E+100,0.0,0,560)
DeclareParameter("pumpBuiding.per.power.P[1]", "Fan or pump electrical power at these flow rates [W]",\
 327, 0, 0.0,1E+100,0.0,0,560)
DeclareParameter("pumpBuiding.per.motorCooledByFluid", "If true, then motor heat is added to fluid stream [:#(type=Boolean)]",\
 328, true, 0.0,0.0,0.0,0,562)
DeclareParameter("pumpBuiding.per.speed_nominal", "Nominal rotational speed for flow characteristic [1]",\
 329, 1, 0.0,1E+100,0.0,0,560)
DeclareVariable("pumpBuiding.per.constantSpeed", "Normalized speed set point, used if inputType = Buildings.Fluid.Types.InputType.Constant [1]",\
 0.0, 0.0,1E+100,0.0,0,513)
DeclareVariable("pumpBuiding.per.speeds[1]", "Vector of normalized speed set points, used if inputType = Buildings.Fluid.Types.InputType.Stages [1]",\
 0.0, 0.0,1E+100,0.0,0,513)
DeclareParameter("pumpBuiding.per.speed_rpm_nominal", "Nominal rotational speed for flow characteristic [rev/min]",\
 330, 1500, 0.0,0.0,0.0,0,560)
DeclareVariable("pumpBuiding.per.constantSpeed_rpm", "Speed set point, used if inputType = Buildings.Fluid.Types.InputType.Constant [rev/min]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("pumpBuiding.per.speeds_rpm[1]", "Vector of speed set points, used if inputType = Buildings.Fluid.Types.InputType.Stages [rev/min]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("pumpBuiding.per.havePressureCurve", "= true, if default record values are being used [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,515)
DeclareVariable("pumpBuiding.inputType", "Control input type [:#(type=Buildings.Fluid.Types.InputType)]",\
 3, 1.0,3.0,0.0,0,517)
DeclareVariable("pumpBuiding.constInput", "Constant input set point [kg/s]", 0.5,\
 0.0,0.0,0.0,0,513)
DeclareVariable("pumpBuiding.stageInputs[1]", "Vector of input set points corresponding to stages [kg/s]",\
 0.5, 0.0,0.0,0.0,0,513)
DeclareVariable("pumpBuiding.computePowerUsingSimilarityLaws", "= true, compute power exactly, using similarity laws. Otherwise approximate. [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,515)
DeclareVariable("pumpBuiding.addPowerToMedium", "Set to false to avoid any power (=heat and flow work) being added to medium (may give simpler equations) [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,515)
DeclareParameter("pumpBuiding.nominalValuesDefineDefaultPressureCurve", \
"Set to true to avoid warning if m_flow_nominal and dp_nominal are used to construct the default pressure curve [:#(type=Boolean)]",\
 331, true, 0.0,0.0,0.0,0,562)
DeclareParameter("pumpBuiding.tau", "Time constant of fluid volume for nominal flow, used if energy or mass balance is dynamic [s]",\
 332, 1, 0.0,0.0,0.0,0,560)
DeclareVariable("pumpBuiding.use_inputFilter", "= true, if speed is filtered with a 2nd order CriticalDamping filter [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,515)
DeclareParameter("pumpBuiding.riseTime", "Rise time of the filter (time to reach 99.6 % of the speed) [s]",\
 333, 30, 0.0,0.0,0.0,0,560)
DeclareVariable("pumpBuiding.init", "Type of initialization (no init/steady state/initial state/initial output) [:#(type=Modelica.Blocks.Types.Init)]",\
 4, 1.0,4.0,0.0,0,517)
DeclareParameter("pumpBuiding.y_start", "Initial value of speed [1]", 334, 0, \
0.0,1.0,0.0,0,560)
DeclareVariable("pumpBuiding.y_actual", "Actual normalised pump speed that is used for computations [1]",\
 1, 0.0,0.0,0.0,0,513)
DeclareVariable("pumpBuiding.P", "Electrical power consumed [W]", 0.0, 0.0,0.0,\
0.0,0,512)
DeclareVariable("pumpBuiding.heatPort.T", "Port temperature [K|degC]", 300.0, \
1.0,10000.0,300.0,0,520)
DeclareVariable("pumpBuiding.heatPort.Q_flow", "Heat flow rate (positive if flowing from outside into the component) [W]",\
 0.0, 0.0,0.0,0.0,0,777)
DeclareVariable("pumpBuiding.VMachine_flow", "Volume flow rate [m3/s]", 0, \
0.0,0.0,0.0,0,512)
DeclareVariable("pumpBuiding.dpMachine", "Pressure difference [Pa|Pa]", 0.0, \
0.0,0.0,0.0,0,512)
DeclareVariable("pumpBuiding.eta", "Global efficiency [1]", 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("pumpBuiding.etaHyd", "Hydraulic efficiency [1]", 0.0, 0.0,0.0,\
0.0,0,512)
DeclareVariable("pumpBuiding.etaMot", "Motor efficiency [1]", 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("pumpBuiding._VMachine_flow", "Start value for VMachine_flow, used to avoid a warning if not specified [m3/s]",\
 0, 0.0,0.0,0.0,0,2561)
DeclareVariable("pumpBuiding.preVar", "Type of prescribed variable [:#(type=Buildings.Fluid.Movers.BaseClasses.Types.PrescribedVariable)]",\
 2, 1.0,3.0,0.0,0,2565)
DeclareVariable("pumpBuiding.speedIsInput", "Parameter that is true if speed is the controlled variables [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,2563)
DeclareVariable("pumpBuiding.nOri", "Number of data points for pressure curve [:#(type=Integer)]",\
 2, 0.0,0.0,0.0,0,2565)
DeclareVariable("pumpBuiding.haveVMax", "Flag, true if user specified data that contain V_flow_max [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,2563)
DeclareVariable("pumpBuiding.V_flow_max", "Maximum volume flow rate, used for smoothing [m3/s]",\
 0.0005022167848884978, 0.0,0.0,0.0,0,2561)
DeclareVariable("pumpBuiding.rho_default", "Default medium density [kg/m3|g/cm3]",\
 995.586, 0.0,1E+100,0.0,0,2561)
DeclareVariable("pumpBuiding.sta_start.p", "Absolute pressure of medium [Pa|bar]",\
 300000, 0.0,100000000.0,100000.0,0,2561)
DeclareVariable("pumpBuiding.sta_start.T", "Temperature of medium [K|degC]", \
293.15, 1.0,10000.0,300.0,0,2561)
DeclareVariable("pumpBuiding.h_outflow_start", "Start value for outflowing enthalpy [J/kg]",\
 0.0, 0.0,0.0,0.0,0,2561)
DeclareAlias2("pumpBuiding.inputSwitch.u", "Connector of Real input signal", \
"gain1.y", 1, 5, 1318, 1024)
DeclareAlias2("pumpBuiding.inputSwitch.y", "Connector of Real output signal", \
"gain1.y", 1, 5, 1318, 1024)
DeclareVariable("pumpBuiding.vol.energyDynamics", "Type of energy balance: dynamic (3 initialization options) or steady state [:#(type=Modelica.Fluid.Types.Dynamics)]",\
 4, 1.0,4.0,0.0,0,2565)
DeclareVariable("pumpBuiding.vol.massDynamics", "Type of mass balance: dynamic (3 initialization options) or steady state [:#(type=Modelica.Fluid.Types.Dynamics)]",\
 4, 1.0,4.0,0.0,0,2565)
DeclareVariable("pumpBuiding.vol.substanceDynamics", "Type of independent mass fraction balance: dynamic (3 initialization options) or steady state [:#(type=Modelica.Fluid.Types.Dynamics)]",\
 4, 1.0,4.0,0.0,0,2565)
DeclareVariable("pumpBuiding.vol.traceDynamics", "Type of trace substance balance: dynamic (3 initialization options) or steady state [:#(type=Modelica.Fluid.Types.Dynamics)]",\
 4, 1.0,4.0,0.0,0,2565)
DeclareVariable("pumpBuiding.vol.p_start", "Start value of pressure [Pa|bar]", 300000,\
 0.0,100000000.0,100000.0,0,2561)
DeclareVariable("pumpBuiding.vol.T_start", "Start value of temperature [K|degC]",\
 293.15, 1.0,10000.0,300.0,0,2561)
DeclareVariable("pumpBuiding.vol.X_start[1]", "Start value of mass fractions m_i/m [kg/kg]",\
 0.0, 0.0,1.0,0.1,0,2561)
DeclareVariable("pumpBuiding.vol.mSenFac", "Factor for scaling the sensible thermal mass of the volume",\
 1, 1.0,1E+100,0.0,0,2561)
DeclareVariable("pumpBuiding.vol.initialize_p", "= true to set up initial equations for pressure [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,1539)
DeclareVariable("pumpBuiding.vol.prescribedHeatFlowRate", "Set to true if the model has a prescribed heat flow at its heatPort. If the heat flow rate at the heatPort is only based on temperature difference, then set to false [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,2563)
DeclareVariable("pumpBuiding.vol.simplify_mWat_flow", "Set to true to cause port_a.m_flow + port_b.m_flow = 0 even if mWat_flow is non-zero [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,2563)
DeclareVariable("pumpBuiding.vol.m_flow_nominal", "Nominal mass flow rate [kg/s]",\
 0.5, 0.0,1E+100,0.0,0,2561)
DeclareVariable("pumpBuiding.vol.nPorts", "Number of ports [:#(type=Integer)]", 2,\
 0.0,0.0,0.0,0,2565)
DeclareVariable("pumpBuiding.vol.m_flow_small", "Small mass flow rate for regularization of zero flow [kg/s]",\
 5E-05, 0.0,1E+100,0.0,0,2561)
DeclareVariable("pumpBuiding.vol.allowFlowReversal", "= false to simplify equations, assuming, but not enforcing, no flow reversal. Used only if model has two ports. [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,2563)
DeclareVariable("pumpBuiding.vol.V", "Volume [m3]", 0.0, 0.0,0.0,0.0,0,2561)
DeclareAlias2("pumpBuiding.vol.ports[1].m_flow", "Mass flow rate from the connection point into the component [kg/s]",\
 "coo.port_a2.m_flow", 1, 5, 615, 1156)
DeclareAlias2("pumpBuiding.vol.ports[1].p", "Thermodynamic pressure in the connection point [Pa|bar]",\
 "exp.p_start", 1, 7, 345, 1028)
DeclareVariable("pumpBuiding.vol.ports[1].h_outflow", "Specific thermodynamic enthalpy close to the connection point if m_flow < 0 [J/kg]",\
 83680.0, -10000000000.0,10000000000.0,1000000.0,0,2569)
DeclareAlias2("pumpBuiding.vol.ports[2].m_flow", "Mass flow rate from the connection point into the component [kg/s]",\
 "coo.port_a2.m_flow", -1, 5, 615, 1156)
DeclareAlias2("pumpBuiding.vol.ports[2].p", "Thermodynamic pressure in the connection point [Pa|bar]",\
 "exp.p_start", 1, 7, 345, 1028)
DeclareVariable("pumpBuiding.vol.ports[2].h_outflow", "Specific thermodynamic enthalpy close to the connection point if m_flow < 0 [J/kg]",\
 83680.0, -10000000000.0,10000000000.0,1000000.0,0,2568)
DeclareAlias2("pumpBuiding.vol.T", "Temperature of the fluid [K|degC]", \
"pumpBuiding.heatPort.T", 1, 5, 1073, 1024)
DeclareVariable("pumpBuiding.vol.U", "Internal energy of the component [J]", 0, \
0.0,0.0,0.0,0,2561)
DeclareAlias2("pumpBuiding.vol.p", "Pressure of the fluid [Pa|bar]", \
"exp.p_start", 1, 7, 345, 1024)
DeclareVariable("pumpBuiding.vol.m", "Mass of the component [kg]", 0, 0.0,0.0,\
0.0,0,2561)
DeclareVariable("pumpBuiding.vol.rho_start", "Density, used to compute start and guess values [kg/m3|g/cm3]",\
 995.586, 0.0,1E+100,0.0,0,2561)
DeclareVariable("pumpBuiding.vol.state_default.p", "Absolute pressure of medium [Pa|bar]",\
 300000.0, 0.0,100000000.0,100000.0,0,2561)
DeclareVariable("pumpBuiding.vol.state_default.T", "Temperature of medium [K|degC]",\
 293.15, 1.0,10000.0,300.0,0,2561)
DeclareVariable("pumpBuiding.vol.rho_default", "Density, used to compute fluid mass [kg/m3|g/cm3]",\
 995.586, 0.0,1E+100,0.0,0,2561)
DeclareVariable("pumpBuiding.vol.state_start.p", "Absolute pressure of medium [Pa|bar]",\
 300000, 0.0,100000000.0,100000.0,0,2561)
DeclareVariable("pumpBuiding.vol.state_start.T", "Temperature of medium [K|degC]",\
 293.15, 1.0,10000.0,300.0,0,2561)
DeclareVariable("pumpBuiding.vol.useSteadyStateTwoPort", "Flag, true if the model has two ports only and uses a steady state balance [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,2563)
DeclareAlias2("pumpBuiding.vol.hOut_internal", "Internal connector for leaving temperature of the component [J/kg]",\
 "pumpBuiding.vol.ports[2].h_outflow", 1, 5, 1107, 1024)
DeclareAlias2("pumpBuiding.vol.preTem.port.T", "Port temperature [K|degC]", \
"pumpBuiding.heatPort.T", 1, 5, 1073, 1028)
DeclareAlias2("pumpBuiding.vol.preTem.port.Q_flow", "Heat flow rate (positive if flowing from outside into the component) [W]",\
 "pumpBuiding.vol.heatPort.Q_flow", 1, 5, 1118, 1156)
DeclareAlias2("pumpBuiding.vol.preTem.T", "", "pumpBuiding.heatPort.T", 1, 5, 1073,\
 1024)
DeclareAlias2("pumpBuiding.vol.portT.y", "Value of Real output", \
"pumpBuiding.heatPort.T", 1, 5, 1073, 1024)
DeclareAlias2("pumpBuiding.vol.heaFloSen.Q_flow", "Heat flow from port_a to port_b as output signal [W]",\
 "pumpBuiding.vol.heatPort.Q_flow", 1, 5, 1118, 1024)
DeclareAlias2("pumpBuiding.vol.heaFloSen.port_a.T", "Port temperature [K|degC]",\
 "pumpBuiding.heatPort.T", 1, 5, 1073, 1028)
DeclareAlias2("pumpBuiding.vol.heaFloSen.port_a.Q_flow", "Heat flow rate (positive if flowing from outside into the component) [W]",\
 "pumpBuiding.vol.heatPort.Q_flow", 1, 5, 1118, 1156)
DeclareAlias2("pumpBuiding.vol.heaFloSen.port_b.T", "Port temperature [K|degC]",\
 "pumpBuiding.heatPort.T", 1, 5, 1073, 1028)
DeclareAlias2("pumpBuiding.vol.heaFloSen.port_b.Q_flow", "Heat flow rate (positive if flowing from outside into the component) [W]",\
 "pumpBuiding.vol.heatPort.Q_flow", -1, 5, 1118, 1156)
DeclareVariable("pumpBuiding.vol.use_C_flow", "Set to true to enable input connector for trace substance [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,2563)
DeclareAlias2("pumpBuiding.vol.heatPort.T", "Port temperature [K|degC]", \
"pumpBuiding.heatPort.T", 1, 5, 1073, 1028)
DeclareVariable("pumpBuiding.vol.heatPort.Q_flow", "Heat flow rate (positive if flowing from outside into the component) [W]",\
 0.0, 0.0,0.0,0.0,0,2824)
DeclareVariable("pumpBuiding.vol.tau", "Time constant at nominal flow [s]", 0.0,\
 0.0,0.0,0.0,0,2561)
DeclareVariable("pumpBuiding.vol.V_nominal", "Volume of delay element [m3]", 0.0,\
 0.0,0.0,0.0,0,2561)
DeclareAlias2("pumpBuiding.filter.u", "Connector of Real input signal [kg/s]", \
"gain1.y", 1, 5, 1318, 1024)
DeclareAlias2("pumpBuiding.filter.y", "Connector of Real output signal [kg/s]", \
"coo.port_a2.m_flow", 1, 5, 615, 1024)
DeclareVariable("pumpBuiding.filter.analogFilter", "Analog filter characteristics (CriticalDamping/Bessel/Butterworth/ChebyshevI) [:#(type=Modelica.Blocks.Types.AnalogFilter)]",\
 1, 1.0,4.0,0.0,0,2565)
DeclareVariable("pumpBuiding.filter.filterType", "Type of filter (LowPass/HighPass/BandPass/BandStop) [:#(type=Modelica.Blocks.Types.FilterType)]",\
 1, 1.0,4.0,0.0,0,2565)
DeclareVariable("pumpBuiding.filter.order", "Order of filter [:#(type=Integer)]",\
 2, 1.0,1E+100,0.0,0,2565)
DeclareVariable("pumpBuiding.filter.f_cut", "Cut-off frequency [Hz]", 0.0, \
0.0,0.0,0.0,0,2561)
DeclareParameter("pumpBuiding.filter.gain", "Gain (= amplitude of frequency response at zero frequency)",\
 335, 1.0, 0.0,0.0,0.0,0,2608)
DeclareParameter("pumpBuiding.filter.A_ripple", "Pass band ripple for Chebyshev filter (otherwise not used); > 0 required [dB]",\
 336, 0.5, 0.0,0.0,0.0,0,2608)
DeclareParameter("pumpBuiding.filter.f_min", "Band of band pass/stop filter is f_min (A=-3db*gain) .. f_cut (A=-3db*gain) [Hz]",\
 337, 0, 0.0,0.0,0.0,0,2608)
DeclareParameter("pumpBuiding.filter.normalized", "= true, if amplitude at f_cut = -3db, otherwise unmodified filter [:#(type=Boolean)]",\
 338, true, 0.0,0.0,0.0,0,2610)
DeclareVariable("pumpBuiding.filter.init", "Type of initialization (no init/steady state/initial state/initial output) [:#(type=Modelica.Blocks.Types.Init)]",\
 4, 1.0,4.0,0.0,0,2565)
DeclareVariable("pumpBuiding.filter.nx", "[:#(type=Integer)]", 2, 0.0,0.0,0.0,0,2565)
DeclareParameter("pumpBuiding.filter.x_start[1]", "Initial or guess values of states",\
 339, 0, 0.0,0.0,0.0,0,2608)
DeclareParameter("pumpBuiding.filter.x_start[2]", "Initial or guess values of states",\
 340, 0, 0.0,0.0,0.0,0,2608)
DeclareVariable("pumpBuiding.filter.y_start", "Initial value of output", 0.0, \
0.0,0.0,0.0,0,2561)
DeclareVariable("pumpBuiding.filter.u_nominal", "Nominal value of input (used for scaling the states)",\
 0.5, 0.0,0.0,0.0,0,2561)
DeclareState("pumpBuiding.filter.x[1]", "Filter states", 8, 0.0, 0.0,0.0,0.0,0,2592)
DeclareDerivative("pumpBuiding.filter.der(x[1])", "der(Filter states)", 0.0, \
0.0,0.0,0.0,0,2560)
DeclareState("pumpBuiding.filter.x[2]", "Filter states", 9, 0.0, 0.0,0.0,0.0,0,2592)
DeclareDerivative("pumpBuiding.filter.der(x[2])", "der(Filter states)", 0.0, \
0.0,0.0,0.0,0,2560)
DeclareVariable("pumpBuiding.filter.ncr", "[:#(type=Integer)]", 2, 0.0,0.0,0.0,0,2565)
DeclareVariable("pumpBuiding.filter.nc0", "[:#(type=Integer)]", 0, 0.0,0.0,0.0,0,2565)
DeclareVariable("pumpBuiding.filter.na", "[:#(type=Integer)]", 0, 0.0,0.0,0.0,0,2565)
DeclareVariable("pumpBuiding.filter.nr", "[:#(type=Integer)]", 2, 0.0,0.0,0.0,0,2565)
DeclareVariable("pumpBuiding.filter.cr[1]", "", 0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("pumpBuiding.filter.cr[2]", "", 0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("pumpBuiding.filter.r[1]", "", 0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("pumpBuiding.filter.r[2]", "", 0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("pumpBuiding.filter.uu[1]", "", 0.0, 0.0,0.0,0.0,0,2560)
DeclareAlias2("pumpBuiding.filter.uu[2]", "", "pumpBuiding.filter.x[1]", 1, 1, 8,\
 1024)
DeclareAlias2("pumpBuiding.filter.uu[3]", "", "pumpBuiding.filter.x[2]", 1, 1, 9,\
 1024)
DeclareVariable("pumpBuiding.preSou.allowFlowReversal", "= false to simplify equations, assuming, but not enforcing, no flow reversal [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,2563)
DeclareAlias2("pumpBuiding.preSou.port_a.m_flow", "Mass flow rate from the connection point into the component [kg/s]",\
 "coo.port_a2.m_flow", 1, 5, 615, 1156)
DeclareAlias2("pumpBuiding.preSou.port_a.p", "Thermodynamic pressure in the connection point [Pa|bar]",\
 "exp.p_start", 1, 7, 345, 1028)
DeclareVariable("pumpBuiding.preSou.port_a.h_outflow", "Specific thermodynamic enthalpy close to the connection point if m_flow < 0 [J/kg]",\
 83680.0, -10000000000.0,10000000000.0,83680.0,0,2569)
DeclareAlias2("pumpBuiding.preSou.port_b.m_flow", "Mass flow rate from the connection point into the component [kg/s]",\
 "coo.port_a2.m_flow", -1, 5, 615, 1156)
DeclareAlias2("pumpBuiding.preSou.port_b.p", "Thermodynamic pressure in the connection point [Pa|bar]",\
 "pumpBuiding.port_b.p", 1, 5, 1047, 1028)
DeclareAlias2("pumpBuiding.preSou.port_b.h_outflow", "Specific thermodynamic enthalpy close to the connection point if m_flow < 0 [J/kg]",\
 "pumpBuiding.vol.ports[2].h_outflow", 1, 5, 1107, 1028)
DeclareParameter("pumpBuiding.preSou.dp_start", "Guess value of dp = port_a.p - port_b.p [Pa|Pa]",\
 341, 0, 0.0,0.0,0.0,0,2608)
DeclareVariable("pumpBuiding.preSou.m_flow_start", "Guess value of m_flow = port_a.m_flow [kg/s]",\
 0.0, -100000.0,100000.0,0.0,0,2561)
DeclareVariable("pumpBuiding.preSou.m_flow_small", "Small mass flow rate for regularization of zero flow [kg/s]",\
 5E-05, -100000.0,100000.0,0.0,0,2561)
DeclareVariable("pumpBuiding.preSou.show_T", "= true, if temperatures at port_a and port_b are computed [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,2563)
DeclareVariable("pumpBuiding.preSou.show_V_flow", "= true, if volume flow rate at inflowing port is computed [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,2563)
DeclareAlias2("pumpBuiding.preSou.m_flow", "Mass flow rate in design flow direction [kg/s]",\
 "coo.port_a2.m_flow", 1, 5, 615, 1024)
DeclareAlias2("pumpBuiding.preSou.dp", "Pressure difference between port_a and port_b (= port_a.p - port_b.p) [Pa|Pa]",\
 "pumpBuiding.dpMachine", -1, 5, 1076, 1024)
DeclareVariable("pumpBuiding.preSou.V_flow", "Volume flow rate at inflowing port (positive when flow from port_a to port_b) [m3/s]",\
 0.0, 0.0,0.0,0.0,0,2560)
DeclareVariable("pumpBuiding.preSou.control_m_flow", "if true, then the mass flow rate is equal to the value of m_flow_in [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,2563)
DeclareVariable("pumpBuiding.preSou.control_dp", "if true, then the head is equal to the value of dp_in [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,2563)
DeclareAlias2("pumpBuiding.preSou.m_flow_in", "Prescribed mass flow rate [kg/s]",\
 "coo.port_a2.m_flow", 1, 5, 615, 1024)
DeclareAlias2("pumpBuiding.preSou.m_flow_internal", "Needed to connect to conditional connector [kg/s]",\
 "coo.port_a2.m_flow", 1, 5, 615, 1024)
DeclareVariable("pumpBuiding.preSou.dp_internal", "Needed to connect to conditional connector [Pa]",\
 0, 0.0,0.0,0.0,0,2561)
DeclareVariable("pumpBuiding.heaDis.homotopyInitialization", "= true, use homotopy method [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,2563)
DeclareVariable("pumpBuiding.heaDis.motorCooledByFluid", "Flag, true if the motor is cooled by the fluid stream [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,2563)
DeclareVariable("pumpBuiding.heaDis.delta_V_flow", "Factor used for setting heat input into medium to zero at very small flows [m3/s]",\
 5.022167848884978E-07, 0.0,0.0,0.0,0,2561)
DeclareAlias2("pumpBuiding.heaDis.etaHyd", "Hydraulic efficiency [1]", \
"pumpBuiding.etaHyd", 1, 5, 1078, 1024)
DeclareAlias2("pumpBuiding.heaDis.V_flow", "Volume flow rate [m3/s]", \
"pumpBuiding.VMachine_flow", 1, 5, 1075, 1024)
DeclareAlias2("pumpBuiding.heaDis.WFlo", "Flow work [W]", "pumpBuiding.eff.WFlo", 1,\
 5, 1194, 1024)
DeclareAlias2("pumpBuiding.heaDis.PEle", "Electrical power consumed [W]", \
"pumpBuiding.P", 1, 5, 1072, 1024)
DeclareVariable("pumpBuiding.heaDis.Q_flow", "Heat input from fan or pump to medium [W]",\
 0.0, 0.0,0.0,0.0,0,2560)
DeclareVariable("pumpBuiding.heaDis.WHyd", "Hydraulic power input (converted to flow work and heat) [W]",\
 0.0, 0.0,0.0,0.0,0,2560)
DeclareVariable("pumpBuiding.heaDis.QThe_flow", "Heat input from fan or pump to medium [W]",\
 0.0, 0.0,0.0,0.0,0,2560)
DeclareAlias2("pumpBuiding.PToMed.u1", "Connector of Real input signal 1", \
"pumpBuiding.heaDis.Q_flow", 1, 5, 1151, 1024)
DeclareAlias2("pumpBuiding.PToMed.u2", "Connector of Real input signal 2", \
"pumpBuiding.eff.WFlo", 1, 5, 1194, 1024)
DeclareAlias2("pumpBuiding.PToMed.y", "Connector of Real output signal", \
"pumpBuiding.vol.heatPort.Q_flow", 1, 5, 1118, 1024)
DeclareVariable("pumpBuiding.PToMed.k1", "Gain of upper input", 1, 0.0,0.0,0.0,0,2561)
DeclareVariable("pumpBuiding.PToMed.k2", "Gain of lower input", 1, 0.0,0.0,0.0,0,2561)
DeclareParameter("pumpBuiding.prePow.T_ref", "Reference temperature [K|degC]", 342,\
 293.15, 0.0,1E+100,300.0,0,2608)
DeclareVariable("pumpBuiding.prePow.alpha", "Temperature coefficient of heat flow rate [1/K]",\
 0, 0.0,0.0,0.0,0,2561)
DeclareAlias2("pumpBuiding.prePow.Q_flow", "[W]", "pumpBuiding.vol.heatPort.Q_flow", 1,\
 5, 1118, 1024)
DeclareAlias2("pumpBuiding.prePow.port.T", "Port temperature [K|degC]", \
"pumpBuiding.heatPort.T", 1, 5, 1073, 1028)
EndNonAlias(0)
PreNonAliasNew(1)
StartNonAlias(1)
DeclareAlias2("pumpBuiding.prePow.port.Q_flow", "Heat flow rate (positive if flowing from outside into the component) [W]",\
 "pumpBuiding.vol.heatPort.Q_flow", -1, 5, 1118, 1156)
DeclareVariable("pumpBuiding.rho_inlet.y", "Value of Real output", 995.586, \
0.0,0.0,0.0,0,2561)
DeclareVariable("pumpBuiding.senMasFlo.allowFlowReversal", "= false to simplify equations, assuming, but not enforcing, no flow reversal [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,2563)
DeclareAlias2("pumpBuiding.senMasFlo.port_a.m_flow", "Mass flow rate from the connection point into the component [kg/s]",\
 "coo.port_a2.m_flow", 1, 5, 615, 1156)
DeclareAlias2("pumpBuiding.senMasFlo.port_a.p", "Thermodynamic pressure in the connection point [Pa|bar]",\
 "exp.p_start", 1, 7, 345, 1028)
DeclareAlias2("pumpBuiding.senMasFlo.port_a.h_outflow", "Specific thermodynamic enthalpy close to the connection point if m_flow < 0 [J/kg]",\
 "pumpBuiding.vol.ports[2].h_outflow", 1, 5, 1107, 1028)
DeclareAlias2("pumpBuiding.senMasFlo.port_b.m_flow", "Mass flow rate from the connection point into the component [kg/s]",\
 "coo.port_a2.m_flow", -1, 5, 615, 1156)
DeclareAlias2("pumpBuiding.senMasFlo.port_b.p", "Thermodynamic pressure in the connection point [Pa|bar]",\
 "exp.p_start", 1, 7, 345, 1028)
DeclareAlias2("pumpBuiding.senMasFlo.port_b.h_outflow", "Specific thermodynamic enthalpy close to the connection point if m_flow < 0 [J/kg]",\
 "pumpBuiding.vol.ports[2].h_outflow", 1, 5, 1107, 1028)
DeclareVariable("pumpBuiding.senMasFlo.m_flow_nominal", "Nominal mass flow rate, used for regularization near zero flow [kg/s]",\
 0, 0.0,1E+100,0.0,0,2561)
DeclareVariable("pumpBuiding.senMasFlo.m_flow_small", "For bi-directional flow, temperature is regularized in the region |m_flow| < m_flow_small (m_flow_small > 0 required) [kg/s]",\
 0, 0.0,1E+100,0.0,0,2561)
DeclareAlias2("pumpBuiding.senMasFlo.m_flow", "Mass flow rate from port_a to port_b [kg/s]",\
 "coo.port_a2.m_flow", 1, 5, 615, 1024)
DeclareVariable("pumpBuiding.senRelPre.port_a.m_flow", "Mass flow rate from the connection point into the component [kg/s]",\
 0, 0.0,100000.0,0.0,0,2825)
DeclareAlias2("pumpBuiding.senRelPre.port_a.p", "Thermodynamic pressure in the connection point [Pa|bar]",\
 "pumpBuiding.port_b.p", 1, 5, 1047, 1028)
DeclareVariable("pumpBuiding.senRelPre.port_a.h_outflow", "Specific thermodynamic enthalpy close to the connection point if m_flow < 0 [J/kg]",\
 0, -10000000000.0,10000000000.0,1000000.0,0,2569)
DeclareVariable("pumpBuiding.senRelPre.port_b.m_flow", "Mass flow rate from the connection point into the component [kg/s]",\
 0, 0.0,100000.0,0.0,0,2825)
DeclareAlias2("pumpBuiding.senRelPre.port_b.p", "Thermodynamic pressure in the connection point [Pa|bar]",\
 "exp.p_start", 1, 7, 345, 1028)
DeclareVariable("pumpBuiding.senRelPre.port_b.h_outflow", "Specific thermodynamic enthalpy close to the connection point if m_flow < 0 [J/kg]",\
 0, -10000000000.0,10000000000.0,1000000.0,0,2569)
DeclareVariable("pumpBuiding.senRelPre.p_rel", "Relative pressure of port_a minus port_b [Pa|Pa]",\
 0.0, 0.0,0.0,0.0,0,2560)
DeclareVariable("pumpBuiding.eff.per.pressure.V_flow[1]", "Volume flow rate at user-selected operating points [m3/s]",\
 0.0, 0.0,1E+100,0.0,0,2561)
DeclareVariable("pumpBuiding.eff.per.pressure.V_flow[2]", "Volume flow rate at user-selected operating points [m3/s]",\
 0.0010044335697769957, 0.0,1E+100,0.0,0,2561)
DeclareVariable("pumpBuiding.eff.per.pressure.dp[1]", "Fan or pump total pressure at these flow rates [Pa|Pa]",\
 12000.0, 0.0,1E+100,0.0,0,2561)
DeclareVariable("pumpBuiding.eff.per.pressure.dp[2]", "Fan or pump total pressure at these flow rates [Pa|Pa]",\
 0.0, 0.0,1E+100,0.0,0,2561)
DeclareVariable("pumpBuiding.eff.per.use_powerCharacteristic", "Use power data instead of motor efficiency [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,2563)
DeclareVariable("pumpBuiding.eff.per.hydraulicEfficiency.V_flow[1]", \
"Volumetric flow rate at user-selected operating points [m3/s]", 0.0, 0.0,1E+100,\
0.0,0,2561)
DeclareVariable("pumpBuiding.eff.per.hydraulicEfficiency.eta[1]", \
"Fan or pump efficiency at these flow rates [1]", 0.0, 0.0,1.0,0.0,0,2561)
DeclareVariable("pumpBuiding.eff.per.motorEfficiency.V_flow[1]", \
"Volumetric flow rate at user-selected operating points [m3/s]", 0.0, 0.0,1E+100,\
0.0,0,2561)
DeclareVariable("pumpBuiding.eff.per.motorEfficiency.eta[1]", "Fan or pump efficiency at these flow rates [1]",\
 0.0, 0.0,1.0,0.0,0,2561)
DeclareVariable("pumpBuiding.eff.per.power.V_flow[1]", "Volume flow rate at user-selected operating points [m3/s]",\
 0.0, 0.0,1E+100,0.0,0,2561)
DeclareVariable("pumpBuiding.eff.per.power.P[1]", "Fan or pump electrical power at these flow rates [W]",\
 0.0, 0.0,1E+100,0.0,0,2561)
DeclareVariable("pumpBuiding.eff.per.motorCooledByFluid", "If true, then motor heat is added to fluid stream [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,2563)
DeclareVariable("pumpBuiding.eff.per.speed_nominal", "Nominal rotational speed for flow characteristic [1]",\
 0, 0.0,1E+100,0.0,0,2561)
DeclareVariable("pumpBuiding.eff.per.constantSpeed", "Normalized speed set point, used if inputType = Buildings.Fluid.Types.InputType.Constant [1]",\
 0, 0.0,1E+100,0.0,0,2561)
DeclareVariable("pumpBuiding.eff.per.speeds[1]", "Vector of normalized speed set points, used if inputType = Buildings.Fluid.Types.InputType.Stages [1]",\
 0, 0.0,1E+100,0.0,0,2561)
DeclareParameter("pumpBuiding.eff.per.speed_rpm_nominal", "Nominal rotational speed for flow characteristic [rev/min]",\
 343, 1500, 0.0,0.0,0.0,0,2608)
DeclareVariable("pumpBuiding.eff.per.constantSpeed_rpm", "Speed set point, used if inputType = Buildings.Fluid.Types.InputType.Constant [rev/min]",\
 0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("pumpBuiding.eff.per.speeds_rpm[1]", "Vector of speed set points, used if inputType = Buildings.Fluid.Types.InputType.Stages [rev/min]",\
 0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("pumpBuiding.eff.per.havePressureCurve", "= true, if default record values are being used [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,2563)
DeclareVariable("pumpBuiding.eff.preVar", "Type of prescribed variable [:#(type=Buildings.Fluid.Movers.BaseClasses.Types.PrescribedVariable)]",\
 2, 1.0,3.0,0.0,0,2565)
DeclareVariable("pumpBuiding.eff.computePowerUsingSimilarityLaws", \
"= true, compute power exactly, using similarity laws. Otherwise approximate. [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,2563)
DeclareVariable("pumpBuiding.eff.V_flow_nominal", "Nominal volume flow rate, used for homotopy [m3/s]",\
 0.0010044335697769957, 0.0,0.0,0.0,0,2561)
DeclareVariable("pumpBuiding.eff.rho_default", "Fluid density at medium default state [kg/m3|g/cm3]",\
 995.586, 0.0,1E+100,0.0,0,2561)
DeclareVariable("pumpBuiding.eff.haveVMax", "Flag, true if user specified data that contain V_flow_max [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,2563)
DeclareVariable("pumpBuiding.eff.V_flow_max", "Maximum volume flow rate, used for smoothing [m3/s]",\
 0.0005022167848884978, 0.0,0.0,0.0,0,2561)
DeclareVariable("pumpBuiding.eff.nOri", "Number of data points for pressure curve [:#(type=Integer)]",\
 2, 1.0,1E+100,0.0,0,2565)
DeclareVariable("pumpBuiding.eff.homotopyInitialization", "= true, use homotopy method [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,2563)
DeclareVariable("pumpBuiding.eff.y_out", "Mover speed (prescribed or computed) [1]",\
 1.0, 0.0,0.0,0.0,0,2561)
DeclareAlias2("pumpBuiding.eff.m_flow", "Mass flow rate [kg/s]", \
"coo.port_a2.m_flow", 1, 5, 615, 1024)
DeclareVariable("pumpBuiding.eff.rho", "Medium density [kg/m3]", 995.586, 0.0,\
1E+100,0.0,0,2561)
DeclareAlias2("pumpBuiding.eff.V_flow", "Volume flow rate [m3/s]", \
"pumpBuiding.VMachine_flow", 1, 5, 1075, 1024)
DeclareVariable("pumpBuiding.eff.WFlo", "Flow work [W]", 0.0, 0.0,0.0,0.0,0,2560)
DeclareAlias2("pumpBuiding.eff.PEle", "Electrical power consumed [W]", \
"pumpBuiding.P", 1, 5, 1072, 1024)
DeclareAlias2("pumpBuiding.eff.eta", "Overall efficiency [1]", "pumpBuiding.eta", 1,\
 5, 1077, 1024)
DeclareAlias2("pumpBuiding.eff.etaHyd", "Hydraulic efficiency [1]", \
"pumpBuiding.etaHyd", 1, 5, 1078, 1024)
DeclareAlias2("pumpBuiding.eff.etaMot", "Motor efficiency [1]", "pumpBuiding.etaMot", 1,\
 5, 1079, 1024)
DeclareVariable("pumpBuiding.eff.r_N", "Ratio N_actual/N_nominal [1]", 1.0, \
0.0,0.0,0.0,0,2561)
DeclareVariable("pumpBuiding.eff.r_V", "Ratio V_flow/V_flow_max [1]", \
0.0005022167848884978, 0.0,0.0,0.0,0,2560)
DeclareVariable("pumpBuiding.eff.preSpe", "True if speed is a prescribed variable of this block [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,2563)
DeclareVariable("pumpBuiding.eff.prePre", "True if pressure head is a prescribed variable of this block [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,2563)
DeclareVariable("pumpBuiding.eff.motDer[1]", "Coefficients for polynomial of motor efficiency vs. volume flow rate",\
 0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("pumpBuiding.eff.hydDer[1]", "Coefficients for polynomial of hydraulic efficiency vs. volume flow rate",\
 0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("pumpBuiding.eff.dpMax", "Maximum head [Pa|Pa]", 12000.0, \
0.0,0.0,0.0,0,2561)
DeclareVariable("pumpBuiding.eff.delta", "Small value used to for regularization and to approximate an internal flow resistance of the fan",\
 0.05, 0.0,0.0,0.0,0,2561)
DeclareVariable("pumpBuiding.eff.kRes", "Coefficient for internal pressure drop of fan or pump [kg/(s.m4)]",\
 5973.516000000001, 0.0,1E+100,0.0,0,2561)
DeclareVariable("pumpBuiding.eff.curve", "Flag, used to pick the right representatio of the fan or pump pressure curve [:#(type=Integer)]",\
 1, 0.0,0.0,0.0,0,2565)
DeclareVariable("pumpBuiding.eff.pCur1.n", "Number of elements in each array [:#(type=Integer)]",\
 2, 0.0,0.0,0.0,0,2565)
DeclareVariable("pumpBuiding.eff.pCur1.V_flow[1]", "Volume flow rate at user-selected operating points [m3/s]",\
 0.0, 0.0,1E+100,0.0,0,2561)
DeclareVariable("pumpBuiding.eff.pCur1.V_flow[2]", "Volume flow rate at user-selected operating points [m3/s]",\
 0.0010044335697769957, 0.0,1E+100,0.0,0,2561)
DeclareVariable("pumpBuiding.eff.pCur1.dp[1]", "Fan or pump total pressure at these flow rates [Pa|Pa]",\
 12000.0, 0.0,1E+100,0.0,0,2561)
DeclareVariable("pumpBuiding.eff.pCur1.dp[2]", "Fan or pump total pressure at these flow rates [Pa|Pa]",\
 0.0, 0.0,1E+100,0.0,0,2561)
DeclareVariable("pumpBuiding.eff.pCur2.n", "Number of elements in each array [:#(type=Integer)]",\
 3, 0.0,0.0,0.0,0,2565)
DeclareVariable("pumpBuiding.eff.pCur2.V_flow[1]", "Volume flow rate at user-selected operating points [m3/s]",\
 0, 0.0,1E+100,0.0,0,2561)
DeclareVariable("pumpBuiding.eff.pCur2.V_flow[2]", "Volume flow rate at user-selected operating points [m3/s]",\
 0, 0.0,1E+100,0.0,0,2561)
DeclareVariable("pumpBuiding.eff.pCur2.V_flow[3]", "Volume flow rate at user-selected operating points [m3/s]",\
 0, 0.0,1E+100,0.0,0,2561)
DeclareVariable("pumpBuiding.eff.pCur2.dp[1]", "Fan or pump total pressure at these flow rates [Pa|Pa]",\
 0, 0.0,1E+100,0.0,0,2561)
DeclareVariable("pumpBuiding.eff.pCur2.dp[2]", "Fan or pump total pressure at these flow rates [Pa|Pa]",\
 0, 0.0,1E+100,0.0,0,2561)
DeclareVariable("pumpBuiding.eff.pCur2.dp[3]", "Fan or pump total pressure at these flow rates [Pa|Pa]",\
 0, 0.0,1E+100,0.0,0,2561)
DeclareVariable("pumpBuiding.eff.pCur3.n", "Number of elements in each array [:#(type=Integer)]",\
 4, 0.0,0.0,0.0,0,2565)
DeclareVariable("pumpBuiding.eff.pCur3.V_flow[1]", "Volume flow rate at user-selected operating points [m3/s]",\
 0, 0.0,1E+100,0.0,0,2561)
DeclareVariable("pumpBuiding.eff.pCur3.V_flow[2]", "Volume flow rate at user-selected operating points [m3/s]",\
 0, 0.0,1E+100,0.0,0,2561)
DeclareVariable("pumpBuiding.eff.pCur3.V_flow[3]", "Volume flow rate at user-selected operating points [m3/s]",\
 0, 0.0,1E+100,0.0,0,2561)
DeclareVariable("pumpBuiding.eff.pCur3.V_flow[4]", "Volume flow rate at user-selected operating points [m3/s]",\
 0, 0.0,1E+100,0.0,0,2561)
DeclareVariable("pumpBuiding.eff.pCur3.dp[1]", "Fan or pump total pressure at these flow rates [Pa|Pa]",\
 0, 0.0,1E+100,0.0,0,2561)
DeclareVariable("pumpBuiding.eff.pCur3.dp[2]", "Fan or pump total pressure at these flow rates [Pa|Pa]",\
 0, 0.0,1E+100,0.0,0,2561)
DeclareVariable("pumpBuiding.eff.pCur3.dp[3]", "Fan or pump total pressure at these flow rates [Pa|Pa]",\
 0, 0.0,1E+100,0.0,0,2561)
DeclareVariable("pumpBuiding.eff.pCur3.dp[4]", "Fan or pump total pressure at these flow rates [Pa|Pa]",\
 0, 0.0,1E+100,0.0,0,2561)
DeclareVariable("pumpBuiding.eff.preDer1[1]", "Derivatives of flow rate vs. pressure at the support points",\
 0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("pumpBuiding.eff.preDer1[2]", "Derivatives of flow rate vs. pressure at the support points",\
 0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("pumpBuiding.eff.preDer2[1]", "Derivatives of flow rate vs. pressure at the support points",\
 0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("pumpBuiding.eff.preDer2[2]", "Derivatives of flow rate vs. pressure at the support points",\
 0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("pumpBuiding.eff.preDer2[3]", "Derivatives of flow rate vs. pressure at the support points",\
 0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("pumpBuiding.eff.preDer3[1]", "Derivatives of flow rate vs. pressure at the support points",\
 0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("pumpBuiding.eff.preDer3[2]", "Derivatives of flow rate vs. pressure at the support points",\
 0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("pumpBuiding.eff.preDer3[3]", "Derivatives of flow rate vs. pressure at the support points",\
 0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("pumpBuiding.eff.preDer3[4]", "Derivatives of flow rate vs. pressure at the support points",\
 0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("pumpBuiding.eff.powDer[1]", "Coefficients for polynomial of power vs. flow rate",\
 0, 0.0,0.0,0.0,0,2561)
DeclareVariable("pumpBuiding.eff.haveMinimumDecrease", "Flag used for reporting [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,2563)
DeclareVariable("pumpBuiding.eff.haveDPMax", "Flag, true if user specified data that contain dpMax [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,2563)
DeclareAlias2("pumpBuiding.eff.dp_internal", "If dp is prescribed, use dp_in and solve for r_N, otherwise compute dp using r_N",\
 "pumpBuiding.senRelPre.p_rel", 1, 5, 1165, 1024)
DeclareVariable("pumpBuiding.dp_nominal", "Nominal pressure raise, used for default pressure curve if not specified in record per [Pa|Pa]",\
 6000, 0.0,1E+100,0.0,0,513)
DeclareParameter("pumpBuiding.m_flow_start", "Initial value of mass flow rate [kg/s]",\
 344, 0, 0.0,1E+100,0.0,0,560)
DeclareVariable("pumpBuiding.constantMassFlowRate", "Constant pump mass flow rate, used when inputType=Constant [kg/s]",\
 0.5, 0.0,0.0,0.0,0,513)
DeclareVariable("pumpBuiding.massFlowRates[1]", "Vector of mass flow rate set points, used when inputType=Stage [kg/s]",\
 0.5, 0.0,0.0,0.0,0,513)
DeclareAlias2("pumpBuiding.m_flow_in", "Prescribed mass flow rate [kg/s]", \
"gain1.y", 1, 5, 1318, 0)
DeclareAlias2("pumpBuiding.m_flow_actual", "Actual mass flow rate [kg/s]", \
"coo.port_a2.m_flow", 1, 5, 615, 0)
DeclareVariable("exp.energyDynamics", "Type of energy balance: dynamic (3 initialization options) or steady state [:#(type=Modelica.Fluid.Types.Dynamics)]",\
 2, 1.0,4.0,0.0,0,517)
DeclareVariable("exp.massDynamics", "Type of mass balance: dynamic (3 initialization options) or steady state [:#(type=Modelica.Fluid.Types.Dynamics)]",\
 2, 1.0,4.0,0.0,0,517)
DeclareVariable("exp.substanceDynamics", "Type of independent mass fraction balance: dynamic (3 initialization options) or steady state [:#(type=Modelica.Fluid.Types.Dynamics)]",\
 2, 1.0,4.0,0.0,0,517)
DeclareVariable("exp.traceDynamics", "Type of trace substance balance: dynamic (3 initialization options) or steady state [:#(type=Modelica.Fluid.Types.Dynamics)]",\
 2, 1.0,4.0,0.0,0,517)
DeclareParameter("exp.p_start", "Start value of pressure [Pa|bar]", 345, 300000,\
 0.0,100000000.0,100000.0,0,560)
DeclareParameter("exp.T_start", "Start value of temperature [K|degC]", 346, \
293.15, 1.0,10000.0,300.0,0,560)
DeclareParameter("exp.X_start[1]", "Start value of mass fractions m_i/m [kg/kg]",\
 347, 1, 0.0,1.0,0.1,0,560)
DeclareVariable("exp.mSenFac", "Factor for scaling the sensible thermal mass of the volume",\
 1, 1.0,1E+100,0.0,0,513)
DeclareParameter("exp.V_start", "Volume of liquid stored in the vessel at the start of the simulation [m3]",\
 348, 1000, 0.0,0.0,0.0,0,560)
DeclareParameter("exp.p", "Constant pressure of the expansion vessel [Pa|bar]", 349,\
 300000, 0.0,0.0,0.0,0,560)
DeclareAlias2("exp.port_a.m_flow", "Mass flow rate from the connection point into the component [kg/s]",\
 "exp.der(m)", 1, 6, 10, 132)
DeclareAlias2("exp.port_a.p", "Thermodynamic pressure in the connection point [Pa|bar]",\
 "exp.p_start", 1, 7, 345, 4)
DeclareVariable("exp.port_a.h_outflow", "Specific thermodynamic enthalpy close to the connection point if m_flow < 0 [J/kg]",\
 83680.0, -10000000000.0,10000000000.0,1000000.0,0,520)
DeclareState("exp.m", "Mass of liquid in the vessel [kg]", 10, 0.0, 0.0,1E+100,\
0.0,0,544)
DeclareDerivative("exp.der(m)", "der(Mass of liquid in the vessel) [kg/s]", 0.0,\
 0.0,0.0,0.0,0,513)
DeclareVariable("exp.state_start.p", "Absolute pressure of medium [Pa|bar]", 300000,\
 0.0,100000000.0,100000.0,0,2561)
DeclareVariable("exp.state_start.T", "Temperature of medium [K|degC]", 293.15, \
1.0,10000.0,300.0,0,2561)
DeclareVariable("exp.rho_start", "Density, used to compute start and guess values [kg/m3|g/cm3]",\
 995.586, 0.0,1E+100,0.0,0,2561)
DeclareState("exp.H", "Internal energy of fluid [J]", 11, 0.0, 0.0,0.0,0.0,0,2592)
DeclareDerivative("exp.der(H)", "der(Internal energy of fluid) [W]", 0.0, \
0.0,0.0,0.0,0,2560)
DeclareVariable("CoolingUnit.allowFlowReversal", "= false to simplify equations, assuming, but not enforcing, no flow reversal [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,515)
DeclareAlias2("CoolingUnit.port_a.m_flow", "Mass flow rate from the connection point into the component [kg/s]",\
 "coo.port_a2.m_flow", 1, 5, 615, 132)
DeclareAlias2("CoolingUnit.port_a.p", "Thermodynamic pressure in the connection point [Pa|bar]",\
 "pumpBuiding.port_b.p", 1, 5, 1047, 4)
DeclareVariable("CoolingUnit.port_a.h_outflow", "Specific thermodynamic enthalpy close to the connection point if m_flow < 0 [J/kg]",\
 0.0, -10000000000.0,10000000000.0,83680.0,0,520)
DeclareAlias2("CoolingUnit.port_b.m_flow", "Mass flow rate from the connection point into the component [kg/s]",\
 "coo.port_a2.m_flow", -1, 5, 615, 132)
DeclareAlias2("CoolingUnit.port_b.p", "Thermodynamic pressure in the connection point [Pa|bar]",\
 "coo.port_a2.p", 1, 5, 616, 4)
DeclareAlias2("CoolingUnit.port_b.h_outflow", "Specific thermodynamic enthalpy close to the connection point if m_flow < 0 [J/kg]",\
 "CoolingUnit.port_a.h_outflow", 1, 5, 1251, 4)
DeclareVariable("CoolingUnit.m_flow_nominal", "Nominal mass flow rate [kg/s]", \
0.5, 0.0,0.0,0.0,0,513)
DeclareVariable("CoolingUnit.m_flow_small", "Small mass flow rate for regularization of zero flow [kg/s]",\
 5E-05, 0.0,1E+100,0.0,0,513)
DeclareVariable("CoolingUnit.show_T", "= true, if actual temperature at port is computed [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,515)
DeclareAlias2("CoolingUnit.m_flow", "Mass flow rate from port_a to port_b (m_flow > 0 is design flow direction) [kg/s]",\
 "coo.port_a2.m_flow", 1, 5, 615, 0)
DeclareVariable("CoolingUnit.dp", "Pressure difference between port_a and port_b [Pa|Pa]",\
 0, 0.0,0.0,0.0,0,512)
DeclareVariable("CoolingUnit._m_flow_start", "Start value for m_flow, used to avoid a warning if not set in m_flow, and to avoid m_flow.start in parameter window [kg/s]",\
 0, 0.0,0.0,0.0,0,2561)
DeclareVariable("CoolingUnit._dp_start", "Start value for dp, used to avoid a warning if not set in dp, and to avoid dp.start in parameter window [Pa|Pa]",\
 0, 0.0,0.0,0.0,0,2561)
DeclareVariable("CoolingUnit.computeFlowResistance", "=true, compute flow resistance. Set to false to assume no friction [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,515)
DeclareVariable("CoolingUnit.from_dp", "= true, use m_flow = f(dp) else dp = f(m_flow) [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,515)
DeclareVariable("CoolingUnit.dp_nominal", "Pressure difference [Pa|Pa]", 2, 0.0,\
1E+100,0.0,0,513)
DeclareVariable("CoolingUnit.linearizeFlowResistance", "= true, use linear relation between m_flow and dp for any flow rate [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,515)
DeclareVariable("CoolingUnit.deltaM", "Fraction of nominal flow rate where flow transitions to laminar",\
 0.1, 0.0,0.0,0.0,0,513)
DeclareParameter("CoolingUnit.tau", "Time constant at nominal flow (if energyDynamics <> SteadyState) [s]",\
 350, 30, 0.0,0.0,0.0,0,560)
DeclareVariable("CoolingUnit.homotopyInitialization", "= true, use homotopy method [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,515)
DeclareVariable("CoolingUnit.energyDynamics", "Type of energy balance: dynamic (3 initialization options) or steady state [:#(type=Modelica.Fluid.Types.Dynamics)]",\
 1, 1.0,4.0,0.0,0,517)
DeclareVariable("CoolingUnit.massDynamics", "Type of mass balance: dynamic (3 initialization options) or steady state [:#(type=Modelica.Fluid.Types.Dynamics)]",\
 1, 1.0,4.0,0.0,0,517)
DeclareParameter("CoolingUnit.p_start", "Start value of pressure [Pa|bar]", 351,\
 300000, 0.0,100000000.0,100000.0,0,560)
DeclareParameter("CoolingUnit.T_start", "Start value of temperature [K|degC]", 352,\
 293.15, 1.0,10000.0,300.0,0,560)
DeclareParameter("CoolingUnit.X_start[1]", "Start value of mass fractions m_i/m [kg/kg]",\
 353, 1, 0.0,1.0,0.1,0,560)
DeclareVariable("CoolingUnit.vol.energyDynamics", "Type of energy balance: dynamic (3 initialization options) or steady state [:#(type=Modelica.Fluid.Types.Dynamics)]",\
 1, 1.0,4.0,0.0,0,517)
DeclareVariable("CoolingUnit.vol.massDynamics", "Type of mass balance: dynamic (3 initialization options) or steady state [:#(type=Modelica.Fluid.Types.Dynamics)]",\
 1, 1.0,4.0,0.0,0,517)
DeclareVariable("CoolingUnit.vol.substanceDynamics", "Type of independent mass fraction balance: dynamic (3 initialization options) or steady state [:#(type=Modelica.Fluid.Types.Dynamics)]",\
 1, 1.0,4.0,0.0,0,517)
DeclareVariable("CoolingUnit.vol.traceDynamics", "Type of trace substance balance: dynamic (3 initialization options) or steady state [:#(type=Modelica.Fluid.Types.Dynamics)]",\
 1, 1.0,4.0,0.0,0,517)
DeclareVariable("CoolingUnit.vol.p_start", "Start value of pressure [Pa|bar]", 300000,\
 0.0,100000000.0,100000.0,0,513)
DeclareVariable("CoolingUnit.vol.T_start", "Start value of temperature [K|degC]",\
 293.15, 1.0,10000.0,300.0,0,513)
DeclareVariable("CoolingUnit.vol.X_start[1]", "Start value of mass fractions m_i/m [kg/kg]",\
 0.0, 0.0,1.0,0.1,0,513)
DeclareVariable("CoolingUnit.vol.mSenFac", "Factor for scaling the sensible thermal mass of the volume",\
 1, 1.0,1E+100,0.0,0,513)
DeclareVariable("CoolingUnit.vol.initialize_p", "= true to set up initial equations for pressure [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,1539)
DeclareVariable("CoolingUnit.vol.prescribedHeatFlowRate", "Set to true if the model has a prescribed heat flow at its heatPort. If the heat flow rate at the heatPort is only based on temperature difference, then set to false [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,515)
DeclareVariable("CoolingUnit.vol.simplify_mWat_flow", "Set to true to cause port_a.m_flow + port_b.m_flow = 0 even if mWat_flow is non-zero [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,515)
DeclareVariable("CoolingUnit.vol.m_flow_nominal", "Nominal mass flow rate [kg/s]",\
 0.5, 0.0,1E+100,0.0,0,513)
DeclareVariable("CoolingUnit.vol.nPorts", "Number of ports [:#(type=Integer)]", 2,\
 0.0,0.0,0.0,0,517)
DeclareVariable("CoolingUnit.vol.m_flow_small", "Small mass flow rate for regularization of zero flow [kg/s]",\
 5E-05, 0.0,1E+100,0.0,0,513)
DeclareVariable("CoolingUnit.vol.allowFlowReversal", "= false to simplify equations, assuming, but not enforcing, no flow reversal. Used only if model has two ports. [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,515)
DeclareVariable("CoolingUnit.vol.V", "Volume [m3]", 0.0, 0.0,0.0,0.0,0,513)
DeclareAlias2("CoolingUnit.vol.ports[1].m_flow", "Mass flow rate from the connection point into the component [kg/s]",\
 "coo.port_a2.m_flow", 1, 5, 615, 132)
DeclareAlias2("CoolingUnit.vol.ports[1].p", "Thermodynamic pressure in the connection point [Pa|bar]",\
 "coo.port_a2.p", 1, 5, 616, 4)
DeclareAlias2("CoolingUnit.vol.ports[1].h_outflow", "Specific thermodynamic enthalpy close to the connection point if m_flow < 0 [J/kg]",\
 "CoolingUnit.port_a.h_outflow", 1, 5, 1251, 4)
DeclareAlias2("CoolingUnit.vol.ports[2].m_flow", "Mass flow rate from the connection point into the component [kg/s]",\
 "coo.port_a2.m_flow", -1, 5, 615, 132)
DeclareAlias2("CoolingUnit.vol.ports[2].p", "Thermodynamic pressure in the connection point [Pa|bar]",\
 "coo.port_a2.p", 1, 5, 616, 4)
DeclareAlias2("CoolingUnit.vol.ports[2].h_outflow", "Specific thermodynamic enthalpy close to the connection point if m_flow < 0 [J/kg]",\
 "CoolingUnit.port_a.h_outflow", 1, 5, 1251, 4)
DeclareVariable("CoolingUnit.vol.T", "Temperature of the fluid [K|degC]", 300.0,\
 1.0,10000.0,300.0,0,512)
DeclareAlias2("CoolingUnit.vol.U", "Internal energy of the component [J]", \
"CoolingUnit.vol.dynBal.U", 1, 1, 20, 0)
DeclareAlias2("CoolingUnit.vol.p", "Pressure of the fluid [Pa|bar]", \
"coo.port_a2.p", 1, 5, 616, 0)
DeclareAlias2("CoolingUnit.vol.m", "Mass of the component [kg]", \
"CoolingUnit.vol.dynBal.m", 1, 5, 1498, 0)
DeclareVariable("CoolingUnit.vol.rho_start", "Density, used to compute start and guess values [kg/m3|g/cm3]",\
 995.586, 0.0,1E+100,0.0,0,2561)
DeclareVariable("CoolingUnit.vol.state_default.p", "Absolute pressure of medium [Pa|bar]",\
 300000.0, 0.0,100000000.0,100000.0,0,2561)
DeclareVariable("CoolingUnit.vol.state_default.T", "Temperature of medium [K|degC]",\
 293.15, 1.0,10000.0,300.0,0,2561)
DeclareVariable("CoolingUnit.vol.rho_default", "Density, used to compute fluid mass [kg/m3|g/cm3]",\
 995.586, 0.0,1E+100,0.0,0,2561)
DeclareVariable("CoolingUnit.vol.state_start.p", "Absolute pressure of medium [Pa|bar]",\
 300000, 0.0,100000000.0,100000.0,0,2561)
DeclareVariable("CoolingUnit.vol.state_start.T", "Temperature of medium [K|degC]",\
 293.15, 1.0,10000.0,300.0,0,2561)
DeclareVariable("CoolingUnit.vol.useSteadyStateTwoPort", "Flag, true if the model has two ports only and uses a steady state balance [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,2563)
DeclareAlias2("CoolingUnit.vol.hOut_internal", "Internal connector for leaving temperature of the component [J/kg]",\
 "CoolingUnit.port_a.h_outflow", 1, 5, 1251, 1024)
DeclareAlias2("CoolingUnit.vol.preTem.port.T", "Port temperature [K|degC]", \
"CoolingUnit.vol.T", 1, 5, 1282, 1028)
DeclareAlias2("CoolingUnit.vol.preTem.port.Q_flow", "Heat flow rate (positive if flowing from outside into the component) [W]",\
 "CoolingUnit.Q_flow", 1, 5, 1315, 1156)
DeclareAlias2("CoolingUnit.vol.preTem.T", "", "CoolingUnit.vol.T", 1, 5, 1282, 1024)
DeclareAlias2("CoolingUnit.vol.portT.y", "Value of Real output", \
"CoolingUnit.vol.T", 1, 5, 1282, 1024)
DeclareAlias2("CoolingUnit.vol.heaFloSen.Q_flow", "Heat flow from port_a to port_b as output signal [W]",\
 "CoolingUnit.Q_flow", 1, 5, 1315, 1024)
DeclareAlias2("CoolingUnit.vol.heaFloSen.port_a.T", "Port temperature [K|degC]",\
 "CoolingUnit.vol.T", 1, 5, 1282, 1028)
DeclareAlias2("CoolingUnit.vol.heaFloSen.port_a.Q_flow", "Heat flow rate (positive if flowing from outside into the component) [W]",\
 "CoolingUnit.Q_flow", 1, 5, 1315, 1156)
DeclareAlias2("CoolingUnit.vol.heaFloSen.port_b.T", "Port temperature [K|degC]",\
 "CoolingUnit.vol.T", 1, 5, 1282, 1028)
DeclareAlias2("CoolingUnit.vol.heaFloSen.port_b.Q_flow", "Heat flow rate (positive if flowing from outside into the component) [W]",\
 "CoolingUnit.Q_flow", -1, 5, 1315, 1156)
DeclareVariable("CoolingUnit.vol.use_C_flow", "Set to true to enable input connector for trace substance [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,515)
DeclareAlias2("CoolingUnit.vol.heatPort.T", "Port temperature [K|degC]", \
"CoolingUnit.vol.T", 1, 5, 1282, 4)
DeclareAlias2("CoolingUnit.vol.heatPort.Q_flow", "Heat flow rate (positive if flowing from outside into the component) [W]",\
 "CoolingUnit.Q_flow", 1, 5, 1315, 132)
DeclareVariable("CoolingUnit.preDro.allowFlowReversal", "= false to simplify equations, assuming, but not enforcing, no flow reversal [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,515)
DeclareAlias2("CoolingUnit.preDro.port_a.m_flow", "Mass flow rate from the connection point into the component [kg/s]",\
 "coo.port_a2.m_flow", 1, 5, 615, 132)
DeclareAlias2("CoolingUnit.preDro.port_a.p", "Thermodynamic pressure in the connection point [Pa|bar]",\
 "pumpBuiding.port_b.p", 1, 5, 1047, 4)
DeclareAlias2("CoolingUnit.preDro.port_a.h_outflow", "Specific thermodynamic enthalpy close to the connection point if m_flow < 0 [J/kg]",\
 "CoolingUnit.port_a.h_outflow", 1, 5, 1251, 4)
DeclareAlias2("CoolingUnit.preDro.port_b.m_flow", "Mass flow rate from the connection point into the component [kg/s]",\
 "coo.port_a2.m_flow", -1, 5, 615, 132)
DeclareAlias2("CoolingUnit.preDro.port_b.p", "Thermodynamic pressure in the connection point [Pa|bar]",\
 "coo.port_a2.p", 1, 5, 616, 4)
DeclareAlias2("CoolingUnit.preDro.port_b.h_outflow", "Specific thermodynamic enthalpy close to the connection point if m_flow < 0 [J/kg]",\
 "pumpBuiding.port_b.h_outflow", 1, 5, 1048, 4)
DeclareVariable("CoolingUnit.preDro.m_flow_nominal", "Nominal mass flow rate [kg/s]",\
 0.5, 0.0,0.0,0.0,0,513)
DeclareVariable("CoolingUnit.preDro.m_flow_small", "Small mass flow rate for regularization of zero flow [kg/s]",\
 5E-05, 0.0,1E+100,0.0,0,513)
DeclareVariable("CoolingUnit.preDro.show_T", "= true, if actual temperature at port is computed [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,515)
DeclareAlias2("CoolingUnit.preDro.m_flow", "Mass flow rate from port_a to port_b (m_flow > 0 is design flow direction) [kg/s]",\
 "coo.port_a2.m_flow", 1, 5, 615, 0)
DeclareVariable("CoolingUnit.preDro.dp", "Pressure difference between port_a and port_b [Pa|Pa]",\
 0, 0.0,0.0,2.0,0,512)
DeclareVariable("CoolingUnit.preDro._m_flow_start", "Start value for m_flow, used to avoid a warning if not set in m_flow, and to avoid m_flow.start in parameter window [kg/s]",\
 0, 0.0,0.0,0.0,0,2561)
DeclareVariable("CoolingUnit.preDro._dp_start", "Start value for dp, used to avoid a warning if not set in dp, and to avoid dp.start in parameter window [Pa|Pa]",\
 0, 0.0,0.0,0.0,0,2561)
DeclareVariable("CoolingUnit.preDro.from_dp", "= true, use m_flow = f(dp) else dp = f(m_flow) [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,515)
DeclareVariable("CoolingUnit.preDro.dp_nominal", "Pressure drop at nominal mass flow rate [Pa|Pa]",\
 2, 0.0,0.0,0.0,0,513)
DeclareVariable("CoolingUnit.preDro.homotopyInitialization", "= true, use homotopy method [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,515)
DeclareVariable("CoolingUnit.preDro.linearized", "= true, use linear relation between m_flow and dp for any flow rate [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,515)
DeclareVariable("CoolingUnit.preDro.m_flow_turbulent", "Turbulent flow if |m_flow| >= m_flow_turbulent [kg/s]",\
 0.05, 0.0,1E+100,0.0,0,513)
DeclareParameter("CoolingUnit.preDro.sta_default.p", "Absolute pressure of medium [Pa|bar]",\
 354, 300000.0, 0.0,100000000.0,100000.0,0,2608)
DeclareParameter("CoolingUnit.preDro.sta_default.T", "Temperature of medium [K|degC]",\
 355, 293.15, 1.0,10000.0,300.0,0,2608)
DeclareVariable("CoolingUnit.preDro.eta_default", "Dynamic viscosity, used to compute transition to turbulent flow regime [Pa.s]",\
 0.001, 0.0,1E+100,0.0,0,2561)
DeclareVariable("CoolingUnit.preDro.m_flow_nominal_pos", "Absolute value of nominal flow rate [kg/s]",\
 0.5, 0.0,0.0,0.0,0,2561)
DeclareVariable("CoolingUnit.preDro.dp_nominal_pos", "Absolute value of nominal pressure difference [Pa|Pa]",\
 2, 0.0,0.0,0.0,0,2561)
DeclareVariable("CoolingUnit.preDro.deltaM", "Fraction of nominal mass flow rate where transition to turbulent occurs",\
 0.1, 1E-06,1E+100,0.0,0,513)
DeclareVariable("CoolingUnit.preDro.k", "Flow coefficient, k=m_flow/sqrt(dp), with unit=(kg.m)^(1/2)",\
 0.35355339059327373, 0.0,0.0,0.0,0,513)
DeclareVariable("CoolingUnit.preDro.computeFlowResistance", "Flag to enable/disable computation of flow resistance [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,2563)
DeclareVariable("CoolingUnit.preDro.coeff", "Precomputed coefficient to avoid division by parameter",\
 0, 0.0,0.0,0.0,0,2561)
DeclareParameter("CoolingUnit.sta_default.p", "Absolute pressure of medium [Pa|bar]",\
 356, 300000.0, 0.0,100000000.0,100000.0,0,2608)
DeclareParameter("CoolingUnit.sta_default.T", "Temperature of medium [K|degC]", 357,\
 293.15, 1.0,10000.0,300.0,0,2608)
DeclareVariable("CoolingUnit.rho_default", "Density, used to compute fluid volume [kg/m3|g/cm3]",\
 995.586, 0.0,1E+100,0.0,0,2561)
DeclareVariable("CoolingUnit.sta_start.p", "Absolute pressure of medium [Pa|bar]",\
 300000, 0.0,100000000.0,100000.0,0,2561)
DeclareVariable("CoolingUnit.sta_start.T", "Temperature of medium [K|degC]", \
293.15, 1.0,10000.0,300.0,0,2561)
DeclareVariable("CoolingUnit.h_outflow_start", "Start value for outflowing enthalpy [J/kg]",\
 0.0, 0.0,0.0,0.0,0,2561)
DeclareParameter("CoolingUnit.Q_flow_nominal", "Heat flow rate at u=1, positive for heating [W]",\
 358, -1000, 0.0,0.0,0.0,0,560)
DeclareVariable("CoolingUnit.u", "Control input [1]", 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("CoolingUnit.Q_flow", "Heat added to the fluid [W]", 0.0, \
0.0,0.0,0.0,0,512)
DeclareParameter("CoolingUnit.gain.k", "Gain value multiplied with input signal [1]",\
 359, 1, 0.0,0.0,0.0,0,560)
DeclareAlias2("CoolingUnit.gain.u", "Input signal connector", "CoolingUnit.u", 1,\
 5, 1314, 0)
DeclareAlias2("CoolingUnit.gain.y", "Output signal connector", "CoolingUnit.Q_flow", 1,\
 5, 1315, 0)
DeclareParameter("CoolingUnit.preHea.T_ref", "Reference temperature [K|degC]", 360,\
 293.15, 0.0,1E+100,300.0,0,2608)
DeclareVariable("CoolingUnit.preHea.alpha", "Temperature coefficient of heat flow rate [1/K]",\
 0, 0.0,0.0,0.0,0,2561)
DeclareAlias2("CoolingUnit.preHea.Q_flow", "[W]", "CoolingUnit.Q_flow", 1, 5, 1315,\
 1024)
DeclareAlias2("CoolingUnit.preHea.port.T", "Port temperature [K|degC]", \
"CoolingUnit.vol.T", 1, 5, 1282, 1028)
DeclareAlias2("CoolingUnit.preHea.port.Q_flow", "Heat flow rate (positive if flowing from outside into the component) [W]",\
 "CoolingUnit.Q_flow", -1, 5, 1315, 1156)
DeclareParameter("gain.k", "Gain value multiplied with input signal [1]", 361, 1,\
 0.0,0.0,0.0,0,560)
DeclareAlias2("gain.u", "Input signal connector", "building.heaPorCoo[1].Q_flow", 1,\
 5, 189, 0)
DeclareAlias2("gain.y", "Output signal connector", "CoolingUnit.u", 1, 5, 1314, 0)
DeclareVariable("gain1.k", "Gain value multiplied with input signal [1]", 1, \
0.0,0.0,0.0,0,513)
DeclareAlias2("gain1.u", "Input signal connector", "building.heaPorCoo[1].Q_flow", 1,\
 5, 189, 0)
DeclareVariable("gain1.y", "Output signal connector", 0.0, 0.0,0.0,0.5,0,512)
DeclareAlias2("prescribedHeatFlow.Q_flow", "", "building.heaPorCoo[1].Q_flow", 1,\
 5, 189, 0)
DeclareAlias2("prescribedHeatFlow.port.T", "Port temperature [K|degC]", \
"building.heaPorCoo[1].T", 1, 5, 188, 4)
DeclareAlias2("prescribedHeatFlow.port.Q_flow", "Heat flow rate (positive if flowing from outside into the component) [W]",\
 "building.heaPorCoo[1].Q_flow", -1, 5, 189, 132)
DeclareVariable("QCoo.nout", "Number of outputs [:#(type=Integer)]", 1, 1.0,\
1E+100,0.0,0,517)
DeclareAlias2("QCoo.y[1]", "Connector of Real output signals", "building.heaPorCoo[1].Q_flow", 1,\
 5, 189, 0)
DeclareVariable("QCoo.tableOnFile", "= true, if table is defined on file or in function usertab [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,515)
DeclareParameter("QCoo.table[1, 1]", "Table matrix (time = first column; e.g., table=[0,2])",\
 362, 0, 0.0,0.0,0.0,0,560)
DeclareParameter("QCoo.table[1, 2]", "Table matrix (time = first column; e.g., table=[0,2])",\
 363, -120, 0.0,0.0,0.0,0,560)
DeclareParameter("QCoo.table[2, 1]", "Table matrix (time = first column; e.g., table=[0,2])",\
 364, 6, 0.0,0.0,0.0,0,560)
DeclareParameter("QCoo.table[2, 2]", "Table matrix (time = first column; e.g., table=[0,2])",\
 365, -100, 0.0,0.0,0.0,0,560)
DeclareParameter("QCoo.table[3, 1]", "Table matrix (time = first column; e.g., table=[0,2])",\
 366, 9, 0.0,0.0,0.0,0,560)
DeclareParameter("QCoo.table[3, 2]", "Table matrix (time = first column; e.g., table=[0,2])",\
 367, -200, 0.0,0.0,0.0,0,560)
DeclareParameter("QCoo.table[4, 1]", "Table matrix (time = first column; e.g., table=[0,2])",\
 368, 12, 0.0,0.0,0.0,0,560)
DeclareParameter("QCoo.table[4, 2]", "Table matrix (time = first column; e.g., table=[0,2])",\
 369, -210, 0.0,0.0,0.0,0,560)
DeclareParameter("QCoo.table[5, 1]", "Table matrix (time = first column; e.g., table=[0,2])",\
 370, 18, 0.0,0.0,0.0,0,560)
DeclareParameter("QCoo.table[5, 2]", "Table matrix (time = first column; e.g., table=[0,2])",\
 371, -150, 0.0,0.0,0.0,0,560)
DeclareParameter("QCoo.table[6, 1]", "Table matrix (time = first column; e.g., table=[0,2])",\
 372, 24, 0.0,0.0,0.0,0,560)
DeclareParameter("QCoo.table[6, 2]", "Table matrix (time = first column; e.g., table=[0,2])",\
 373, -100, 0.0,0.0,0.0,0,560)
DeclareParameter("QCoo.table[7, 1]", "Table matrix (time = first column; e.g., table=[0,2])",\
 374, 30, 0.0,0.0,0.0,0,560)
DeclareParameter("QCoo.table[7, 2]", "Table matrix (time = first column; e.g., table=[0,2])",\
 375, -120, 0.0,0.0,0.0,0,560)
DeclareParameter("QCoo.table[8, 1]", "Table matrix (time = first column; e.g., table=[0,2])",\
 376, 36, 0.0,0.0,0.0,0,560)
DeclareParameter("QCoo.table[8, 2]", "Table matrix (time = first column; e.g., table=[0,2])",\
 377, -110, 0.0,0.0,0.0,0,560)
DeclareParameter("QCoo.table[9, 1]", "Table matrix (time = first column; e.g., table=[0,2])",\
 378, 42, 0.0,0.0,0.0,0,560)
DeclareParameter("QCoo.table[9, 2]", "Table matrix (time = first column; e.g., table=[0,2])",\
 379, -200, 0.0,0.0,0.0,0,560)
DeclareParameter("QCoo.table[10, 1]", "Table matrix (time = first column; e.g., table=[0,2])",\
 380, 48, 0.0,0.0,0.0,0,560)
DeclareParameter("QCoo.table[10, 2]", "Table matrix (time = first column; e.g., table=[0,2])",\
 381, -120, 0.0,0.0,0.0,0,560)
DeclareParameter("QCoo.table[11, 1]", "Table matrix (time = first column; e.g., table=[0,2])",\
 382, 54, 0.0,0.0,0.0,0,560)
DeclareParameter("QCoo.table[11, 2]", "Table matrix (time = first column; e.g., table=[0,2])",\
 383, -150, 0.0,0.0,0.0,0,560)
DeclareParameter("QCoo.verboseRead", "= true, if info message that file is loading is to be printed [:#(type=Boolean)]",\
 384, true, 0.0,0.0,0.0,0,562)
DeclareVariable("QCoo.columns[1]", "Columns of table to be interpolated [:#(type=Integer)]",\
 2, 0.0,0.0,0.0,0,517)
DeclareVariable("QCoo.smoothness", "Smoothness of table interpolation [:#(type=Modelica.Blocks.Types.Smoothness)]",\
 1, 1.0,5.0,0.0,0,517)
DeclareParameter("QCoo.extrapolation", "Extrapolation of data outside the definition range [:#(type=Modelica.Blocks.Types.Extrapolation)]",\
 385, 3, 1.0,4.0,0.0,0,564)
DeclareParameter("QCoo.offset[1]", "Offsets of output signals", 386, 0, 0.0,0.0,\
0.0,0,560)
DeclareParameter("QCoo.startTime", "Output = offset for time < startTime [s]", 387,\
 0, 0.0,0.0,0.0,0,560)
DeclareVariable("QCoo.timeScale", "Time scale of first table column [s]", 3600, \
1E-15,1E+100,0.0,0,513)
DeclareVariable("QCoo.t_min", "Minimum abscissa value defined in table [s]", 0.0,\
 0.0,0.0,0.0,0,513)
DeclareVariable("QCoo.t_max", "Maximum abscissa value defined in table [s]", 0.0,\
 0.0,0.0,0.0,0,513)
DeclareVariable("QCoo.t_minScaled", "Minimum (scaled) abscissa value defined in table",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("QCoo.t_maxScaled", "Maximum (scaled) abscissa value defined in table",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("QCoo.p_offset[1]", "Offsets of output signals", 0.0, 0.0,0.0,\
0.0,0,2561)
DeclareVariable("QCoo.tableID.id", "[:#(type=Integer)]", 0, 0.0,0.0,0.0,0,2565)
DeclareVariable("QCoo.nextTimeEvent", "Next time event instant [s]", 0, 0.0,0.0,\
0.0,0,2704)
DeclareVariable("QCoo.nextTimeEventScaled", "Next scaled time event instant", 0,\
 0.0,0.0,0.0,0,2704)
DeclareVariable("QCoo.tableOnFileRead", "= 1, if table was successfully read from file",\
 0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("QCoo.DBL_MAX", "", 1.7976931348623157E+308, 0.0,0.0,0.0,0,2561)
DeclareVariable("QCoo.timeScaled", "Scaled time", 0.0, 0.0,0.0,0.0,0,2560)
DeclareParameter("building.heaLoaO[1].TOutHea_nominal", "Outdoor temperature at heating nominal conditions [K|degC]",\
 388, 268.15, 0.0,1E+100,300.0,0,560)
DeclareVariable("building.heaLoaO[1].TIndHea_nominal", "Indoor temperature at heating nominal conditions [K|degC]",\
 293.15, 0.0,1E+100,300.0,0,513)
DeclareVariable("building.heaLoaO[1].Q_flowHea_nominal", "Heating (>0) heat flow rate at nominal conditions [W]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("building.heaLoaO[1].Q_flow_nominal", "Heating (>0) or cooling (<0) heat flow rate at nominal conditions [W]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("building.heaLoaO[1].steadyStateInitial", "true initializes T with dT(0)/dt=0, false initializes T with T(0)=TIndHea_nominal [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,515)
DeclareParameter("building.heaLoaO[1].tau", "Time constant of the indoor temperature [s]",\
 389, 7200, 0.0,0.0,0.0,0,560)
DeclareAlias2("building.heaLoaO[1].TSet", "Setpoint temperature for heating or cooling [K|degC]",\
 "building.from_degC1.y", 1, 5, 526, 0)
DeclareAlias2("building.heaLoaO[1].Q_flowReq", "Required heat flow rate to meet setpoint temperature [W]",\
 "building.Q_flowHeaReq[2]", 1, 5, 194, 0)
DeclareVariable("building.heaLoaO[1].Q_flowAct", "Actual heating or cooling heat flow rate [W]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareState("building.heaLoaO[1].TInd", "Indoor temperature [K|degC]", 12, \
288.15, 0.0,1E+100,300.0,0,544)
DeclareDerivative("building.heaLoaO[1].der(TInd)", "der(Indoor temperature) [K/s]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("building.heaLoaO[1].G", "Lumped thermal conductance representing all deltaT dependent heat transfer mechanisms [W/K]",\
 0.0, 0.0,0.0,0.0,0,2561)
DeclareAlias2("building.THeaLoaO[1].port.T", "Port temperature [K|degC]", \
"building.heaLoaO[1].TInd", 1, 1, 12, 4)
DeclareVariable("building.THeaLoaO[1].port.Q_flow", "Heat flow rate (positive if flowing from outside into the component) [W]",\
 0.0, 0.0,0.0,0.0,0,777)
DeclareAlias2("building.THeaLoaO[1].T", "", "building.heaLoaO[1].TInd", 1, 1, 12,\
 0)
DeclareVariable("building.heaFloHeaLoaO[1].Q_flow", "Heat flow from port_a to port_b as output signal [W]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareAlias2("building.heaFloHeaLoaO[1].port_a.T", "Port temperature [K|degC]",\
 "building.heaLoaO[1].TInd", 1, 1, 12, 4)
DeclareVariable("building.heaFloHeaLoaO[1].port_a.Q_flow", "Heat flow rate (positive if flowing from outside into the component) [W]",\
 0.0, 0.0,0.0,0.0,0,777)
DeclareAlias2("building.heaFloHeaLoaO[1].port_b.T", "Port temperature [K|degC]",\
 "building.heaLoaO[1].TInd", 1, 1, 12, 4)
DeclareVariable("building.heaFloHeaLoaO[1].port_b.Q_flow", "Heat flow rate (positive if flowing from outside into the component) [W]",\
 0.0, 0.0,0.0,0.0,0,777)
DeclareAlias2("building.heaFloCooLoaH[1].Q_flow", "Heat flow from port_a to port_b as output signal [W]",\
 "building.heaPorCoo[1].Q_flow", 1, 5, 189, 0)
DeclareAlias2("building.heaFloCooLoaH[1].port_a.T", "Port temperature [K|degC]",\
 "building.heaPorCoo[1].T", 1, 5, 188, 4)
DeclareAlias2("building.heaFloCooLoaH[1].port_a.Q_flow", "Heat flow rate (positive if flowing from outside into the component) [W]",\
 "building.heaPorCoo[1].Q_flow", 1, 5, 189, 132)
DeclareAlias2("building.heaFloCooLoaH[1].port_b.T", "Port temperature [K|degC]",\
 "building.heaPorCoo[1].T", 1, 5, 188, 4)
DeclareAlias2("building.heaFloCooLoaH[1].port_b.Q_flow", "Heat flow rate (positive if flowing from outside into the component) [W]",\
 "building.heaPorCoo[1].Q_flow", -1, 5, 189, 132)
DeclareVariable("building.heaFloHeaLoaH[1].Q_flow", "Heat flow from port_a to port_b as output signal [W]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareAlias2("building.heaFloHeaLoaH[1].port_a.T", "Port temperature [K|degC]",\
 "building.heaPorCoo[1].T", 1, 5, 188, 4)
DeclareVariable("building.heaFloHeaLoaH[1].port_a.Q_flow", "Heat flow rate (positive if flowing from outside into the component) [W]",\
 0.0, 0.0,0.0,0.0,0,777)
DeclareAlias2("building.heaFloHeaLoaH[1].port_b.T", "Port temperature [K|degC]",\
 "building.heaPorCoo[1].T", 1, 5, 188, 4)
DeclareVariable("building.heaFloHeaLoaH[1].port_b.Q_flow", "Heat flow rate (positive if flowing from outside into the component) [W]",\
 0.0, 0.0,0.0,0.0,0,777)
DeclareAlias2("building.thermalZoneOneElement.TAir", "Indoor air temperature [K|degC]",\
 "building.heaPorCoo[1].T", 1, 5, 188, 0)
DeclareAlias2("building.thermalZoneOneElement.TRad", "Mean indoor radiation temperature [K|degC]",\
 "building.perRad.port.T", 1, 5, 503, 0)
DeclareAlias2("building.thermalZoneOneElement.extWall.T", "Port temperature [K|degC]",\
 "building.theConWall.solid.T", 1, 5, 501, 4)
DeclareAlias2("building.thermalZoneOneElement.extWall.Q_flow", "Heat flow rate (positive if flowing from outside into the component) [W]",\
 "building.preTem.port.Q_flow", -1, 5, 496, 132)
DeclareAlias2("building.thermalZoneOneElement.window.T", "Port temperature [K|degC]",\
 "building.theConWin.solid.T", 1, 5, 499, 4)
DeclareAlias2("building.thermalZoneOneElement.window.Q_flow", "Heat flow rate (positive if flowing from outside into the component) [W]",\
 "building.preTem1.port.Q_flow", -1, 5, 497, 132)
DeclareAlias2("building.thermalZoneOneElement.intGainsConv.T", "Port temperature [K|degC]",\
 "building.heaPorCoo[1].T", 1, 5, 188, 4)
DeclareVariable("building.thermalZoneOneElement.intGainsConv.Q_flow", \
"Heat flow rate (positive if flowing from outside into the component) [W]", 0.0,\
 0.0,0.0,0.0,0,776)
DeclareAlias2("building.thermalZoneOneElement.intGainsRad.T", "Port temperature [K|degC]",\
 "building.perRad.port.T", 1, 5, 503, 4)
DeclareAlias2("building.thermalZoneOneElement.intGainsRad.Q_flow", \
"Heat flow rate (positive if flowing from outside into the component) [W]", \
"building.perRad.port.Q_flow", -1, 5, 504, 132)
DeclareVariable("building.thermalZoneOneElement.volAir.dynBal.energyDynamics", \
"Type of energy balance: dynamic (3 initialization options) or steady state [:#(type=Modelica.Fluid.Types.Dynamics)]",\
 2, 1.0,4.0,0.0,0,2565)
DeclareVariable("building.thermalZoneOneElement.volAir.dynBal.massDynamics", \
"Type of mass balance: dynamic (3 initialization options) or steady state [:#(type=Modelica.Fluid.Types.Dynamics)]",\
 2, 1.0,4.0,0.0,0,2565)
DeclareVariable("building.thermalZoneOneElement.volAir.dynBal.substanceDynamics",\
 "Type of independent mass fraction balance: dynamic (3 initialization options) or steady state [:#(type=Modelica.Fluid.Types.Dynamics)]",\
 2, 1.0,4.0,0.0,0,2565)
DeclareVariable("building.thermalZoneOneElement.volAir.dynBal.traceDynamics", \
"Type of trace substance balance: dynamic (3 initialization options) or steady state [:#(type=Modelica.Fluid.Types.Dynamics)]",\
 2, 1.0,4.0,0.0,0,2565)
DeclareVariable("building.thermalZoneOneElement.volAir.dynBal.p_start", \
"Start value of pressure [Pa|bar]", 100000.0, 0.0,100000000.0,100000.0,0,2561)
DeclareVariable("building.thermalZoneOneElement.volAir.dynBal.T_start", \
"Start value of temperature [K|degC]", 288.15, 273.15,373.15,300.0,0,2561)
DeclareVariable("building.thermalZoneOneElement.volAir.dynBal.X_start[1]", \
"Start value of mass fractions m_i/m [kg/kg]", 0.0, 0.0,1.0,0.1,0,2561)
DeclareVariable("building.thermalZoneOneElement.volAir.dynBal.mSenFac", \
"Factor for scaling the sensible thermal mass of the volume", 1.0, 1.0,1E+100,\
0.0,0,2561)
DeclareVariable("building.thermalZoneOneElement.volAir.dynBal.initialize_p", \
"= true to set up initial equations for pressure [:#(type=Boolean)]", true, \
0.0,0.0,0.0,0,1539)
DeclareVariable("building.thermalZoneOneElement.volAir.dynBal.simplify_mWat_flow",\
 "Set to true to cause port_a.m_flow + port_b.m_flow = 0 even if mWat_flow is non-zero. Used only if Medium.nX > 1 [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,2563)
DeclareVariable("building.thermalZoneOneElement.volAir.dynBal.nPorts", \
"Number of ports [:#(type=Integer)]", 0, 0.0,0.0,0.0,0,2565)
DeclareVariable("building.thermalZoneOneElement.volAir.dynBal.use_mWat_flow", \
"Set to true to enable input connector for moisture mass flow rate [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,2563)
DeclareVariable("building.thermalZoneOneElement.volAir.dynBal.use_C_flow", \
"Set to true to enable input connector for trace substance [:#(type=Boolean)]", \
false, 0.0,0.0,0.0,0,2563)
DeclareAlias2("building.thermalZoneOneElement.volAir.dynBal.Q_flow", \
"Sensible plus latent heat flow rate transferred into the medium [W]", \
"building.thermalZoneOneElement.volAir.dynBal.der(U)", 1, 6, 13, 1024)
DeclareAlias2("building.thermalZoneOneElement.volAir.dynBal.hOut", \
"Leaving specific enthalpy of the component [J/kg]", "building.thermalZoneOneElement.volAir.hOut_internal", 1,\
 5, 446, 1024)
DeclareAlias2("building.thermalZoneOneElement.volAir.dynBal.UOut", \
"Internal energy of the component [J]", "building.thermalZoneOneElement.volAir.dynBal.U", 1,\
 1, 13, 1024)
DeclareAlias2("building.thermalZoneOneElement.volAir.dynBal.mOut", \
"Mass of the component [kg]", "building.thermalZoneOneElement.volAir.dynBal.m", 1,\
 1, 14, 1024)
DeclareVariable("building.thermalZoneOneElement.volAir.dynBal.medium.p", \
"Absolute pressure of medium [Pa|bar]", 0.0, 0.0,100000000.0,100000.0,0,2560)
DeclareAlias2("building.thermalZoneOneElement.volAir.dynBal.medium.h", \
"Specific enthalpy of medium [J/kg]", "building.thermalZoneOneElement.volAir.hOut_internal", 1,\
 5, 446, 1024)
DeclareVariable("building.thermalZoneOneElement.volAir.dynBal.medium.d", \
"Density of medium [kg/m3|g/cm3]", 0.0, 0.0,100000.0,1.0,0,2560)
DeclareVariable("building.thermalZoneOneElement.volAir.dynBal.medium.T", \
"Temperature of medium [K|degC]", 300.0, 273.15,373.15,300.0,0,2560)
DeclareVariable("building.thermalZoneOneElement.volAir.dynBal.medium.X[1]", \
"Mass fractions (= (component mass)/total mass  m_i/m) [kg/kg]", 1.0, 0.0,1.0,\
0.1,0,2561)
DeclareVariable("building.thermalZoneOneElement.volAir.dynBal.medium.u", \
"Specific internal energy of medium [J/kg]", 0.0, -100000000.0,100000000.0,\
1000000.0,0,2560)
DeclareVariable("building.thermalZoneOneElement.volAir.dynBal.medium.R", \
"Gas constant (of mixture if applicable) [J/(kg.K)]", 287.0508037566665, 0.0,\
10000000.0,1000.0,0,2561)
DeclareVariable("building.thermalZoneOneElement.volAir.dynBal.medium.MM", \
"Molar mass (of mixture or single fluid) [kg/mol]", 0.0289651159, 0.001,0.25,\
0.032,0,2561)
DeclareAlias2("building.thermalZoneOneElement.volAir.dynBal.medium.state.p", \
"Absolute pressure of medium [Pa|bar]", "building.thermalZoneOneElement.volAir.dynBal.medium.p", 1,\
 5, 1362, 1024)
DeclareAlias2("building.thermalZoneOneElement.volAir.dynBal.medium.state.T", \
"Temperature of medium [K|degC]", "building.thermalZoneOneElement.volAir.dynBal.medium.T", 1,\
 5, 1364, 1024)
DeclareVariable("building.thermalZoneOneElement.volAir.dynBal.medium.preferredMediumStates",\
 "= true if StateSelect.prefer shall be used for the independent property variables of the medium [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,2563)
DeclareVariable("building.thermalZoneOneElement.volAir.dynBal.medium.standardOrderComponents",\
 "If true, and reducedX = true, the last element of X will be computed from the other ones [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,2563)
DeclareVariable("building.thermalZoneOneElement.volAir.dynBal.medium.T_degC", \
"Temperature of medium in [degC] [degC;]", 0.0, 0.0,0.0,0.0,0,2560)
DeclareVariable("building.thermalZoneOneElement.volAir.dynBal.medium.p_bar", \
"Absolute pressure of medium in [bar] [bar]", 0.0, 0.0,0.0,0.0,0,2560)
DeclareState("building.thermalZoneOneElement.volAir.dynBal.U", "Internal energy of fluid [J]",\
 13, 0.0, 0.0,0.0,100000.0,0,2592)
DeclareDerivative("building.thermalZoneOneElement.volAir.dynBal.der(U)", \
"der(Internal energy of fluid) [W]", 0.0, 0.0,0.0,0.0,0,2560)
DeclareState("building.thermalZoneOneElement.volAir.dynBal.m", "Mass of fluid [kg]",\
 14, 0.0, 0.0,1E+100,0.0,0,2592)
DeclareDerivative("building.thermalZoneOneElement.volAir.dynBal.der(m)", \
"der(Mass of fluid) [kg/s]", 0.0, 0.0,0.0,0.0,0,2560)
DeclareVariable("building.thermalZoneOneElement.volAir.dynBal.mb_flow", \
"Mass flows across boundaries [kg/s]", 0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("building.thermalZoneOneElement.volAir.dynBal.Hb_flow", \
"Enthalpy flow across boundaries or energy source/sink [W]", 0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("building.thermalZoneOneElement.volAir.dynBal.fluidVolume", \
"Volume [m3]", 52.5, 0.0,0.0,0.0,0,2561)
DeclareVariable("building.thermalZoneOneElement.volAir.dynBal.CSen", \
"Aditional heat capacity for implementing mFactor [J/K]", 0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("building.thermalZoneOneElement.volAir.dynBal.cp_default", \
"Heat capacity, to compute additional dry mass [J/(kg.K)]", 1005.45, 0.0,0.0,0.0,\
0,2561)
DeclareVariable("building.thermalZoneOneElement.volAir.dynBal.rho_start", \
"Density, used to compute fluid mass [kg/m3|g/cm3]", 0.0, 0.0,1E+100,0.0,0,2561)
DeclareVariable("building.thermalZoneOneElement.volAir.dynBal.computeCSen", \
"[:#(type=Boolean)]", false, 0.0,0.0,0.0,0,2563)
DeclareVariable("building.thermalZoneOneElement.volAir.dynBal.state_default.p", \
"Absolute pressure of medium [Pa|bar]", 101325.0, 0.0,100000000.0,100000.0,0,2561)
DeclareVariable("building.thermalZoneOneElement.volAir.dynBal.state_default.T", \
"Temperature of medium [K|degC]", 293.15, 273.15,373.15,300.0,0,2561)
DeclareVariable("building.thermalZoneOneElement.volAir.dynBal.rho_default", \
"Density, used to compute fluid mass [kg/m3|g/cm3]", 1.204114944782858, 0.0,\
1E+100,0.0,0,2561)
DeclareVariable("building.thermalZoneOneElement.volAir.dynBal.hStart", \
"Start value for specific enthalpy [J/kg]", 0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("building.thermalZoneOneElement.volAir.dynBal._simplify_mWat_flow",\
 "If true, then port_a.m_flow + port_b.m_flow = 0 even if mWat_flow is non-zero, and equations are simplified [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,2563)
DeclareVariable("building.thermalZoneOneElement.volAir.dynBal.mWat_flow_internal",\
 "Needed to connect to conditional connector [kg/s]", 0, 0.0,0.0,0.0,0,2561)
DeclareAlias2("building.thermalZoneOneElement.resWin.Q_flow", "Heat flow rate from port_a -> port_b [W]",\
 "building.preTem1.port.Q_flow", -1, 5, 497, 0)
DeclareVariable("building.thermalZoneOneElement.resWin.dT", "port_a.T - port_b.T [K,]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("building.thermalZoneOneElement.resWin.port_a.T", "Port temperature [K|degC]",\
 "building.theConWin.solid.T", 1, 5, 499, 4)
DeclareAlias2("building.thermalZoneOneElement.resWin.port_a.Q_flow", \
"Heat flow rate (positive if flowing from outside into the component) [W]", \
"building.preTem1.port.Q_flow", -1, 5, 497, 132)
DeclareAlias2("building.thermalZoneOneElement.resWin.port_b.T", "Port temperature [K|degC]",\
 "building.thermalZoneOneElement.convWin.solid.T", 1, 5, 467, 4)
DeclareAlias2("building.thermalZoneOneElement.resWin.port_b.Q_flow", \
"Heat flow rate (positive if flowing from outside into the component) [W]", \
"building.preTem1.port.Q_flow", 1, 5, 497, 132)
DeclareVariable("building.thermalZoneOneElement.resWin.R", "Constant thermal resistance of material [K/W]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareParameter("building.thermalZoneOneElement.convHeatSol.T_ref", \
"Reference temperature [K|degC]", 390, 293.15, 0.0,1E+100,300.0,0,560)
DeclareVariable("building.thermalZoneOneElement.convHeatSol.alpha", \
"Temperature coefficient of heat flow rate [1/K]", 0, 0.0,0.0,0.0,0,513)
DeclareAlias2("building.thermalZoneOneElement.convHeatSol.Q_flow", "[W]", \
"building.thermalZoneOneElement.sumSolRad.y", 1, 5, 481, 0)
DeclareAlias2("building.thermalZoneOneElement.convHeatSol.port.T", \
"Port temperature [K|degC]", "building.heaPorCoo[1].T", 1, 5, 188, 4)
DeclareAlias2("building.thermalZoneOneElement.convHeatSol.port.Q_flow", \
"Heat flow rate (positive if flowing from outside into the component) [W]", \
"building.thermalZoneOneElement.sumSolRad.y", -1, 5, 481, 132)
DeclareParameter("building.thermalZoneOneElement.radHeatSol[1].T_ref", \
"Reference temperature [K|degC]", 391, 293.15, 0.0,1E+100,300.0,0,560)
DeclareVariable("building.thermalZoneOneElement.radHeatSol[1].alpha", \
"Temperature coefficient of heat flow rate [1/K]", 0, 0.0,0.0,0.0,0,513)
DeclareAlias2("building.thermalZoneOneElement.radHeatSol[1].Q_flow", "[W]", \
"building.thermalZoneOneElement.thermSplitterSolRad.portIn[1].Q_flow", 1, 5, 1404,\
 0)
DeclareAlias2("building.thermalZoneOneElement.radHeatSol[1].port.T", \
"Port temperature [K|degC]", "building.thermalZoneOneElement.thermSplitterSolRad.portIn[1].T", 1,\
 5, 1403, 4)
DeclareAlias2("building.thermalZoneOneElement.radHeatSol[1].port.Q_flow", \
"Heat flow rate (positive if flowing from outside into the component) [W]", \
"building.thermalZoneOneElement.thermSplitterSolRad.portIn[1].Q_flow", -1, 5, 1404,\
 132)
DeclareParameter("building.thermalZoneOneElement.radHeatSol[2].T_ref", \
"Reference temperature [K|degC]", 392, 293.15, 0.0,1E+100,300.0,0,560)
DeclareVariable("building.thermalZoneOneElement.radHeatSol[2].alpha", \
"Temperature coefficient of heat flow rate [1/K]", 0, 0.0,0.0,0.0,0,513)
DeclareAlias2("building.thermalZoneOneElement.radHeatSol[2].Q_flow", "[W]", \
"building.thermalZoneOneElement.thermSplitterSolRad.portIn[2].Q_flow", 1, 5, 1406,\
 0)
DeclareAlias2("building.thermalZoneOneElement.radHeatSol[2].port.T", \
"Port temperature [K|degC]", "building.thermalZoneOneElement.thermSplitterSolRad.portIn[2].T", 1,\
 5, 1405, 4)
DeclareAlias2("building.thermalZoneOneElement.radHeatSol[2].port.Q_flow", \
"Heat flow rate (positive if flowing from outside into the component) [W]", \
"building.thermalZoneOneElement.thermSplitterSolRad.portIn[2].Q_flow", -1, 5, 1406,\
 132)
DeclareVariable("building.thermalZoneOneElement.thermSplitterIntGains.nOut", \
"Number of splitter outputs [:#(type=Integer)]", 2, 0.0,0.0,0.0,0,517)
DeclareVariable("building.thermalZoneOneElement.thermSplitterIntGains.nIn", \
"Number of splitter inputs [:#(type=Integer)]", 1, 0.0,0.0,0.0,0,517)
DeclareVariable("building.thermalZoneOneElement.thermSplitterIntGains.splitFactor[1, 1]",\
 "Matrix of split factor for outputs (between 0 and 1 for each row)", \
0.45098039215686275, 0.0,0.0,0.0,0,513)
DeclareVariable("building.thermalZoneOneElement.thermSplitterIntGains.splitFactor[2, 1]",\
 "Matrix of split factor for outputs (between 0 and 1 for each row)", \
0.5490196078431373, 0.0,0.0,0.0,0,513)
DeclareAlias2("building.thermalZoneOneElement.thermSplitterIntGains.portIn[1].T",\
 "Port temperature [K|degC]", "building.perRad.port.T", 1, 5, 503, 4)
DeclareAlias2("building.thermalZoneOneElement.thermSplitterIntGains.portIn[1].Q_flow",\
 "Heat flow rate (positive if flowing from outside into the component) [W]", \
"building.perRad.port.Q_flow", -1, 5, 504, 132)
DeclareAlias2("building.thermalZoneOneElement.thermSplitterIntGains.portOut[1].T",\
 "Port temperature [K|degC]", "building.thermalZoneOneElement.convExtWall.solid.T", 1,\
 5, 463, 4)
DeclareVariable("building.thermalZoneOneElement.thermSplitterIntGains.portOut[1].Q_flow",\
 "Heat flow rate (positive if flowing from outside into the component) [W]", 0.0,\
 0.0,0.0,0.0,0,776)
DeclareAlias2("building.thermalZoneOneElement.thermSplitterIntGains.portOut[2].T",\
 "Port temperature [K|degC]", "building.thermalZoneOneElement.convWin.solid.T", 1,\
 5, 467, 4)
DeclareVariable("building.thermalZoneOneElement.thermSplitterIntGains.portOut[2].Q_flow",\
 "Heat flow rate (positive if flowing from outside into the component) [W]", 0.0,\
 0.0,0.0,0.0,0,776)
DeclareVariable("building.thermalZoneOneElement.thermSplitterSolRad.nOut", \
"Number of splitter outputs [:#(type=Integer)]", 2, 0.0,0.0,0.0,0,517)
DeclareVariable("building.thermalZoneOneElement.thermSplitterSolRad.nIn", \
"Number of splitter inputs [:#(type=Integer)]", 2, 0.0,0.0,0.0,0,517)
DeclareVariable("building.thermalZoneOneElement.thermSplitterSolRad.splitFactor[1, 1]",\
 "Matrix of split factor for outputs (between 0 and 1 for each row)", 0.0, \
0.0,0.0,0.0,0,513)
DeclareVariable("building.thermalZoneOneElement.thermSplitterSolRad.splitFactor[1, 2]",\
 "Matrix of split factor for outputs (between 0 and 1 for each row)", 0.0, \
0.0,0.0,0.0,0,513)
DeclareVariable("building.thermalZoneOneElement.thermSplitterSolRad.splitFactor[2, 1]",\
 "Matrix of split factor for outputs (between 0 and 1 for each row)", 0.0, \
0.0,0.0,0.0,0,513)
DeclareVariable("building.thermalZoneOneElement.thermSplitterSolRad.splitFactor[2, 2]",\
 "Matrix of split factor for outputs (between 0 and 1 for each row)", 0.0, \
0.0,0.0,0.0,0,513)
DeclareVariable("building.thermalZoneOneElement.thermSplitterSolRad.portIn[1].T",\
 "Port temperature [K|degC]", 288.15, 0.0,1E+100,300.0,0,520)
DeclareVariable("building.thermalZoneOneElement.thermSplitterSolRad.portIn[1].Q_flow",\
 "Heat flow rate (positive if flowing from outside into the component) [W]", 0.0,\
 0.0,0.0,0.0,0,776)
DeclareVariable("building.thermalZoneOneElement.thermSplitterSolRad.portIn[2].T",\
 "Port temperature [K|degC]", 288.15, 0.0,1E+100,300.0,0,520)
DeclareVariable("building.thermalZoneOneElement.thermSplitterSolRad.portIn[2].Q_flow",\
 "Heat flow rate (positive if flowing from outside into the component) [W]", 0.0,\
 0.0,0.0,0.0,0,776)
DeclareAlias2("building.thermalZoneOneElement.thermSplitterSolRad.portOut[1].T",\
 "Port temperature [K|degC]", "building.thermalZoneOneElement.convExtWall.solid.T", 1,\
 5, 463, 4)
DeclareVariable("building.thermalZoneOneElement.thermSplitterSolRad.portOut[1].Q_flow",\
 "Heat flow rate (positive if flowing from outside into the component) [W]", 0.0,\
 0.0,0.0,0.0,0,776)
DeclareAlias2("building.thermalZoneOneElement.thermSplitterSolRad.portOut[2].T",\
 "Port temperature [K|degC]", "building.thermalZoneOneElement.convWin.solid.T", 1,\
 5, 467, 4)
DeclareVariable("building.thermalZoneOneElement.thermSplitterSolRad.portOut[2].Q_flow",\
 "Heat flow rate (positive if flowing from outside into the component) [W]", 0.0,\
 0.0,0.0,0.0,0,776)
DeclareVariable("building.thermalZoneOneElement.extWallRC.n", "Number of RC-elements [:#(type=Integer)]",\
 1, 1.0,1E+100,0.0,0,517)
DeclareVariable("building.thermalZoneOneElement.extWallRC.RExt[1]", \
"Vector of resistors, from port_a to port_b [K/W]", 1E-60, 1E-60,1E+100,0.0,0,513)
DeclareVariable("building.thermalZoneOneElement.extWallRC.RExtRem", \
"Resistance of remaining resistor RExtRem between capacitor n and port_b [K/W]",\
 1E-60, 1E-60,1E+100,0.0,0,513)
DeclareVariable("building.thermalZoneOneElement.extWallRC.CExt[1]", \
"Vector of heat capacities, from port_a to port_b [J/K]", 1E-60, 1E-60,1E+100,\
0.0,0,513)
DeclareVariable("building.thermalZoneOneElement.extWallRC.T_start", \
"Initial temperature of capacities [K|degC]", 288.15, 0.0,1E+100,300.0,0,513)
DeclareAlias2("building.thermalZoneOneElement.extWallRC.port_a.T", \
"Port temperature [K|degC]", "building.thermalZoneOneElement.convExtWall.solid.T", 1,\
 5, 463, 4)
DeclareVariable("building.thermalZoneOneElement.extWallRC.port_a.Q_flow", \
"Heat flow rate (positive if flowing from outside into the component) [W]", 0.0,\
 0.0,0.0,0.0,0,776)
DeclareAlias2("building.thermalZoneOneElement.extWallRC.port_b.T", \
"Port temperature [K|degC]", "building.theConWall.solid.T", 1, 5, 501, 4)
DeclareAlias2("building.thermalZoneOneElement.extWallRC.port_b.Q_flow", \
"Heat flow rate (positive if flowing from outside into the component) [W]", \
"building.preTem.port.Q_flow", -1, 5, 496, 132)
DeclareVariable("building.thermalZoneOneElement.extWallRC.thermCapExt[1].C", \
"Heat capacity of element (= cp*m) [J/K]", 0.0, 0.0,0.0,0.0,0,513)
DeclareState("building.thermalZoneOneElement.extWallRC.thermCapExt[1].T", \
"Temperature of element [K|degC]", 15, 0.0, 0.0,1E+100,300.0,0,544)
DeclareDerivative("building.thermalZoneOneElement.extWallRC.thermCapExt[1].der(T)",\
 "der(Temperature of element) [K/s]", 0, 0.0,0.0,0.0,0,512)
DeclareVariable("building.thermalZoneOneElement.extWallRC.thermCapExt[1].der_T",\
 "Time derivative of temperature (= der(T)) [K/s]", 0, 0.0,0.0,0.0,0,528)
DeclareAlias2("building.thermalZoneOneElement.extWallRC.thermCapExt[1].port.T", \
"Port temperature [K|degC]", "building.thermalZoneOneElement.extWallRC.thermCapExt[1].T", 1,\
 1, 15, 4)
DeclareVariable("building.thermalZoneOneElement.extWallRC.thermCapExt[1].port.Q_flow",\
 "Heat flow rate (positive if flowing from outside into the component) [W]", 0.0,\
 0.0,0.0,0.0,0,776)
DeclareAlias2("building.thermalZoneOneElement.extWallRC.thermResExt[1].Q_flow", \
"Heat flow rate from port_a -> port_b [W]", "building.thermalZoneOneElement.extWallRC.port_a.Q_flow", 1,\
 5, 1414, 1024)
DeclareVariable("building.thermalZoneOneElement.extWallRC.thermResExt[1].dT", \
"port_a.T - port_b.T [K,]", 0.0, 0.0,0.0,0.0,0,2560)
DeclareAlias2("building.thermalZoneOneElement.extWallRC.thermResExt[1].port_a.T",\
 "Port temperature [K|degC]", "building.thermalZoneOneElement.convExtWall.solid.T", 1,\
 5, 463, 1028)
DeclareAlias2("building.thermalZoneOneElement.extWallRC.thermResExt[1].port_a.Q_flow",\
 "Heat flow rate (positive if flowing from outside into the component) [W]", \
"building.thermalZoneOneElement.extWallRC.port_a.Q_flow", 1, 5, 1414, 1156)
DeclareAlias2("building.thermalZoneOneElement.extWallRC.thermResExt[1].port_b.T",\
 "Port temperature [K|degC]", "building.thermalZoneOneElement.extWallRC.thermCapExt[1].T", 1,\
 1, 15, 1028)
DeclareAlias2("building.thermalZoneOneElement.extWallRC.thermResExt[1].port_b.Q_flow",\
 "Heat flow rate (positive if flowing from outside into the component) [W]", \
"building.thermalZoneOneElement.extWallRC.port_a.Q_flow", -1, 5, 1414, 1156)
DeclareVariable("building.thermalZoneOneElement.extWallRC.thermResExt[1].R", \
"Constant thermal resistance of material [K/W]", 0.0, 0.0,0.0,0.0,0,2561)
DeclareAlias2("building.thermalZoneOneElement.extWallRC.thermResExtRem.Q_flow", \
"Heat flow rate from port_a -> port_b [W]", "building.preTem.port.Q_flow", 1, 5,\
 496, 1024)
DeclareVariable("building.thermalZoneOneElement.extWallRC.thermResExtRem.dT", \
"port_a.T - port_b.T [K,]", 0.0, 0.0,0.0,0.0,0,2560)
DeclareAlias2("building.thermalZoneOneElement.extWallRC.thermResExtRem.port_a.T",\
 "Port temperature [K|degC]", "building.thermalZoneOneElement.extWallRC.thermCapExt[1].T", 1,\
 1, 15, 1028)
DeclareAlias2("building.thermalZoneOneElement.extWallRC.thermResExtRem.port_a.Q_flow",\
 "Heat flow rate (positive if flowing from outside into the component) [W]", \
"building.preTem.port.Q_flow", 1, 5, 496, 1156)
DeclareAlias2("building.thermalZoneOneElement.extWallRC.thermResExtRem.port_b.T",\
 "Port temperature [K|degC]", "building.theConWall.solid.T", 1, 5, 501, 1028)
DeclareAlias2("building.thermalZoneOneElement.extWallRC.thermResExtRem.port_b.Q_flow",\
 "Heat flow rate (positive if flowing from outside into the component) [W]", \
"building.preTem.port.Q_flow", -1, 5, 496, 1156)
DeclareVariable("building.thermalZoneOneElement.extWallRC.thermResExtRem.R", \
"Constant thermal resistance of material [K/W]", 0.0, 0.0,0.0,0.0,0,2561)
DeclareAlias2("building.conPIDMinT.I.u", "Connector of Real input signal", \
"building.conPIDMinT.addI.y", 1, 5, 561, 0)
DeclareState("building.conPIDMinT.I.y", "Connector of Real output signal", 16, \
0.0, 0.0,0.0,0.0,0,544)
DeclareDerivative("building.conPIDMinT.I.der(y)", "der(Connector of Real output signal)",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("building.conPIDMinT.I.k", "Integrator gain [1]", 0.0, 0.0,0.0,\
0.0,0,513)
DeclareVariable("building.conPIDMinT.I.initType", "Type of initialization (1: no init, 2: initial state, 3: initial output) [:#(type=Buildings.Controls.OBC.CDL.Types.Init)]",\
 2, 1.0,3.0,0.0,0,517)
DeclareVariable("building.conPIDMinT.I.y_start", "Initial or guess value of output (= state)",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("building.conPIDMinT.I.reset", "Type of integrator reset [:#(type=Buildings.Controls.OBC.CDL.Types.Reset)]",\
 1, 1.0,3.0,0.0,0,517)
DeclareVariable("building.conPIDMinT.I.y_reset", "Value to which integrator is reset, used if reset = Types.Reset.Parameter",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareAlias2("building.conPIDMinT.I.y_reset_internal", "Internal connector for integrator reset",\
 "building.conPIDMinT.I.y_reset", 1, 5, 1426, 1024)
DeclareVariable("building.conPIDMinT.I.trigger_internal", "Needed to use conditional connector trigger [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,2563)
DeclareAlias2("building.conPIDMax.I.u", "Connector of Real input signal", \
"building.conPIDMax.addI.y", 1, 5, 597, 0)
DeclareState("building.conPIDMax.I.y", "Connector of Real output signal", 17, \
0.0, 0.0,0.0,0.0,0,544)
DeclareDerivative("building.conPIDMax.I.der(y)", "der(Connector of Real output signal)",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("building.conPIDMax.I.k", "Integrator gain [1]", 0.0, 0.0,0.0,\
0.0,0,513)
DeclareVariable("building.conPIDMax.I.initType", "Type of initialization (1: no init, 2: initial state, 3: initial output) [:#(type=Buildings.Controls.OBC.CDL.Types.Init)]",\
 2, 1.0,3.0,0.0,0,517)
DeclareVariable("building.conPIDMax.I.y_start", "Initial or guess value of output (= state)",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("building.conPIDMax.I.reset", "Type of integrator reset [:#(type=Buildings.Controls.OBC.CDL.Types.Reset)]",\
 1, 1.0,3.0,0.0,0,517)
DeclareVariable("building.conPIDMax.I.y_reset", "Value to which integrator is reset, used if reset = Types.Reset.Parameter",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareAlias2("building.conPIDMax.I.y_reset_internal", "Internal connector for integrator reset",\
 "building.conPIDMax.I.y_reset", 1, 5, 1432, 1024)
DeclareVariable("building.conPIDMax.I.trigger_internal", "Needed to use conditional connector trigger [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,2563)
DeclareAlias2("coo.con.addD.u1", "Connector of Real input signal 1", \
"TSetCHWS.k", 1, 7, 297, 0)
DeclareAlias2("coo.con.addD.u2", "Connector of Real input signal 2", \
"coo.TBuiRet.T", 1, 1, 3, 0)
DeclareVariable("coo.con.addD.y", "Connector of Real output signal", 0.0, \
0.0,0.0,0.0,0,512)
DeclareVariable("coo.con.addD.k1", "Gain of upper input", 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("coo.con.addD.k2", "Gain of lower input", 0.0, 0.0,0.0,0.0,0,513)
DeclareAlias2("coo.con.I.u", "Connector of Real input signal", "coo.con.addI.y", 1,\
 5, 867, 0)
DeclareState("coo.con.I.y", "Connector of Real output signal", 18, 0.0, 0.0,0.0,\
0.0,0,544)
DeclareDerivative("coo.con.I.der(y)", "der(Connector of Real output signal)", \
0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("coo.con.I.k", "Integrator gain [1]", 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("coo.con.I.initType", "Type of initialization (1: no init, 2: steady state, 3,4: initial output) [:#(type=Modelica.Blocks.Types.Init)]",\
 1, 1.0,4.0,0.0,0,517)
DeclareVariable("coo.con.I.y_start", "Initial or guess value of output (= state)",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("coo.con.I.reset", "Type of integrator reset [:#(type=Buildings.Types.Reset)]",\
 1, 1.0,3.0,0.0,0,517)
DeclareVariable("coo.con.I.y_reset", "Value to which integrator is reset, used if reset = Buildings.Types.Reset.Parameter",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("coo.con.I.y_reset_internal", "Internal connector for integrator reset",\
 0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("coo.con.I.trigger_internal", "Needed to use conditional connector trigger [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,2563)
DeclareVariable("coo.con.D.k", "Gains [1]", 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("coo.con.D.T", "Time constants (T>0 required; T=0 is ideal derivative block) [s]",\
 1E-60, 1E-60,1E+100,0.0,0,513)
DeclareVariable("coo.con.D.initType", "Type of initialization (1: no init, 2: steady state, 3: initial state, 4: initial output) [:#(type=Modelica.Blocks.Types.Init)]",\
 2, 1.0,4.0,0.0,0,517)
DeclareVariable("coo.con.D.x_start", "Initial or guess value of state", 0.0, \
0.0,0.0,0.0,0,513)
DeclareParameter("coo.con.D.y_start", "Initial value of output (= state)", 393, 0,\
 0.0,0.0,0.0,0,560)
DeclareAlias2("coo.con.D.u", "Connector of Real input signal", "coo.con.addD.y", 1,\
 5, 1434, 0)
DeclareAlias2("coo.con.D.y", "Connector of Real output signal", "coo.con.addPID.u2", 1,\
 5, 857, 0)
DeclareState("coo.con.D.x", "State of block", 19, 0.0, 0.0,0.0,0.0,0,544)
DeclareDerivative("coo.con.D.der(x)", "der(State of block)", 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("coo.con.D.zeroGain", "[:#(type=Boolean)]", false, 0.0,0.0,0.0,0,2563)
DeclareVariable("pumpBuiding.vol.steBal.allowFlowReversal", "= false to simplify equations, assuming, but not enforcing, no flow reversal [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,2563)
DeclareAlias2("pumpBuiding.vol.steBal.port_a.m_flow", "Mass flow rate from the connection point into the component [kg/s]",\
 "coo.port_a2.m_flow", 1, 5, 615, 1156)
DeclareAlias2("pumpBuiding.vol.steBal.port_a.p", "Thermodynamic pressure in the connection point [Pa|bar]",\
 "exp.p_start", 1, 7, 345, 1028)
DeclareVariable("pumpBuiding.vol.steBal.port_a.h_outflow", "Specific thermodynamic enthalpy close to the connection point if m_flow < 0 [J/kg]",\
 83680.0, -10000000000.0,10000000000.0,83680.0,0,2569)
DeclareAlias2("pumpBuiding.vol.steBal.port_b.m_flow", "Mass flow rate from the connection point into the component [kg/s]",\
 "coo.port_a2.m_flow", -1, 5, 615, 1156)
DeclareAlias2("pumpBuiding.vol.steBal.port_b.p", "Thermodynamic pressure in the connection point [Pa|bar]",\
 "exp.p_start", 1, 7, 345, 1028)
DeclareAlias2("pumpBuiding.vol.steBal.port_b.h_outflow", "Specific thermodynamic enthalpy close to the connection point if m_flow < 0 [J/kg]",\
 "pumpBuiding.vol.ports[2].h_outflow", 1, 5, 1107, 1028)
DeclareVariable("pumpBuiding.vol.steBal.m_flow_nominal", "Nominal mass flow rate [kg/s]",\
 0.5, 0.0,0.0,0.0,0,2561)
DeclareVariable("pumpBuiding.vol.steBal.m_flow_small", "Small mass flow rate for regularization of zero flow [kg/s]",\
 5E-05, 0.0,1E+100,0.0,0,2561)
DeclareVariable("pumpBuiding.vol.steBal.show_T", "= true, if actual temperature at port is computed [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,2563)
DeclareAlias2("pumpBuiding.vol.steBal.m_flow", "Mass flow rate from port_a to port_b (m_flow > 0 is design flow direction) [kg/s]",\
 "coo.port_a2.m_flow", 1, 5, 615, 1024)
DeclareVariable("pumpBuiding.vol.steBal.dp", "Pressure difference between port_a and port_b [Pa|Pa]",\
 0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("pumpBuiding.vol.steBal._m_flow_start", "Start value for m_flow, used to avoid a warning if not set in m_flow, and to avoid m_flow.start in parameter window [kg/s]",\
 0, 0.0,0.0,0.0,0,2561)
DeclareVariable("pumpBuiding.vol.steBal._dp_start", "Start value for dp, used to avoid a warning if not set in dp, and to avoid dp.start in parameter window [Pa|Pa]",\
 0, 0.0,0.0,0.0,0,2561)
DeclareVariable("pumpBuiding.vol.steBal.simplify_mWat_flow", "Set to true to cause port_a.m_flow + port_b.m_flow = 0 even if mWat_flow is non-zero [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,2563)
DeclareVariable("pumpBuiding.vol.steBal.prescribedHeatFlowRate", \
"Set to true if the heat flow rate is not a function of a temperature difference to the fluid temperature [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,2563)
DeclareVariable("pumpBuiding.vol.steBal.use_mWat_flow", "Set to true to enable input connector for moisture mass flow rate [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,2563)
DeclareVariable("pumpBuiding.vol.steBal.use_C_flow", "Set to true to enable input connector for trace substance [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,2563)
DeclareAlias2("pumpBuiding.vol.steBal.Q_flow", "Sensible plus latent heat flow rate transferred into the medium [W]",\
 "pumpBuiding.vol.heatPort.Q_flow", 1, 5, 1118, 1024)
DeclareAlias2("pumpBuiding.vol.steBal.hOut", "Leaving specific enthalpy of the component [J/kg]",\
 "pumpBuiding.vol.ports[2].h_outflow", 1, 5, 1107, 1024)
DeclareVariable("pumpBuiding.vol.steBal.use_m_flowInv", "Flag, true if m_flowInv is used in the model [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,2563)
DeclareVariable("pumpBuiding.vol.steBal.m_flowInv", "Regularization of 1/m_flow of port_a [s/kg]",\
 0.0, 0.0,0.0,0.0,0,2560)
DeclareVariable("pumpBuiding.vol.steBal.deltaReg", "Smoothing region for inverseXRegularized",\
 5.0000000000000004E-08, 0.0,0.0,0.0,0,2561)
DeclareVariable("pumpBuiding.vol.steBal.deltaInvReg", "Inverse value of delta for inverseXRegularized",\
 20000000.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("pumpBuiding.vol.steBal.aReg", "Polynomial coefficient for inverseXRegularized",\
 -300000000.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("pumpBuiding.vol.steBal.bReg", "Polynomial coefficient for inverseXRegularized",\
 4.76E+16, 0.0,0.0,0.0,0,2561)
DeclareVariable("pumpBuiding.vol.steBal.cReg", "Polynomial coefficient for inverseXRegularized",\
 -2.888E+24, 0.0,0.0,0.0,0,2561)
DeclareVariable("pumpBuiding.vol.steBal.dReg", "Polynomial coefficient for inverseXRegularized",\
 8.544E+31, 0.0,0.0,0.0,0,2561)
DeclareVariable("pumpBuiding.vol.steBal.eReg", "Polynomial coefficient for inverseXRegularized",\
 -1.216E+39, 0.0,0.0,0.0,0,2561)
DeclareVariable("pumpBuiding.vol.steBal.fReg", "Polynomial coefficient for inverseXRegularized",\
 6.656E+45, 0.0,0.0,0.0,0,2561)
DeclareVariable("pumpBuiding.vol.steBal.state_default.p", "Absolute pressure of medium [Pa|bar]",\
 300000.0, 0.0,100000000.0,100000.0,0,2561)
DeclareVariable("pumpBuiding.vol.steBal.state_default.T", "Temperature of medium [K|degC]",\
 293.15, 1.0,10000.0,300.0,0,2561)
DeclareVariable("pumpBuiding.vol.steBal.cp_default", "Specific heat capacity, used to verify energy conservation [J/(kg.K)]",\
 4184, 0.0,0.0,0.0,0,2561)
DeclareVariable("pumpBuiding.vol.steBal.dTMax", "Maximum temperature difference across the StaticTwoPortConservationEquation [K,]",\
 200, 1.0,1E+100,0.0,0,2561)
DeclareVariable("pumpBuiding.vol.steBal.mWat_flow_internal", "Needed to connect to conditional connector [kg/s]",\
 0, 0.0,0.0,0.0,0,2561)
DeclareAlias2("pumpBuiding.eff.dp_in", "Prescribed pressure increase [Pa]", \
"pumpBuiding.senRelPre.p_rel", 1, 5, 1165, 1024)
DeclareVariable("CoolingUnit.vol.dynBal.energyDynamics", "Type of energy balance: dynamic (3 initialization options) or steady state [:#(type=Modelica.Fluid.Types.Dynamics)]",\
 1, 1.0,4.0,0.0,0,2565)
DeclareVariable("CoolingUnit.vol.dynBal.massDynamics", "Type of mass balance: dynamic (3 initialization options) or steady state [:#(type=Modelica.Fluid.Types.Dynamics)]",\
 1, 1.0,4.0,0.0,0,2565)
DeclareVariable("CoolingUnit.vol.dynBal.substanceDynamics", "Type of independent mass fraction balance: dynamic (3 initialization options) or steady state [:#(type=Modelica.Fluid.Types.Dynamics)]",\
 1, 1.0,4.0,0.0,0,2565)
DeclareVariable("CoolingUnit.vol.dynBal.traceDynamics", "Type of trace substance balance: dynamic (3 initialization options) or steady state [:#(type=Modelica.Fluid.Types.Dynamics)]",\
 1, 1.0,4.0,0.0,0,2565)
DeclareVariable("CoolingUnit.vol.dynBal.p_start", "Start value of pressure [Pa|bar]",\
 300000, 0.0,100000000.0,100000.0,0,2561)
DeclareVariable("CoolingUnit.vol.dynBal.T_start", "Start value of temperature [K|degC]",\
 293.15, 1.0,10000.0,300.0,0,2561)
DeclareVariable("CoolingUnit.vol.dynBal.X_start[1]", "Start value of mass fractions m_i/m [kg/kg]",\
 0.0, 0.0,1.0,0.1,0,2561)
DeclareVariable("CoolingUnit.vol.dynBal.mSenFac", "Factor for scaling the sensible thermal mass of the volume",\
 1.0, 1.0,1E+100,0.0,0,2561)
DeclareVariable("CoolingUnit.vol.dynBal.initialize_p", "= true to set up initial equations for pressure [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,1539)
DeclareVariable("CoolingUnit.vol.dynBal.simplify_mWat_flow", "Set to true to cause port_a.m_flow + port_b.m_flow = 0 even if mWat_flow is non-zero. Used only if Medium.nX > 1 [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,2563)
DeclareVariable("CoolingUnit.vol.dynBal.nPorts", "Number of ports [:#(type=Integer)]",\
 2, 0.0,0.0,0.0,0,2565)
DeclareVariable("CoolingUnit.vol.dynBal.use_mWat_flow", "Set to true to enable input connector for moisture mass flow rate [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,2563)
DeclareVariable("CoolingUnit.vol.dynBal.use_C_flow", "Set to true to enable input connector for trace substance [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,2563)
DeclareAlias2("CoolingUnit.vol.dynBal.Q_flow", "Sensible plus latent heat flow rate transferred into the medium [W]",\
 "CoolingUnit.Q_flow", 1, 5, 1315, 1024)
DeclareAlias2("CoolingUnit.vol.dynBal.hOut", "Leaving specific enthalpy of the component [J/kg]",\
 "CoolingUnit.port_a.h_outflow", 1, 5, 1251, 1024)
DeclareAlias2("CoolingUnit.vol.dynBal.UOut", "Internal energy of the component [J]",\
 "CoolingUnit.vol.dynBal.U", 1, 1, 20, 1024)
DeclareAlias2("CoolingUnit.vol.dynBal.mOut", "Mass of the component [kg]", \
"CoolingUnit.vol.dynBal.m", 1, 5, 1498, 1024)
DeclareAlias2("CoolingUnit.vol.dynBal.ports[1].m_flow", "Mass flow rate from the connection point into the component [kg/s]",\
 "coo.port_a2.m_flow", 1, 5, 615, 1156)
DeclareAlias2("CoolingUnit.vol.dynBal.ports[1].p", "Thermodynamic pressure in the connection point [Pa|bar]",\
 "coo.port_a2.p", 1, 5, 616, 1028)
DeclareAlias2("CoolingUnit.vol.dynBal.ports[1].h_outflow", "Specific thermodynamic enthalpy close to the connection point if m_flow < 0 [J/kg]",\
 "CoolingUnit.port_a.h_outflow", 1, 5, 1251, 1028)
DeclareAlias2("CoolingUnit.vol.dynBal.ports[2].m_flow", "Mass flow rate from the connection point into the component [kg/s]",\
 "coo.port_a2.m_flow", -1, 5, 615, 1156)
DeclareAlias2("CoolingUnit.vol.dynBal.ports[2].p", "Thermodynamic pressure in the connection point [Pa|bar]",\
 "coo.port_a2.p", 1, 5, 616, 1028)
DeclareAlias2("CoolingUnit.vol.dynBal.ports[2].h_outflow", "Specific thermodynamic enthalpy close to the connection point if m_flow < 0 [J/kg]",\
 "CoolingUnit.port_a.h_outflow", 1, 5, 1251, 1028)
DeclareVariable("CoolingUnit.vol.dynBal.medium.T", "Temperature of medium [K|degC]",\
 300.0, 1.0,10000.0,300.0,0,2560)
DeclareAlias2("CoolingUnit.vol.dynBal.medium.p", "Absolute pressure of medium [Pa|bar]",\
 "coo.port_a2.p", 1, 5, 616, 1024)
DeclareAlias2("CoolingUnit.vol.dynBal.medium.h", "Specific enthalpy of medium [J/kg]",\
 "CoolingUnit.port_a.h_outflow", 1, 5, 1251, 1024)
DeclareAlias2("CoolingUnit.vol.dynBal.medium.u", "Specific internal energy of medium [J/kg]",\
 "CoolingUnit.port_a.h_outflow", 1, 5, 1251, 1024)
DeclareVariable("CoolingUnit.vol.dynBal.medium.d", "Density of medium [kg/m3|g/cm3]",\
 995.586, 0.0,1E+100,0.0,0,2561)
DeclareVariable("CoolingUnit.vol.dynBal.medium.X[1]", "Mass fractions (= (component mass)/total mass  m_i/m) [1]",\
 1, 0.0,1.0,0.0,0,2561)
DeclareVariable("CoolingUnit.vol.dynBal.medium.R", "Gas constant (of mixture if applicable) [J/(kg.K)]",\
 0, 0.0,0.0,0.0,0,2561)
DeclareVariable("CoolingUnit.vol.dynBal.medium.MM", "Molar mass (of mixture or single fluid) [kg/mol]",\
 0.018015268, 0.0,1E+100,0.0,0,2561)
DeclareAlias2("CoolingUnit.vol.dynBal.medium.state.p", "Absolute pressure of medium [Pa|bar]",\
 "coo.port_a2.p", 1, 5, 616, 1024)
DeclareAlias2("CoolingUnit.vol.dynBal.medium.state.T", "Temperature of medium [K|degC]",\
 "CoolingUnit.vol.dynBal.medium.T", 1, 5, 1489, 1024)
DeclareVariable("CoolingUnit.vol.dynBal.medium.preferredMediumStates", \
"= true if StateSelect.prefer shall be used for the independent property variables of the medium [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,2563)
DeclareVariable("CoolingUnit.vol.dynBal.medium.standardOrderComponents", \
"If true, and reducedX = true, the last element of X will be computed from the other ones [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,2563)
DeclareVariable("CoolingUnit.vol.dynBal.medium.T_degC", "Temperature of medium in [degC] [degC;]",\
 0.0, 0.0,0.0,0.0,0,2560)
DeclareVariable("CoolingUnit.vol.dynBal.medium.p_bar", "Absolute pressure of medium in [bar] [bar]",\
 0.0, 0.0,0.0,0.0,0,2560)
DeclareState("CoolingUnit.vol.dynBal.U", "Internal energy of fluid [J]", 20, 0.0,\
 0.0,0.0,100000.0,0,2592)
DeclareDerivative("CoolingUnit.vol.dynBal.der(U)", "der(Internal energy of fluid) [W]",\
 0.0, 0.0,0.0,0.0,0,2560)
DeclareVariable("CoolingUnit.vol.dynBal.m", "Mass of fluid [kg]", 0.0, 0.0,\
1E+100,0.0,0,2561)
DeclareVariable("CoolingUnit.vol.dynBal.der(m)", "der(Mass of fluid) [kg/s]", \
0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("CoolingUnit.vol.dynBal.mb_flow", "Mass flows across boundaries [kg/s]",\
 0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("CoolingUnit.vol.dynBal.Hb_flow", "Enthalpy flow across boundaries or energy source/sink [W]",\
 0.0, 0.0,0.0,0.0,0,2560)
DeclareVariable("CoolingUnit.vol.dynBal.fluidVolume", "Volume [m3]", 0.0, \
0.0,0.0,0.0,0,2561)
DeclareVariable("CoolingUnit.vol.dynBal.CSen", "Aditional heat capacity for implementing mFactor [J/K]",\
 0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("CoolingUnit.vol.dynBal.ports_H_flow[1]", "[W]", 0.0, \
-100000000.0,100000000.0,1000.0,0,2560)
DeclareVariable("CoolingUnit.vol.dynBal.ports_H_flow[2]", "[W]", 0.0, \
-100000000.0,100000000.0,1000.0,0,2560)
DeclareVariable("CoolingUnit.vol.dynBal.cp_default", "Heat capacity, to compute additional dry mass [J/(kg.K)]",\
 4184, 0.0,0.0,0.0,0,2561)
DeclareVariable("CoolingUnit.vol.dynBal.rho_start", "Density, used to compute fluid mass [kg/m3|g/cm3]",\
 995.586, 0.0,1E+100,0.0,0,2561)
DeclareVariable("CoolingUnit.vol.dynBal.computeCSen", "[:#(type=Boolean)]", \
false, 0.0,0.0,0.0,0,2563)
DeclareVariable("CoolingUnit.vol.dynBal.state_default.p", "Absolute pressure of medium [Pa|bar]",\
 300000.0, 0.0,100000000.0,100000.0,0,2561)
DeclareVariable("CoolingUnit.vol.dynBal.state_default.T", "Temperature of medium [K|degC]",\
 293.15, 1.0,10000.0,300.0,0,2561)
DeclareVariable("CoolingUnit.vol.dynBal.rho_default", "Density, used to compute fluid mass [kg/m3|g/cm3]",\
 995.586, 0.0,1E+100,0.0,0,2561)
DeclareVariable("CoolingUnit.vol.dynBal.hStart", "Start value for specific enthalpy [J/kg]",\
 0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("CoolingUnit.vol.dynBal._simplify_mWat_flow", "If true, then port_a.m_flow + port_b.m_flow = 0 even if mWat_flow is non-zero, and equations are simplified [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,2563)
DeclareVariable("CoolingUnit.vol.dynBal.mWat_flow_internal", "Needed to connect to conditional connector [kg/s]",\
 0, 0.0,0.0,0.0,0,2561)
DeclareAlias2("weaDat.weaBus.pAtm", "Atmospheric pressure [Pa]", "weaDat.pAtm", 1,\
 7, 4, 4)
DeclareAlias2("weaDat.weaBus.nTot", "Sky cover [0, 1] [1]", "weaDat.cheTotSkyCov.nOut", 1,\
 5, 78, 4)
DeclareAlias2("weaDat.weaBus.nOpa", "Sky cover [0, 1] [1]", "weaDat.cheOpaSkyCov.nOut", 1,\
 5, 82, 4)
DeclareAlias2("weaDat.weaBus.HGloHor", "Radiation [W/m2]", "weaDat.cheGloHorRad.HOut", 1,\
 5, 86, 4)
DeclareAlias2("weaDat.weaBus.HDifHor", "Radiation [W/m2]", "weaDat.cheDifHorRad.HOut", 1,\
 5, 88, 4)
DeclareAlias2("weaDat.weaBus.HDirNor", "Radiation [W/m2]", "weaDat.cheDirNorRad.HOut", 1,\
 5, 90, 4)
DeclareAlias2("weaDat.weaBus.celHei", "Ceiling height [m]", "weaDat.cheCeiHei.ceiHeiOut", 1,\
 5, 92, 4)
DeclareAlias2("weaDat.weaBus.winSpe", "Wind speed [m/s]", "weaDat.cheWinSpe.winSpeOut", 1,\
 5, 94, 4)
DeclareAlias2("weaDat.weaBus.HHorIR", "Horizontal infrared irradiation [W/m2]", \
"weaDat.cheHorRad.HOut", 1, 5, 96, 4)
DeclareAlias2("weaDat.weaBus.winDir", "Wind direction [rad|deg]", \
"weaDat.cheWinDir.nOut", 1, 5, 98, 4)
DeclareAlias2("weaDat.weaBus.cloTim", "Connector of Real output signal", \
"weaDat.modTim.y", 1, 5, 106, 4)
DeclareAlias2("weaDat.weaBus.solTim", "Solar time [s|s]", "weaDat.solTim.solTim", 1,\
 5, 138, 4)
DeclareAlias2("weaDat.weaBus.TDewPoi", "Output temperature [K|degC]", \
"weaDat.TDewPoi_in_internal", 1, 5, 143, 4)
DeclareAlias2("weaDat.weaBus.relHum", "Relative humidity [1]", "weaDat.cheRelHum.relHumOut", 1,\
 5, 156, 4)
DeclareAlias2("weaDat.weaBus.TDryBul", "Output temperature [K|degC]", \
"weaDat.TDryBul_in_internal", 1, 5, 142, 4)
DeclareAlias2("weaDat.weaBus.solAlt", "Solar altitude angle [rad|deg]", \
"weaDat.altAng.alt", 1, 5, 161, 4)
DeclareAlias2("weaDat.weaBus.solZen", "Zenith angle [rad|deg]", "weaDat.altAng.zen", 1,\
 5, 160, 4)
DeclareAlias2("weaDat.weaBus.solDec", "Solar declination angle [rad|deg]", \
"weaDat.zenAng.decAng", 1, 5, 164, 4)
DeclareAlias2("weaDat.weaBus.solHouAng", "Solar hour angle [rad|deg]", \
"weaDat.zenAng.solHouAng", 1, 5, 163, 4)
DeclareVariable("weaDat.weaBus.lon", "Longitude of the location [rad|deg]", \
-2.1362830044410592, 0.0,0.0,0.0,0,521)
DeclareVariable("weaDat.weaBus.lat", "Latitude of the location [rad|deg]", \
0.6565928646002667, 0.0,0.0,0.0,0,521)
DeclareAlias2("weaDat.weaBus.TBlaSky", "Black-body sky temperature [K|degC]", \
"weaDat.TBlaSky_in_internal", 1, 5, 144, 4)
DeclareAlias2("building.HDifTil[1].incAng.weaBus.cloTim", "Day number with units of seconds [s]",\
 "weaDat.modTim.y", 1, 5, 106, 1028)
DeclareAlias2("building.HDifTil[1].incAng.weaBus.solTim", "Solar time [s]", \
"weaDat.solTim.solTim", 1, 5, 138, 1028)
DeclareAlias2("building.HDifTil[1].weaBus.solZen", "Zenith angle of the sun beam [rad|degreeC]",\
 "weaDat.altAng.zen", 1, 5, 160, 4)
DeclareAlias2("building.HDifTil[1].weaBus.HGloHor", "Horizontal global solar radiation [W/m2]",\
 "weaDat.cheGloHorRad.HOut", 1, 5, 86, 4)
DeclareAlias2("building.HDifTil[1].weaBus.HDifHor", "Horizontal diffuse solar radiation [W/m2]",\
 "weaDat.cheDifHorRad.HOut", 1, 5, 88, 4)
DeclareAlias2("building.HDifTil[2].incAng.weaBus.cloTim", "Day number with units of seconds [s]",\
 "weaDat.modTim.y", 1, 5, 106, 1028)
DeclareAlias2("building.HDifTil[2].incAng.weaBus.solTim", "Solar time [s]", \
"weaDat.solTim.solTim", 1, 5, 138, 1028)
DeclareAlias2("building.HDifTil[2].weaBus.solZen", "Zenith angle of the sun beam [rad|degreeC]",\
 "weaDat.altAng.zen", 1, 5, 160, 4)
DeclareAlias2("building.HDifTil[2].weaBus.HGloHor", "Horizontal global solar radiation [W/m2]",\
 "weaDat.cheGloHorRad.HOut", 1, 5, 86, 4)
DeclareAlias2("building.HDifTil[2].weaBus.HDifHor", "Horizontal diffuse solar radiation [W/m2]",\
 "weaDat.cheDifHorRad.HOut", 1, 5, 88, 4)
DeclareAlias2("building.HDirTil[1].incAng.weaBus.cloTim", "Day number with units of seconds [s]",\
 "weaDat.modTim.y", 1, 5, 106, 1028)
DeclareAlias2("building.HDirTil[1].incAng.weaBus.solTim", "Solar time [s]", \
"weaDat.solTim.solTim", 1, 5, 138, 1028)
DeclareAlias2("building.HDirTil[1].weaBus.HDirNor", "Direct normal radiation [W/m2]",\
 "weaDat.cheDirNorRad.HOut", 1, 5, 90, 4)
DeclareAlias2("building.HDirTil[2].incAng.weaBus.cloTim", "Day number with units of seconds [s]",\
 "weaDat.modTim.y", 1, 5, 106, 1028)
DeclareAlias2("building.HDirTil[2].incAng.weaBus.solTim", "Solar time [s]", \
"weaDat.solTim.solTim", 1, 5, 138, 1028)
DeclareAlias2("building.HDirTil[2].weaBus.HDirNor", "Direct normal radiation [W/m2]",\
 "weaDat.cheDirNorRad.HOut", 1, 5, 90, 4)
DeclareAlias2("building.weaBus.TBlaSky", "Black-body sky temperature [K|degC]", \
"weaDat.TBlaSky_in_internal", 1, 5, 144, 4)
DeclareAlias2("building.weaBus.TDryBul", "Dry bulb temperature [K|degC]", \
"weaDat.TDryBul_in_internal", 1, 5, 142, 4)
DeclareAlias2("building.HDifTil[1].incAng.weaBus.HDifHor", "Radiation [W/m2]", \
"weaDat.cheDifHorRad.HOut", 1, 5, 88, 1028)
DeclareAlias2("building.HDifTil[1].incAng.weaBus.HDirNor", "Radiation [W/m2]", \
"weaDat.cheDirNorRad.HOut", 1, 5, 90, 1028)
DeclareAlias2("building.HDifTil[1].incAng.weaBus.HGloHor", "Radiation [W/m2]", \
"weaDat.cheGloHorRad.HOut", 1, 5, 86, 1028)
DeclareAlias2("building.HDifTil[1].incAng.weaBus.HHorIR", "Horizontal infrared irradiation [W/m2]",\
 "weaDat.cheHorRad.HOut", 1, 5, 96, 1028)
DeclareAlias2("building.HDifTil[1].incAng.weaBus.TBlaSky", "Black-body sky temperature [K|degC]",\
 "weaDat.TBlaSky_in_internal", 1, 5, 144, 1028)
DeclareAlias2("building.HDifTil[1].incAng.weaBus.TDewPoi", "Output temperature [K|degC]",\
 "weaDat.TDewPoi_in_internal", 1, 5, 143, 1028)
DeclareAlias2("building.HDifTil[1].incAng.weaBus.TDryBul", "Output temperature [K|degC]",\
 "weaDat.TDryBul_in_internal", 1, 5, 142, 1028)
DeclareAlias2("building.HDifTil[1].incAng.weaBus.celHei", "Ceiling height [m]", \
"weaDat.cheCeiHei.ceiHeiOut", 1, 5, 92, 1028)
DeclareVariable("building.HDifTil[1].incAng.weaBus.lat", "Latitude of the location [rad|deg]",\
 0.6565928646002667, 0.0,0.0,0.0,0,2569)
DeclareVariable("building.HDifTil[1].incAng.weaBus.lon", "Longitude of the location [rad|deg]",\
 -2.1362830044410592, 0.0,0.0,0.0,0,2569)
DeclareAlias2("building.HDifTil[1].incAng.weaBus.nOpa", "Sky cover [0, 1] [1]", \
"weaDat.cheOpaSkyCov.nOut", 1, 5, 82, 1028)
DeclareAlias2("building.HDifTil[1].incAng.weaBus.nTot", "Sky cover [0, 1] [1]", \
"weaDat.cheTotSkyCov.nOut", 1, 5, 78, 1028)
DeclareAlias2("building.HDifTil[1].incAng.weaBus.pAtm", "Atmospheric pressure [Pa]",\
 "weaDat.pAtm", 1, 7, 4, 1028)
DeclareAlias2("building.HDifTil[1].incAng.weaBus.relHum", "Relative humidity [1]",\
 "weaDat.cheRelHum.relHumOut", 1, 5, 156, 1028)
DeclareAlias2("building.HDifTil[1].incAng.weaBus.solAlt", "Solar altitude angle [rad|deg]",\
 "weaDat.altAng.alt", 1, 5, 161, 1028)
DeclareAlias2("building.HDifTil[1].incAng.weaBus.solDec", "Solar declination angle [rad|deg]",\
 "weaDat.zenAng.decAng", 1, 5, 164, 1028)
DeclareAlias2("building.HDifTil[1].incAng.weaBus.solHouAng", "Solar hour angle [rad|deg]",\
 "weaDat.zenAng.solHouAng", 1, 5, 163, 1028)
DeclareAlias2("building.HDifTil[1].incAng.weaBus.solZen", "Zenith angle [rad|deg]",\
 "weaDat.altAng.zen", 1, 5, 160, 1028)
DeclareAlias2("building.HDifTil[1].incAng.weaBus.winDir", "Wind direction [rad|deg]",\
 "weaDat.cheWinDir.nOut", 1, 5, 98, 1028)
DeclareAlias2("building.HDifTil[1].incAng.weaBus.winSpe", "Wind speed [m/s]", \
"weaDat.cheWinSpe.winSpeOut", 1, 5, 94, 1028)
DeclareAlias2("building.HDifTil[1].weaBus.HDirNor", "Radiation [W/m2]", \
"weaDat.cheDirNorRad.HOut", 1, 5, 90, 4)
DeclareAlias2("building.HDifTil[1].weaBus.HHorIR", "Horizontal infrared irradiation [W/m2]",\
 "weaDat.cheHorRad.HOut", 1, 5, 96, 4)
DeclareAlias2("building.HDifTil[1].weaBus.TBlaSky", "Black-body sky temperature [K|degC]",\
 "weaDat.TBlaSky_in_internal", 1, 5, 144, 4)
DeclareAlias2("building.HDifTil[1].weaBus.TDewPoi", "Output temperature [K|degC]",\
 "weaDat.TDewPoi_in_internal", 1, 5, 143, 4)
DeclareAlias2("building.HDifTil[1].weaBus.TDryBul", "Output temperature [K|degC]",\
 "weaDat.TDryBul_in_internal", 1, 5, 142, 4)
DeclareAlias2("building.HDifTil[1].weaBus.celHei", "Ceiling height [m]", \
"weaDat.cheCeiHei.ceiHeiOut", 1, 5, 92, 4)
DeclareAlias2("building.HDifTil[1].weaBus.cloTim", "Connector of Real output signal [s]",\
 "weaDat.modTim.y", 1, 5, 106, 4)
DeclareVariable("building.HDifTil[1].weaBus.lat", "Latitude of the location [rad|deg]",\
 0.6565928646002667, 0.0,0.0,0.0,0,521)
DeclareVariable("building.HDifTil[1].weaBus.lon", "Longitude of the location [rad|deg]",\
 -2.1362830044410592, 0.0,0.0,0.0,0,521)
DeclareAlias2("building.HDifTil[1].weaBus.nOpa", "Sky cover [0, 1] [1]", \
"weaDat.cheOpaSkyCov.nOut", 1, 5, 82, 4)
DeclareAlias2("building.HDifTil[1].weaBus.nTot", "Sky cover [0, 1] [1]", \
"weaDat.cheTotSkyCov.nOut", 1, 5, 78, 4)
DeclareAlias2("building.HDifTil[1].weaBus.pAtm", "Atmospheric pressure [Pa]", \
"weaDat.pAtm", 1, 7, 4, 4)
DeclareAlias2("building.HDifTil[1].weaBus.relHum", "Relative humidity [1]", \
"weaDat.cheRelHum.relHumOut", 1, 5, 156, 4)
DeclareAlias2("building.HDifTil[1].weaBus.solAlt", "Solar altitude angle [rad|deg]",\
 "weaDat.altAng.alt", 1, 5, 161, 4)
DeclareAlias2("building.HDifTil[1].weaBus.solDec", "Solar declination angle [rad|deg]",\
 "weaDat.zenAng.decAng", 1, 5, 164, 4)
DeclareAlias2("building.HDifTil[1].weaBus.solHouAng", "Solar hour angle [rad|deg]",\
 "weaDat.zenAng.solHouAng", 1, 5, 163, 4)
DeclareAlias2("building.HDifTil[1].weaBus.solTim", "Solar time [s|s]", \
"weaDat.solTim.solTim", 1, 5, 138, 4)
DeclareAlias2("building.HDifTil[1].weaBus.winDir", "Wind direction [rad|deg]", \
"weaDat.cheWinDir.nOut", 1, 5, 98, 4)
DeclareAlias2("building.HDifTil[1].weaBus.winSpe", "Wind speed [m/s]", \
"weaDat.cheWinSpe.winSpeOut", 1, 5, 94, 4)
DeclareAlias2("building.HDifTil[2].incAng.weaBus.HDifHor", "Radiation [W/m2]", \
"weaDat.cheDifHorRad.HOut", 1, 5, 88, 1028)
DeclareAlias2("building.HDifTil[2].incAng.weaBus.HDirNor", "Radiation [W/m2]", \
"weaDat.cheDirNorRad.HOut", 1, 5, 90, 1028)
DeclareAlias2("building.HDifTil[2].incAng.weaBus.HGloHor", "Radiation [W/m2]", \
"weaDat.cheGloHorRad.HOut", 1, 5, 86, 1028)
DeclareAlias2("building.HDifTil[2].incAng.weaBus.HHorIR", "Horizontal infrared irradiation [W/m2]",\
 "weaDat.cheHorRad.HOut", 1, 5, 96, 1028)
DeclareAlias2("building.HDifTil[2].incAng.weaBus.TBlaSky", "Black-body sky temperature [K|degC]",\
 "weaDat.TBlaSky_in_internal", 1, 5, 144, 1028)
DeclareAlias2("building.HDifTil[2].incAng.weaBus.TDewPoi", "Output temperature [K|degC]",\
 "weaDat.TDewPoi_in_internal", 1, 5, 143, 1028)
DeclareAlias2("building.HDifTil[2].incAng.weaBus.TDryBul", "Output temperature [K|degC]",\
 "weaDat.TDryBul_in_internal", 1, 5, 142, 1028)
DeclareAlias2("building.HDifTil[2].incAng.weaBus.celHei", "Ceiling height [m]", \
"weaDat.cheCeiHei.ceiHeiOut", 1, 5, 92, 1028)
DeclareVariable("building.HDifTil[2].incAng.weaBus.lat", "Latitude of the location [rad|deg]",\
 0.6565928646002667, 0.0,0.0,0.0,0,2569)
DeclareVariable("building.HDifTil[2].incAng.weaBus.lon", "Longitude of the location [rad|deg]",\
 -2.1362830044410592, 0.0,0.0,0.0,0,2569)
DeclareAlias2("building.HDifTil[2].incAng.weaBus.nOpa", "Sky cover [0, 1] [1]", \
"weaDat.cheOpaSkyCov.nOut", 1, 5, 82, 1028)
DeclareAlias2("building.HDifTil[2].incAng.weaBus.nTot", "Sky cover [0, 1] [1]", \
"weaDat.cheTotSkyCov.nOut", 1, 5, 78, 1028)
DeclareAlias2("building.HDifTil[2].incAng.weaBus.pAtm", "Atmospheric pressure [Pa]",\
 "weaDat.pAtm", 1, 7, 4, 1028)
DeclareAlias2("building.HDifTil[2].incAng.weaBus.relHum", "Relative humidity [1]",\
 "weaDat.cheRelHum.relHumOut", 1, 5, 156, 1028)
DeclareAlias2("building.HDifTil[2].incAng.weaBus.solAlt", "Solar altitude angle [rad|deg]",\
 "weaDat.altAng.alt", 1, 5, 161, 1028)
DeclareAlias2("building.HDifTil[2].incAng.weaBus.solDec", "Solar declination angle [rad|deg]",\
 "weaDat.zenAng.decAng", 1, 5, 164, 1028)
DeclareAlias2("building.HDifTil[2].incAng.weaBus.solHouAng", "Solar hour angle [rad|deg]",\
 "weaDat.zenAng.solHouAng", 1, 5, 163, 1028)
DeclareAlias2("building.HDifTil[2].incAng.weaBus.solZen", "Zenith angle [rad|deg]",\
 "weaDat.altAng.zen", 1, 5, 160, 1028)
DeclareAlias2("building.HDifTil[2].incAng.weaBus.winDir", "Wind direction [rad|deg]",\
 "weaDat.cheWinDir.nOut", 1, 5, 98, 1028)
DeclareAlias2("building.HDifTil[2].incAng.weaBus.winSpe", "Wind speed [m/s]", \
"weaDat.cheWinSpe.winSpeOut", 1, 5, 94, 1028)
DeclareAlias2("building.HDifTil[2].weaBus.HDirNor", "Radiation [W/m2]", \
"weaDat.cheDirNorRad.HOut", 1, 5, 90, 4)
DeclareAlias2("building.HDifTil[2].weaBus.HHorIR", "Horizontal infrared irradiation [W/m2]",\
 "weaDat.cheHorRad.HOut", 1, 5, 96, 4)
DeclareAlias2("building.HDifTil[2].weaBus.TBlaSky", "Black-body sky temperature [K|degC]",\
 "weaDat.TBlaSky_in_internal", 1, 5, 144, 4)
DeclareAlias2("building.HDifTil[2].weaBus.TDewPoi", "Output temperature [K|degC]",\
 "weaDat.TDewPoi_in_internal", 1, 5, 143, 4)
DeclareAlias2("building.HDifTil[2].weaBus.TDryBul", "Output temperature [K|degC]",\
 "weaDat.TDryBul_in_internal", 1, 5, 142, 4)
DeclareAlias2("building.HDifTil[2].weaBus.celHei", "Ceiling height [m]", \
"weaDat.cheCeiHei.ceiHeiOut", 1, 5, 92, 4)
DeclareAlias2("building.HDifTil[2].weaBus.cloTim", "Connector of Real output signal [s]",\
 "weaDat.modTim.y", 1, 5, 106, 4)
DeclareVariable("building.HDifTil[2].weaBus.lat", "Latitude of the location [rad|deg]",\
 0.6565928646002667, 0.0,0.0,0.0,0,521)
DeclareVariable("building.HDifTil[2].weaBus.lon", "Longitude of the location [rad|deg]",\
 -2.1362830044410592, 0.0,0.0,0.0,0,521)
DeclareAlias2("building.HDifTil[2].weaBus.nOpa", "Sky cover [0, 1] [1]", \
"weaDat.cheOpaSkyCov.nOut", 1, 5, 82, 4)
DeclareAlias2("building.HDifTil[2].weaBus.nTot", "Sky cover [0, 1] [1]", \
"weaDat.cheTotSkyCov.nOut", 1, 5, 78, 4)
DeclareAlias2("building.HDifTil[2].weaBus.pAtm", "Atmospheric pressure [Pa]", \
"weaDat.pAtm", 1, 7, 4, 4)
DeclareAlias2("building.HDifTil[2].weaBus.relHum", "Relative humidity [1]", \
"weaDat.cheRelHum.relHumOut", 1, 5, 156, 4)
DeclareAlias2("building.HDifTil[2].weaBus.solAlt", "Solar altitude angle [rad|deg]",\
 "weaDat.altAng.alt", 1, 5, 161, 4)
DeclareAlias2("building.HDifTil[2].weaBus.solDec", "Solar declination angle [rad|deg]",\
 "weaDat.zenAng.decAng", 1, 5, 164, 4)
DeclareAlias2("building.HDifTil[2].weaBus.solHouAng", "Solar hour angle [rad|deg]",\
 "weaDat.zenAng.solHouAng", 1, 5, 163, 4)
DeclareAlias2("building.HDifTil[2].weaBus.solTim", "Solar time [s|s]", \
"weaDat.solTim.solTim", 1, 5, 138, 4)
DeclareAlias2("building.HDifTil[2].weaBus.winDir", "Wind direction [rad|deg]", \
"weaDat.cheWinDir.nOut", 1, 5, 98, 4)
DeclareAlias2("building.HDifTil[2].weaBus.winSpe", "Wind speed [m/s]", \
"weaDat.cheWinSpe.winSpeOut", 1, 5, 94, 4)
DeclareAlias2("building.HDirTil[1].incAng.weaBus.HDifHor", "Radiation [W/m2]", \
"weaDat.cheDifHorRad.HOut", 1, 5, 88, 1028)
DeclareAlias2("building.HDirTil[1].incAng.weaBus.HDirNor", "Radiation [W/m2]", \
"weaDat.cheDirNorRad.HOut", 1, 5, 90, 1028)
DeclareAlias2("building.HDirTil[1].incAng.weaBus.HGloHor", "Radiation [W/m2]", \
"weaDat.cheGloHorRad.HOut", 1, 5, 86, 1028)
DeclareAlias2("building.HDirTil[1].incAng.weaBus.HHorIR", "Horizontal infrared irradiation [W/m2]",\
 "weaDat.cheHorRad.HOut", 1, 5, 96, 1028)
DeclareAlias2("building.HDirTil[1].incAng.weaBus.TBlaSky", "Black-body sky temperature [K|degC]",\
 "weaDat.TBlaSky_in_internal", 1, 5, 144, 1028)
DeclareAlias2("building.HDirTil[1].incAng.weaBus.TDewPoi", "Output temperature [K|degC]",\
 "weaDat.TDewPoi_in_internal", 1, 5, 143, 1028)
DeclareAlias2("building.HDirTil[1].incAng.weaBus.TDryBul", "Output temperature [K|degC]",\
 "weaDat.TDryBul_in_internal", 1, 5, 142, 1028)
DeclareAlias2("building.HDirTil[1].incAng.weaBus.celHei", "Ceiling height [m]", \
"weaDat.cheCeiHei.ceiHeiOut", 1, 5, 92, 1028)
DeclareVariable("building.HDirTil[1].incAng.weaBus.lat", "Latitude of the location [rad|deg]",\
 0.6565928646002667, 0.0,0.0,0.0,0,2569)
DeclareVariable("building.HDirTil[1].incAng.weaBus.lon", "Longitude of the location [rad|deg]",\
 -2.1362830044410592, 0.0,0.0,0.0,0,2569)
DeclareAlias2("building.HDirTil[1].incAng.weaBus.nOpa", "Sky cover [0, 1] [1]", \
"weaDat.cheOpaSkyCov.nOut", 1, 5, 82, 1028)
DeclareAlias2("building.HDirTil[1].incAng.weaBus.nTot", "Sky cover [0, 1] [1]", \
"weaDat.cheTotSkyCov.nOut", 1, 5, 78, 1028)
DeclareAlias2("building.HDirTil[1].incAng.weaBus.pAtm", "Atmospheric pressure [Pa]",\
 "weaDat.pAtm", 1, 7, 4, 1028)
DeclareAlias2("building.HDirTil[1].incAng.weaBus.relHum", "Relative humidity [1]",\
 "weaDat.cheRelHum.relHumOut", 1, 5, 156, 1028)
DeclareAlias2("building.HDirTil[1].incAng.weaBus.solAlt", "Solar altitude angle [rad|deg]",\
 "weaDat.altAng.alt", 1, 5, 161, 1028)
DeclareAlias2("building.HDirTil[1].incAng.weaBus.solDec", "Solar declination angle [rad|deg]",\
 "weaDat.zenAng.decAng", 1, 5, 164, 1028)
DeclareAlias2("building.HDirTil[1].incAng.weaBus.solHouAng", "Solar hour angle [rad|deg]",\
 "weaDat.zenAng.solHouAng", 1, 5, 163, 1028)
DeclareAlias2("building.HDirTil[1].incAng.weaBus.solZen", "Zenith angle [rad|deg]",\
 "weaDat.altAng.zen", 1, 5, 160, 1028)
DeclareAlias2("building.HDirTil[1].incAng.weaBus.winDir", "Wind direction [rad|deg]",\
 "weaDat.cheWinDir.nOut", 1, 5, 98, 1028)
DeclareAlias2("building.HDirTil[1].incAng.weaBus.winSpe", "Wind speed [m/s]", \
"weaDat.cheWinSpe.winSpeOut", 1, 5, 94, 1028)
DeclareAlias2("building.HDirTil[1].weaBus.HDifHor", "Radiation [W/m2]", \
"weaDat.cheDifHorRad.HOut", 1, 5, 88, 4)
DeclareAlias2("building.HDirTil[1].weaBus.HGloHor", "Radiation [W/m2]", \
"weaDat.cheGloHorRad.HOut", 1, 5, 86, 4)
DeclareAlias2("building.HDirTil[1].weaBus.HHorIR", "Horizontal infrared irradiation [W/m2]",\
 "weaDat.cheHorRad.HOut", 1, 5, 96, 4)
DeclareAlias2("building.HDirTil[1].weaBus.TBlaSky", "Black-body sky temperature [K|degC]",\
 "weaDat.TBlaSky_in_internal", 1, 5, 144, 4)
DeclareAlias2("building.HDirTil[1].weaBus.TDewPoi", "Output temperature [K|degC]",\
 "weaDat.TDewPoi_in_internal", 1, 5, 143, 4)
DeclareAlias2("building.HDirTil[1].weaBus.TDryBul", "Output temperature [K|degC]",\
 "weaDat.TDryBul_in_internal", 1, 5, 142, 4)
DeclareAlias2("building.HDirTil[1].weaBus.celHei", "Ceiling height [m]", \
"weaDat.cheCeiHei.ceiHeiOut", 1, 5, 92, 4)
DeclareAlias2("building.HDirTil[1].weaBus.cloTim", "Connector of Real output signal [s]",\
 "weaDat.modTim.y", 1, 5, 106, 4)
DeclareVariable("building.HDirTil[1].weaBus.lat", "Latitude of the location [rad|deg]",\
 0.6565928646002667, 0.0,0.0,0.0,0,521)
DeclareVariable("building.HDirTil[1].weaBus.lon", "Longitude of the location [rad|deg]",\
 -2.1362830044410592, 0.0,0.0,0.0,0,521)
DeclareAlias2("building.HDirTil[1].weaBus.nOpa", "Sky cover [0, 1] [1]", \
"weaDat.cheOpaSkyCov.nOut", 1, 5, 82, 4)
DeclareAlias2("building.HDirTil[1].weaBus.nTot", "Sky cover [0, 1] [1]", \
"weaDat.cheTotSkyCov.nOut", 1, 5, 78, 4)
DeclareAlias2("building.HDirTil[1].weaBus.pAtm", "Atmospheric pressure [Pa]", \
"weaDat.pAtm", 1, 7, 4, 4)
DeclareAlias2("building.HDirTil[1].weaBus.relHum", "Relative humidity [1]", \
"weaDat.cheRelHum.relHumOut", 1, 5, 156, 4)
DeclareAlias2("building.HDirTil[1].weaBus.solAlt", "Solar altitude angle [rad|deg]",\
 "weaDat.altAng.alt", 1, 5, 161, 4)
DeclareAlias2("building.HDirTil[1].weaBus.solDec", "Solar declination angle [rad|deg]",\
 "weaDat.zenAng.decAng", 1, 5, 164, 4)
DeclareAlias2("building.HDirTil[1].weaBus.solHouAng", "Solar hour angle [rad|deg]",\
 "weaDat.zenAng.solHouAng", 1, 5, 163, 4)
DeclareAlias2("building.HDirTil[1].weaBus.solTim", "Solar time [s|s]", \
"weaDat.solTim.solTim", 1, 5, 138, 4)
DeclareAlias2("building.HDirTil[1].weaBus.solZen", "Zenith angle [rad|deg]", \
"weaDat.altAng.zen", 1, 5, 160, 4)
DeclareAlias2("building.HDirTil[1].weaBus.winDir", "Wind direction [rad|deg]", \
"weaDat.cheWinDir.nOut", 1, 5, 98, 4)
DeclareAlias2("building.HDirTil[1].weaBus.winSpe", "Wind speed [m/s]", \
"weaDat.cheWinSpe.winSpeOut", 1, 5, 94, 4)
DeclareAlias2("building.HDirTil[2].incAng.weaBus.HDifHor", "Radiation [W/m2]", \
"weaDat.cheDifHorRad.HOut", 1, 5, 88, 1028)
DeclareAlias2("building.HDirTil[2].incAng.weaBus.HDirNor", "Radiation [W/m2]", \
"weaDat.cheDirNorRad.HOut", 1, 5, 90, 1028)
DeclareAlias2("building.HDirTil[2].incAng.weaBus.HGloHor", "Radiation [W/m2]", \
"weaDat.cheGloHorRad.HOut", 1, 5, 86, 1028)
DeclareAlias2("building.HDirTil[2].incAng.weaBus.HHorIR", "Horizontal infrared irradiation [W/m2]",\
 "weaDat.cheHorRad.HOut", 1, 5, 96, 1028)
DeclareAlias2("building.HDirTil[2].incAng.weaBus.TBlaSky", "Black-body sky temperature [K|degC]",\
 "weaDat.TBlaSky_in_internal", 1, 5, 144, 1028)
DeclareAlias2("building.HDirTil[2].incAng.weaBus.TDewPoi", "Output temperature [K|degC]",\
 "weaDat.TDewPoi_in_internal", 1, 5, 143, 1028)
DeclareAlias2("building.HDirTil[2].incAng.weaBus.TDryBul", "Output temperature [K|degC]",\
 "weaDat.TDryBul_in_internal", 1, 5, 142, 1028)
DeclareAlias2("building.HDirTil[2].incAng.weaBus.celHei", "Ceiling height [m]", \
"weaDat.cheCeiHei.ceiHeiOut", 1, 5, 92, 1028)
DeclareVariable("building.HDirTil[2].incAng.weaBus.lat", "Latitude of the location [rad|deg]",\
 0.6565928646002667, 0.0,0.0,0.0,0,2569)
DeclareVariable("building.HDirTil[2].incAng.weaBus.lon", "Longitude of the location [rad|deg]",\
 -2.1362830044410592, 0.0,0.0,0.0,0,2569)
DeclareAlias2("building.HDirTil[2].incAng.weaBus.nOpa", "Sky cover [0, 1] [1]", \
"weaDat.cheOpaSkyCov.nOut", 1, 5, 82, 1028)
DeclareAlias2("building.HDirTil[2].incAng.weaBus.nTot", "Sky cover [0, 1] [1]", \
"weaDat.cheTotSkyCov.nOut", 1, 5, 78, 1028)
DeclareAlias2("building.HDirTil[2].incAng.weaBus.pAtm", "Atmospheric pressure [Pa]",\
 "weaDat.pAtm", 1, 7, 4, 1028)
DeclareAlias2("building.HDirTil[2].incAng.weaBus.relHum", "Relative humidity [1]",\
 "weaDat.cheRelHum.relHumOut", 1, 5, 156, 1028)
DeclareAlias2("building.HDirTil[2].incAng.weaBus.solAlt", "Solar altitude angle [rad|deg]",\
 "weaDat.altAng.alt", 1, 5, 161, 1028)
DeclareAlias2("building.HDirTil[2].incAng.weaBus.solDec", "Solar declination angle [rad|deg]",\
 "weaDat.zenAng.decAng", 1, 5, 164, 1028)
DeclareAlias2("building.HDirTil[2].incAng.weaBus.solHouAng", "Solar hour angle [rad|deg]",\
 "weaDat.zenAng.solHouAng", 1, 5, 163, 1028)
DeclareAlias2("building.HDirTil[2].incAng.weaBus.solZen", "Zenith angle [rad|deg]",\
 "weaDat.altAng.zen", 1, 5, 160, 1028)
DeclareAlias2("building.HDirTil[2].incAng.weaBus.winDir", "Wind direction [rad|deg]",\
 "weaDat.cheWinDir.nOut", 1, 5, 98, 1028)
DeclareAlias2("building.HDirTil[2].incAng.weaBus.winSpe", "Wind speed [m/s]", \
"weaDat.cheWinSpe.winSpeOut", 1, 5, 94, 1028)
DeclareAlias2("building.HDirTil[2].weaBus.HDifHor", "Radiation [W/m2]", \
"weaDat.cheDifHorRad.HOut", 1, 5, 88, 4)
DeclareAlias2("building.HDirTil[2].weaBus.HGloHor", "Radiation [W/m2]", \
"weaDat.cheGloHorRad.HOut", 1, 5, 86, 4)
DeclareAlias2("building.HDirTil[2].weaBus.HHorIR", "Horizontal infrared irradiation [W/m2]",\
 "weaDat.cheHorRad.HOut", 1, 5, 96, 4)
DeclareAlias2("building.HDirTil[2].weaBus.TBlaSky", "Black-body sky temperature [K|degC]",\
 "weaDat.TBlaSky_in_internal", 1, 5, 144, 4)
DeclareAlias2("building.HDirTil[2].weaBus.TDewPoi", "Output temperature [K|degC]",\
 "weaDat.TDewPoi_in_internal", 1, 5, 143, 4)
DeclareAlias2("building.HDirTil[2].weaBus.TDryBul", "Output temperature [K|degC]",\
 "weaDat.TDryBul_in_internal", 1, 5, 142, 4)
DeclareAlias2("building.HDirTil[2].weaBus.celHei", "Ceiling height [m]", \
"weaDat.cheCeiHei.ceiHeiOut", 1, 5, 92, 4)
DeclareAlias2("building.HDirTil[2].weaBus.cloTim", "Connector of Real output signal [s]",\
 "weaDat.modTim.y", 1, 5, 106, 4)
DeclareVariable("building.HDirTil[2].weaBus.lat", "Latitude of the location [rad|deg]",\
 0.6565928646002667, 0.0,0.0,0.0,0,521)
DeclareVariable("building.HDirTil[2].weaBus.lon", "Longitude of the location [rad|deg]",\
 -2.1362830044410592, 0.0,0.0,0.0,0,521)
DeclareAlias2("building.HDirTil[2].weaBus.nOpa", "Sky cover [0, 1] [1]", \
"weaDat.cheOpaSkyCov.nOut", 1, 5, 82, 4)
DeclareAlias2("building.HDirTil[2].weaBus.nTot", "Sky cover [0, 1] [1]", \
"weaDat.cheTotSkyCov.nOut", 1, 5, 78, 4)
DeclareAlias2("building.HDirTil[2].weaBus.pAtm", "Atmospheric pressure [Pa]", \
"weaDat.pAtm", 1, 7, 4, 4)
DeclareAlias2("building.HDirTil[2].weaBus.relHum", "Relative humidity [1]", \
"weaDat.cheRelHum.relHumOut", 1, 5, 156, 4)
DeclareAlias2("building.HDirTil[2].weaBus.solAlt", "Solar altitude angle [rad|deg]",\
 "weaDat.altAng.alt", 1, 5, 161, 4)
DeclareAlias2("building.HDirTil[2].weaBus.solDec", "Solar declination angle [rad|deg]",\
 "weaDat.zenAng.decAng", 1, 5, 164, 4)
DeclareAlias2("building.HDirTil[2].weaBus.solHouAng", "Solar hour angle [rad|deg]",\
 "weaDat.zenAng.solHouAng", 1, 5, 163, 4)
DeclareAlias2("building.HDirTil[2].weaBus.solTim", "Solar time [s|s]", \
"weaDat.solTim.solTim", 1, 5, 138, 4)
DeclareAlias2("building.HDirTil[2].weaBus.solZen", "Zenith angle [rad|deg]", \
"weaDat.altAng.zen", 1, 5, 160, 4)
DeclareAlias2("building.HDirTil[2].weaBus.winDir", "Wind direction [rad|deg]", \
"weaDat.cheWinDir.nOut", 1, 5, 98, 4)
DeclareAlias2("building.HDirTil[2].weaBus.winSpe", "Wind speed [m/s]", \
"weaDat.cheWinSpe.winSpeOut", 1, 5, 94, 4)
DeclareAlias2("building.weaBus.HDifHor", "Radiation [W/m2]", "weaDat.cheDifHorRad.HOut", 1,\
 5, 88, 4)
DeclareAlias2("building.weaBus.HDirNor", "Radiation [W/m2]", "weaDat.cheDirNorRad.HOut", 1,\
 5, 90, 4)
DeclareAlias2("building.weaBus.HGloHor", "Radiation [W/m2]", "weaDat.cheGloHorRad.HOut", 1,\
 5, 86, 4)
DeclareAlias2("building.weaBus.HHorIR", "Horizontal infrared irradiation [W/m2]",\
 "weaDat.cheHorRad.HOut", 1, 5, 96, 4)
DeclareAlias2("building.weaBus.TDewPoi", "Output temperature [K|degC]", \
"weaDat.TDewPoi_in_internal", 1, 5, 143, 4)
DeclareAlias2("building.weaBus.celHei", "Ceiling height [m]", "weaDat.cheCeiHei.ceiHeiOut", 1,\
 5, 92, 4)
DeclareAlias2("building.weaBus.cloTim", "Connector of Real output signal [s]", \
"weaDat.modTim.y", 1, 5, 106, 4)
DeclareVariable("building.weaBus.lat", "Latitude of the location [rad|deg]", \
0.6565928646002667, 0.0,0.0,0.0,0,521)
DeclareVariable("building.weaBus.lon", "Longitude of the location [rad|deg]", \
-2.1362830044410592, 0.0,0.0,0.0,0,521)
DeclareAlias2("building.weaBus.nOpa", "Sky cover [0, 1] [1]", "weaDat.cheOpaSkyCov.nOut", 1,\
 5, 82, 4)
DeclareAlias2("building.weaBus.nTot", "Sky cover [0, 1] [1]", "weaDat.cheTotSkyCov.nOut", 1,\
 5, 78, 4)
DeclareAlias2("building.weaBus.pAtm", "Atmospheric pressure [Pa]", "weaDat.pAtm", 1,\
 7, 4, 4)
DeclareAlias2("building.weaBus.relHum", "Relative humidity [1]", \
"weaDat.cheRelHum.relHumOut", 1, 5, 156, 4)
DeclareAlias2("building.weaBus.solAlt", "Solar altitude angle [rad|deg]", \
"weaDat.altAng.alt", 1, 5, 161, 4)
DeclareAlias2("building.weaBus.solDec", "Solar declination angle [rad|deg]", \
"weaDat.zenAng.decAng", 1, 5, 164, 4)
DeclareAlias2("building.weaBus.solHouAng", "Solar hour angle [rad|deg]", \
"weaDat.zenAng.solHouAng", 1, 5, 163, 4)
DeclareAlias2("building.weaBus.solTim", "Solar time [s|s]", "weaDat.solTim.solTim", 1,\
 5, 138, 4)
DeclareAlias2("building.weaBus.solZen", "Zenith angle [rad|deg]", \
"weaDat.altAng.zen", 1, 5, 160, 4)
DeclareAlias2("building.weaBus.winDir", "Wind direction [rad|deg]", \
"weaDat.cheWinDir.nOut", 1, 5, 98, 4)
DeclareAlias2("building.weaBus.winSpe", "Wind speed [m/s]", "weaDat.cheWinSpe.winSpeOut", 1,\
 5, 94, 4)
EndNonAlias(1)

#define DymolaHaveUpdateInitVars 1
#include <dsblock5.c>

DYMOLA_STATIC void UpdateInitVars(double*time, double* X_, double* XD_, double* U_, double* DP_, int IP_[], Dymola_bool LP_[], double* F_, double* Y_, double* W_, double QZ_[], double duser_[], int iuser_[], void*cuser_[],struct DYNInstanceData*did_,int initialCall) {
if (initialCall) DYNX(did_->xInitial_var, 0)=DYNX(W_,612);
else if (DYNHReject) DYNX(W_,612)=did_->xInitial_var2[0]; else did_->xInitial_var2[0]=
  DYNX(W_,612);
}
StartDataBlock
StartPreBlock
pre(DYNX(W_,1330),"QCoo.nextTimeEvent", 0, 7);
preI(DYNX(W_,1331),"QCoo.nextTimeEventScaled", 0, 4);
pre(DYNX(W_,520),"building.intGai.nextTimeEvent", 0, 8);
preI(DYNX(W_,521),"building.intGai.nextTimeEventScaled", 0, 0);
preWD(DYNX(W_,825),"coo.hex.flowRegime", DYNX(W_,824), 3);
preWI(DYNX(W_,984),"tra.T_start", 0.0, 1);
preD(DYNX(W_,985),"tra.count", 0, 2);
preI(DYNX(W_,135),"weaDat.conTim.tNext", 0, 6);
preI(DYNX(W_,129),"weaDat.conTim1.tNext", 0, 5);
EndPreBlock
StartEqBlock
if (final_==2) {
DYNX(W_,1251) = DYNX(W_,1313);
}
DoRemember_(DYNX(W_,1251), DYNX(W_,1313), 0);
DoRemember_(DYNX(W_,500), 0.0, 8);
DoRemember_(DYNX(W_,499), 288.15, 6);
DoRemember_(DYNX(W_,463), 288.15, 7);
DoRemember_(DYNX(W_,1416), 0, 9);
DoRemember_(DYNX(W_,1362), DYNX(W_,1353), 10);
DoRemember_(DYNX(W_,1366), 0.0, 5);
DoRemember_(DYNX(W_,612), 0, 1);
DoRemember_(DYNX(F_,12), 0.0, 4);
DoRemember_(DYNX(W_,1246), 83680.0, 2);
DoRemember_(DYNX(W_,1152), 0.0, 3);
DYNSetRememberAcceptedBase(10);
EndEqBlock
UpdateQEvaluate(7)
EndDataBlock
  BreakSectionStart(6);

   /* Linear system of equations to solve. */
  /* Tag: simplified homotopy initialization.linear[1] */
  DYNX(W_,612) = 0;
  SolveScalarLinearParametric(2000.0+2.0*DYNX(W_,942),"2000.0+2.0*coo.val.dp_nominal_pos",
     DYNX(DP_,307)-DYNX(DP_,316),"souDis.p-sinDis.p", DYNX(W_,612),
    "coo.port_a1.m_flow");
  DYNX(W_,708) = 2000.0*DYNX(W_,612);
  DYNX(W_,932) = 2.0*DYNX(W_,942)*DYNX(W_,612);
   /* End of Equation Block */ 

  BreakSectionEnd()

BreakSectionFunctionStart(0);
BreakSectionFunctionCallNew(1);
BreakSectionFunctionCallNew(2);
BreakSectionFunctionCallNew(3);
BreakSectionFunctionCallNew(4);
BreakSectionFunctionCallNew(5);
BreakSectionFunctionCallNew(7);
BreakSectionFunctionCallNew(8);
BreakSectionFunctionCallNew(9);
BreakSectionFunctionEnd()
